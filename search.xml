<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[redis ziplist]]></title>
      <url>/2017/11/04/redis-ziplist/</url>
      <content type="html"><![CDATA[<h1 id="redis-skiplist"><a href="#redis-skiplist" class="headerlink" title="redis skiplist"></a>redis skiplist</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在redis底层实现中，skiplist作为支持列表键和哈希键的底层实现之一（并不唯一）。压缩列表是redis为了节约内存而开发的，是由一块连续编码的内存块构成。一个压缩列表可以包含任意多个结点，每个节点可以保存一个字节数组或者一个整数值。</p>
<p>下面为一个skiplist结构的内存布局：</p>
<p><img src="https://ws4.sinaimg.cn/large/006tKfTcly1fl6c1bboarj30we02sgln.jpg" alt=""></p>
<p>压缩列表各个组成部分的说明如下表所示：</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1fl6c2l619cj31680ecdk9.jpg" alt=""></p>
<p>压缩列表每个节点组成如下所示：</p>
<p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1fl6c3l0unaj30mw02et8p.jpg" alt=""></p>
<p>其中，<code>previous_entry_length</code>记录了前一个entry的长度，encoding记录了当前entry的编码格式，content对应此entry中记录的内容。</p>
<p>entry结构定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zlentry</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">  <span class="comment">// prevrawlen ：前一节点的长度</span></div><div class="line">  <span class="comment">// prevrawlensize ：编码 prevrawlen 所需的字节大小</span></div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> prevrawlensize, prevrawlen;</div><div class="line"></div><div class="line">  <span class="comment">// len ：当前节点值的长度</span></div><div class="line">  <span class="comment">// lensize ：编码 len 所需的字节大小</span></div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> lensize, len;</div><div class="line"></div><div class="line">  <span class="comment">// 当前节点 header 的大小</span></div><div class="line">  <span class="comment">// 等于 prevrawlensize + lensize</span></div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> headersize;</div><div class="line"></div><div class="line">  <span class="comment">// 当前节点值所使用的编码类型</span></div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding;</div><div class="line"></div><div class="line">  <span class="comment">// 指向当前节点的指针</span></div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</div><div class="line"></div><div class="line">&#125; zlentry;</div></pre></td></tr></table></figure>
<p>skiplist中entry的编码和内容之间的关系</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1fl6elsq2k7j31740nkjvl.jpg" alt=""></p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="创建ziplist"><a href="#创建ziplist" class="headerlink" title="创建ziplist"></a>创建ziplist</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistNew</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">  <span class="comment">// ZIPLIST_HEADER_SIZE 是 ziplist 表头的大小</span></div><div class="line">  <span class="comment">// 1 字节是表末端 ZIP_END 的大小</span></div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> bytes = ZIPLIST_HEADER_SIZE + <span class="number">1</span>;</div><div class="line"></div><div class="line">  <span class="comment">// 为表头和表末端分配空间</span></div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = zmalloc(bytes);</div><div class="line"></div><div class="line">  <span class="comment">// 初始化表属性</span></div><div class="line">  ZIPLIST_BYTES(zl) = intrev32ifbe(bytes);</div><div class="line">  ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(ZIPLIST_HEADER_SIZE);</div><div class="line">  ZIPLIST_LENGTH(zl) = <span class="number">0</span>;</div><div class="line">  <span class="comment">// 设置表末端标志</span></div><div class="line">  zl[bytes - <span class="number">1</span>] = ZIP_END;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> zl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调整ziplist的大小</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Resize the ziplist.</span></div><div class="line"> *</div><div class="line"> * 调整 ziplist 的大小为 len 字节。</div><div class="line"> *</div><div class="line"> * 当 ziplist 原有的大小小于 len 时，扩展 ziplist 不会改变 ziplist 原有的元素。</div><div class="line"> *</div><div class="line"> * T = O(N)</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistResize</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">int</span> len)</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">  <span class="comment">// 用 zrealloc ，扩展时不改变现有元素</span></div><div class="line">  zl = zrealloc(zl, len);</div><div class="line"></div><div class="line">  <span class="comment">// 更新 bytes 属性</span></div><div class="line">  ZIPLIST_BYTES(zl) = intrev32ifbe(len);</div><div class="line"></div><div class="line">  <span class="comment">// 重新设置表末端</span></div><div class="line">  zl[len - <span class="number">1</span>] = ZIP_END;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> zl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当对ziplist中某结点进行扩充之后，其后面紧跟的节点可能prevlen空间不足以存储其前面节点的长度值，此时需要进行连锁处理。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> unsigned <span class="keyword">char</span> *__ziplistCascadeUpdate(unsigned <span class="keyword">char</span> *zl, unsigned <span class="keyword">char</span> *p)</div><div class="line">&#123;</div><div class="line">  size_t curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), rawlen, rawlensize;</div><div class="line">  size_t offset, noffset, extra;</div><div class="line">  unsigned <span class="keyword">char</span> *np;</div><div class="line">  zlentry cur, <span class="keyword">next</span>;</div><div class="line"></div><div class="line">  <span class="comment">// T = O(N^2)</span></div><div class="line">  <span class="keyword">while</span> (p[<span class="number">0</span>] != ZIP_END)</div><div class="line">  &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 将 p 所指向的节点的信息保存到 cur 结构中</span></div><div class="line">    cur = zipEntry(p);</div><div class="line">    <span class="comment">// 当前节点的长度</span></div><div class="line">    rawlen = cur.headersize + cur.len;</div><div class="line">    <span class="comment">// 计算编码当前节点的长度所需的字节数</span></div><div class="line">    <span class="comment">// T = O(1)</span></div><div class="line">    rawlensize = zipPrevEncodeLength(<span class="keyword">NULL</span>, rawlen);</div><div class="line"></div><div class="line">    <span class="comment">/* Abort if there is no next entry. */</span></div><div class="line">    <span class="comment">// 如果已经没有后续空间需要更新了，跳出</span></div><div class="line">    <span class="keyword">if</span> (p[rawlen] == ZIP_END)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 取出后续节点的信息，保存到 next 结构中</span></div><div class="line">    <span class="comment">// T = O(1)</span></div><div class="line">    <span class="keyword">next</span> = zipEntry(p + rawlen);</div><div class="line"></div><div class="line">    <span class="comment">/* Abort when "prevlen" has not changed. */</span></div><div class="line">    <span class="comment">// 后续节点编码当前节点的空间已经足够，无须再进行任何处理，跳出</span></div><div class="line">    <span class="comment">// 可以证明，只要遇到一个空间足够的节点，</span></div><div class="line">    <span class="comment">// 那么这个节点之后的所有节点的空间都是足够的</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">next</span>.prevrawlen == rawlen)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">next</span>.prevrawlensize &lt; rawlensize)</div><div class="line">    &#123;</div><div class="line"></div><div class="line">      <span class="comment">/* The "prevlen" field of "next" needs more bytes to hold</span></div><div class="line">       * the raw length of "cur". */</div><div class="line">      <span class="comment">// 执行到这里，表示 next 空间的大小不足以编码 cur 的长度</span></div><div class="line">      <span class="comment">// 所以程序需要对 next 节点的（header 部分）空间进行扩展</span></div><div class="line"></div><div class="line">      <span class="comment">// 记录 p 的偏移量</span></div><div class="line">      offset = p - zl;</div><div class="line">      <span class="comment">// 计算需要增加的节点数量</span></div><div class="line">      extra = rawlensize - <span class="keyword">next</span>.prevrawlensize;</div><div class="line">      <span class="comment">// 扩展 zl 的大小</span></div><div class="line">      <span class="comment">// T = O(N)</span></div><div class="line">      zl = ziplistResize(zl, curlen + extra);</div><div class="line">      <span class="comment">// 还原指针 p</span></div><div class="line">      p = zl + offset;</div><div class="line"></div><div class="line">      <span class="comment">/* Current pointer and offset for next element. */</span></div><div class="line">      <span class="comment">// 记录下一节点的偏移量</span></div><div class="line">      np = p + rawlen;</div><div class="line">      noffset = np - zl;</div><div class="line"></div><div class="line">      <span class="comment">/* Update tail offset when next element is not the tail element. */</span></div><div class="line">      <span class="comment">// 当 next 节点不是表尾节点时，更新列表到表尾节点的偏移量</span></div><div class="line">      <span class="comment">//</span></div><div class="line">      <span class="comment">// 不用更新的情况（next 为表尾节点）：</span></div><div class="line">      <span class="comment">//</span></div><div class="line">      <span class="comment">// |     | next |      ==&gt;    |     | new next          |</span></div><div class="line">      <span class="comment">//       ^                          ^</span></div><div class="line">      <span class="comment">//       |                          |</span></div><div class="line">      <span class="comment">//     tail                        tail</span></div><div class="line">      <span class="comment">//</span></div><div class="line">      <span class="comment">// 需要更新的情况（next 不是表尾节点）：</span></div><div class="line">      <span class="comment">//</span></div><div class="line">      <span class="comment">// | next |     |   ==&gt;     | new next          |     |</span></div><div class="line">      <span class="comment">//        ^                        ^</span></div><div class="line">      <span class="comment">//        |                        |</span></div><div class="line">      <span class="comment">//    old tail                 old tail</span></div><div class="line">      <span class="comment">//</span></div><div class="line">      <span class="comment">// 更新之后：</span></div><div class="line">      <span class="comment">//</span></div><div class="line">      <span class="comment">// | new next          |     |</span></div><div class="line">      <span class="comment">//                     ^</span></div><div class="line">      <span class="comment">//                     |</span></div><div class="line">      <span class="comment">//                  new tail</span></div><div class="line">      <span class="comment">// T = O(1)</span></div><div class="line">      <span class="keyword">if</span> ((zl + intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))) != np)</div><div class="line">      &#123;</div><div class="line">        ZIPLIST_TAIL_OFFSET(zl) =</div><div class="line">            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)) + extra);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">/* Move the tail to the back. */</span></div><div class="line">      <span class="comment">// 向后移动 cur 节点之后的数据，为 cur 的新 header 腾出空间</span></div><div class="line">      <span class="comment">//</span></div><div class="line">      <span class="comment">// 示例：</span></div><div class="line">      <span class="comment">//</span></div><div class="line">      <span class="comment">// | header | value |  ==&gt;  | header |    | value |  ==&gt;  | header      | value |</span></div><div class="line">      <span class="comment">//                                   |&lt;--&gt;|</span></div><div class="line">      <span class="comment">//                            为新 header 腾出的空间</span></div><div class="line">      <span class="comment">// T = O(N)</span></div><div class="line">      memmove(np + rawlensize,</div><div class="line">              np + <span class="keyword">next</span>.prevrawlensize,</div><div class="line">              curlen - noffset - <span class="keyword">next</span>.prevrawlensize - <span class="number">1</span>);</div><div class="line">      <span class="comment">// 将新的前一节点长度值编码进新的 next 节点的 header</span></div><div class="line">      <span class="comment">// T = O(1)</span></div><div class="line">      zipPrevEncodeLength(np, rawlen);</div><div class="line"></div><div class="line">      <span class="comment">/* Advance the cursor */</span></div><div class="line">      <span class="comment">// 移动指针，继续处理下个节点</span></div><div class="line">      p += rawlen;</div><div class="line">      <span class="comment">/// 更新当前ziplist的长度值</span></div><div class="line">      curlen += extra;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">next</span>.prevrawlensize &gt; rawlensize)</div><div class="line">      &#123;</div><div class="line">        <span class="comment">/* This would result in shrinking, which we want to avoid.</span></div><div class="line">         * So, set "rawlen" in the available bytes. */</div><div class="line">        <span class="comment">// 执行到这里，说明 next 节点编码前置节点的 header 空间有 5 字节</span></div><div class="line">        <span class="comment">// 而编码 rawlen 只需要 1 字节</span></div><div class="line">        <span class="comment">// 但是程序不会对 next 进行缩小，</span></div><div class="line">        <span class="comment">// 所以这里只将 rawlen 写入 5 字节的 header 中就算了。</span></div><div class="line">        <span class="comment">// T = O(1)</span></div><div class="line">        zipPrevEncodeLengthForceLarge(p + rawlen, rawlen);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span></div><div class="line">      &#123;</div><div class="line">        <span class="comment">// 运行到这里，</span></div><div class="line">        <span class="comment">// 说明 cur 节点的长度正好可以编码到 next 节点的 header 中</span></div><div class="line">        <span class="comment">// T = O(1)</span></div><div class="line">        zipPrevEncodeLength(p + rawlen, rawlen);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">/* Stop here, as the raw length of "next" has not changed. */</span></div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> zl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在ziplist之中删除num个节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Delete "num" entries, starting at "p". Returns pointer to the ziplist.</span></div><div class="line"> *</div><div class="line"> * 从位置 p 开始，连续删除 num 个节点。</div><div class="line"> *</div><div class="line"> * 函数的返回值为处理删除操作之后的 ziplist 。</div><div class="line"> *</div><div class="line"> * T = O(N^2)</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistDelete(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> num)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i, totlen, deleted = <span class="number">0</span>;</div><div class="line">  <span class="keyword">size_t</span> offset;</div><div class="line">  <span class="keyword">int</span> nextdiff = <span class="number">0</span>;</div><div class="line">  zlentry first, tail;</div><div class="line"></div><div class="line">  <span class="comment">// 计算被删除节点总共占用的内存字节数</span></div><div class="line">  <span class="comment">// 以及被删除节点的总个数</span></div><div class="line">  <span class="comment">// T = O(N)</span></div><div class="line">  first = zipEntry(p);</div><div class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; p[<span class="number">0</span>] != ZIP_END &amp;&amp; i &lt; num; i++)</div><div class="line">  &#123;</div><div class="line">    p += zipRawEntryLength(p);</div><div class="line">    deleted++;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// totlen 是所有被删除节点总共占用的内存字节数</span></div><div class="line">  totlen = p - first.p;</div><div class="line">  <span class="keyword">if</span> (totlen &gt; <span class="number">0</span>)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END)</div><div class="line">    &#123;</div><div class="line"></div><div class="line">      <span class="comment">// 执行这里，表示被删除节点之后仍然有节点存在</span></div><div class="line"></div><div class="line">      <span class="comment">/* Storing `prevrawlen` in this entry may increase or decrease the</span></div><div class="line">       * number of bytes required compare to the current `prevrawlen`.</div><div class="line">       * There always is room to store this, because it was previously</div><div class="line">       * stored by an entry that is now being deleted. */</div><div class="line">      <span class="comment">// 因为位于被删除范围之后的第一个节点的 header 部分的大小</span></div><div class="line">      <span class="comment">// 可能容纳不了新的前置节点，所以需要计算新旧前置节点之间的字节数差</span></div><div class="line">      <span class="comment">// T = O(1)</span></div><div class="line">      nextdiff = zipPrevLenByteDiff(p, first.prevrawlen);</div><div class="line">      <span class="comment">// 如果有需要的话，将指针 p 后退 nextdiff 字节，为新 header 空出空间</span></div><div class="line">      p -= nextdiff;</div><div class="line">      <span class="comment">// 将 first 的前置节点的长度编码至 p 中</span></div><div class="line">      <span class="comment">// T = O(1)</span></div><div class="line">      zipPrevEncodeLength(p, first.prevrawlen);</div><div class="line"></div><div class="line">      <span class="comment">/* Update offset for tail */</span></div><div class="line">      <span class="comment">// 更新到达表尾的偏移量</span></div><div class="line">      <span class="comment">// T = O(1)</span></div><div class="line">      ZIPLIST_TAIL_OFFSET(zl) =</div><div class="line">          intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)) - totlen);</div><div class="line"></div><div class="line">      <span class="comment">/* When the tail contains more than one entry, we need to take</span></div><div class="line">       * "nextdiff" in account as well. Otherwise, a change in the</div><div class="line">       * size of prevlen doesn't have an effect on the *tail* offset. */</div><div class="line">      <span class="comment">// 如果被删除节点之后，有多于一个节点</span></div><div class="line">      <span class="comment">// 那么程序需要将 nextdiff 记录的字节数也计算到表尾偏移量中</span></div><div class="line">      <span class="comment">// 这样才能让表尾偏移量正确对齐表尾节点</span></div><div class="line">      <span class="comment">// T = O(1)</span></div><div class="line">      tail = zipEntry(p);</div><div class="line">      <span class="keyword">if</span> (p[tail.headersize + tail.len] != ZIP_END)</div><div class="line">      &#123;</div><div class="line">        ZIPLIST_TAIL_OFFSET(zl) =</div><div class="line">            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)) + nextdiff);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">/* Move tail to the front of the ziplist */</span></div><div class="line">      <span class="comment">// 从表尾向表头移动数据，覆盖被删除节点的数据</span></div><div class="line">      <span class="comment">// T = O(N)</span></div><div class="line">      memmove(first.p, p,</div><div class="line">              intrev32ifbe(ZIPLIST_BYTES(zl)) - (p - zl) - <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line"></div><div class="line">      <span class="comment">// 执行这里，表示被删除节点之后已经没有其他节点了</span></div><div class="line">      <span class="comment">// tail offset 定位到first前面的那个entry</span></div><div class="line">      <span class="comment">/* The entire tail was deleted. No need to move memory. */</span></div><div class="line">      <span class="comment">// T = O(1)</span></div><div class="line">      ZIPLIST_TAIL_OFFSET(zl) =</div><div class="line">          intrev32ifbe((first.p - zl) - first.prevrawlen);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* Resize and update length */</span></div><div class="line">    <span class="comment">// 缩小并更新 ziplist 的长度</span></div><div class="line">    offset = first.p - zl;</div><div class="line">    zl = ziplistResize(zl, intrev32ifbe(ZIPLIST_BYTES(zl)) - totlen + nextdiff);</div><div class="line">    ZIPLIST_INCR_LENGTH(zl, -deleted);</div><div class="line">    p = zl + offset;</div><div class="line"></div><div class="line">    <span class="comment">/* When nextdiff != 0, the raw length of the next entry has changed, so</span></div><div class="line">     * we need to cascade the update throughout the ziplist */</div><div class="line">    <span class="comment">// 如果 p 所指向的节点的大小已经变更，那么进行级联更新</span></div><div class="line">    <span class="comment">// 检查 p 之后的所有节点是否符合 ziplist 的编码要求</span></div><div class="line">    <span class="comment">// T = O(N^2)</span></div><div class="line">    <span class="keyword">if</span> (nextdiff != <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">      <span class="comment">// 进行空间扩展检查</span></div><div class="line">      zl = __ziplistCascadeUpdate(zl, p);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> zl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ziplist插入</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 根据指针 p 所指定的位置，将长度为 slen 的字符串 s 插入到 zl 中。</div><div class="line"> *</div><div class="line"> * 函数的返回值为完成插入操作之后的 ziplist</div><div class="line"> *</div><div class="line"> * T = O(N^2)</div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistInsert(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen)</div><div class="line">&#123;</div><div class="line">  <span class="comment">// 记录当前 ziplist 的长度</span></div><div class="line">  <span class="keyword">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen, prevlen = <span class="number">0</span>;</div><div class="line">  <span class="keyword">size_t</span> offset;</div><div class="line">  <span class="keyword">int</span> nextdiff = <span class="number">0</span>;</div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding = <span class="number">0</span>;</div><div class="line">  <span class="keyword">long</span> <span class="keyword">long</span> value = <span class="number">123456789</span>; <span class="comment">/* initialized to avoid warning. Using a value</span></div><div class="line">                                    that is easy to see if for some reason</div><div class="line">                                    we use it uninitialized. */</div><div class="line">  zlentry entry, tail;</div><div class="line"></div><div class="line">  <span class="comment">/* Find out prevlen for the entry that is inserted. */</span></div><div class="line">  <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END)</div><div class="line">  &#123;</div><div class="line">    <span class="comment">// 如果 p[0] 不指向列表末端，说明列表非空，并且 p 正指向列表的其中一个节点</span></div><div class="line">    <span class="comment">// 那么取出 p 所指向节点的信息，并将它保存到 entry 结构中</span></div><div class="line">    <span class="comment">// 然后用 prevlen 变量记录前置节点的长度</span></div><div class="line">    <span class="comment">// （当插入新节点之后 p 所指向的节点就成了新节点的前置节点）</span></div><div class="line">    <span class="comment">// T = O(1)</span></div><div class="line">    entry = zipEntry(p);</div><div class="line">    prevlen = entry.prevrawlen;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">  &#123;</div><div class="line">    <span class="comment">// 如果 p 指向表尾末端，那么程序需要检查列表是否为：</span></div><div class="line">    <span class="comment">// 1)如果 ptail 也指向 ZIP_END ，那么列表为空；</span></div><div class="line">    <span class="comment">// 2)如果列表不为空，那么 ptail 将指向列表的最后一个节点。</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *ptail = ZIPLIST_ENTRY_TAIL(zl);</div><div class="line">    <span class="keyword">if</span> (ptail[<span class="number">0</span>] != ZIP_END)</div><div class="line">    &#123;</div><div class="line">      <span class="comment">// 表尾节点为新节点的前置节点</span></div><div class="line"></div><div class="line">      <span class="comment">// 取出表尾节点的长度</span></div><div class="line">      <span class="comment">// T = O(1)</span></div><div class="line">      prevlen = zipRawEntryLength(ptail);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* See if the entry can be encoded */</span></div><div class="line">  <span class="comment">// 尝试看能否将输入字符串转换为整数，如果成功的话：</span></div><div class="line">  <span class="comment">// 1)value 将保存转换后的整数值</span></div><div class="line">  <span class="comment">// 2)encoding 则保存适用于 value 的编码方式</span></div><div class="line">  <span class="comment">// 无论使用什么编码， reqlen 都保存节点值的长度</span></div><div class="line">  <span class="comment">// T = O(N)</span></div><div class="line">  <span class="keyword">if</span> (zipTryEncoding(s, slen, &amp;value, &amp;encoding))</div><div class="line">  &#123;</div><div class="line">    <span class="comment">/* 'encoding' is set to the appropriate integer encoding */</span></div><div class="line">    reqlen = zipIntSize(encoding);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">  &#123;</div><div class="line">    <span class="comment">/* 'encoding' is untouched, however zipEncodeLength will use the</span></div><div class="line">     * string length to figure out how to encode it. */</div><div class="line">    reqlen = slen;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">/* We need space for both the length of the previous entry and</span></div><div class="line">   * the length of the payload. */</div><div class="line">  <span class="comment">// 计算编码前置节点的长度所需的大小</span></div><div class="line">  <span class="comment">// T = O(1)</span></div><div class="line">  reqlen += zipPrevEncodeLength(<span class="literal">NULL</span>, prevlen);</div><div class="line">  <span class="comment">// 计算编码当前节点值所需的大小</span></div><div class="line">  <span class="comment">// T = O(1)</span></div><div class="line">  reqlen += zipEncodeLength(<span class="literal">NULL</span>, encoding, slen);</div><div class="line"></div><div class="line">  <span class="comment">/* When the insert position is not equal to the tail, we need to</span></div><div class="line">   * make sure that the next entry can hold this entry's length in</div><div class="line">   * its prevlen field. */</div><div class="line">  <span class="comment">// 只要新节点不是被添加到列表末端，</span></div><div class="line">  <span class="comment">// 那么程序就需要检查看 p 所指向的节点（的 header）能否编码新节点的长度。</span></div><div class="line">  <span class="comment">// nextdiff 保存了新旧编码之间的字节大小差，如果这个值大于 0</span></div><div class="line">  <span class="comment">// 那么说明需要对 p 所指向的节点（的 header ）进行扩展</span></div><div class="line">  <span class="comment">// T = O(1)</span></div><div class="line">  nextdiff = (p[<span class="number">0</span>] != ZIP_END) ? zipPrevLenByteDiff(p, reqlen) : <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="comment">/* Store offset because a realloc may change the address of zl. */</span></div><div class="line">  <span class="comment">// 因为重分配空间可能会改变 zl 的地址</span></div><div class="line">  <span class="comment">// 所以在分配之前，需要记录 zl 到 p 的偏移量，然后在分配之后依靠偏移量还原 p</span></div><div class="line">  offset = p - zl;</div><div class="line">  <span class="comment">// curlen 是 ziplist 原来的长度</span></div><div class="line">  <span class="comment">// reqlen 是整个新节点的长度</span></div><div class="line">  <span class="comment">// nextdiff 是新节点的后继节点扩展 header 的长度（要么 0 字节，要么 4 个字节）</span></div><div class="line">  <span class="comment">// T = O(N)</span></div><div class="line">  zl = ziplistResize(zl, curlen + reqlen + nextdiff);</div><div class="line">  p = zl + offset;</div><div class="line"></div><div class="line">  <span class="comment">/* Apply memory move when necessary and update tail offset. */</span></div><div class="line">  <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END)</div><div class="line">  &#123;</div><div class="line">    <span class="comment">// 新元素之后还有节点，因为新元素的加入，需要对这些原有节点进行调整</span></div><div class="line"></div><div class="line">    <span class="comment">/* Subtract one because of the ZIP_END bytes */</span></div><div class="line">    <span class="comment">// 移动现有元素，为新元素的插入空间腾出位置 (有部分填充数据 p-nextdiff -&gt; p)</span></div><div class="line">    <span class="comment">// T = O(N)</span></div><div class="line">    memmove(p + reqlen, p - nextdiff, curlen - offset - <span class="number">1</span> + nextdiff);</div><div class="line"></div><div class="line">    <span class="comment">/* Encode this entry's raw length in the next entry. */</span></div><div class="line">    <span class="comment">// 将新节点的长度编码至后置节点</span></div><div class="line">    <span class="comment">// p+reqlen 定位到后置节点</span></div><div class="line">    <span class="comment">// reqlen 是新节点的长度</span></div><div class="line">    <span class="comment">// T = O(1)</span></div><div class="line">    zipPrevEncodeLength(p + reqlen, reqlen);</div><div class="line"></div><div class="line">    <span class="comment">/* Update offset for tail */</span></div><div class="line">    <span class="comment">// 更新到达表尾的偏移量，将新节点的长度也算上</span></div><div class="line">    ZIPLIST_TAIL_OFFSET(zl) =</div><div class="line">        intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)) + reqlen);</div><div class="line"></div><div class="line">    <span class="comment">/* When the tail contains more than one entry, we need to take</span></div><div class="line">     * "nextdiff" in account as well. Otherwise, a change in the</div><div class="line">     * size of prevlen doesn't have an effect on the *tail* offset. */</div><div class="line">    <span class="comment">// 如果新节点的后面有多于一个节点</span></div><div class="line">    <span class="comment">// 那么程序需要将 nextdiff 记录的字节数也计算到表尾偏移量中</span></div><div class="line">    <span class="comment">// 这样才能让表尾偏移量正确对齐表尾节点</span></div><div class="line">    <span class="comment">// T = O(1)</span></div><div class="line">    tail = zipEntry(p + reqlen);</div><div class="line">    <span class="keyword">if</span> (p[reqlen + tail.headersize + tail.len] != ZIP_END)</div><div class="line">    &#123;</div><div class="line">      ZIPLIST_TAIL_OFFSET(zl) =</div><div class="line">          intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl)) + nextdiff);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">  &#123;</div><div class="line">    <span class="comment">/* This element will be the new tail. */</span></div><div class="line">    <span class="comment">// 新元素是新的表尾节点</span></div><div class="line">    ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p - zl);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* When nextdiff != 0, the raw length of the next entry has changed, so</span></div><div class="line">   * we need to cascade the update throughout the ziplist */</div><div class="line">  <span class="comment">// 当 nextdiff != 0 时，新节点的后继节点的（header 部分）长度已经被改变，</span></div><div class="line">  <span class="comment">// 所以需要级联地更新后续的节点</span></div><div class="line">  <span class="keyword">if</span> (nextdiff != <span class="number">0</span>)</div><div class="line">  &#123;</div><div class="line">    offset = p - zl;</div><div class="line">    <span class="comment">// T  = O(N^2)</span></div><div class="line">    zl = __ziplistCascadeUpdate(zl, p + reqlen);</div><div class="line">    p = zl + offset;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* Write the entry */</span></div><div class="line">  <span class="comment">// 一切搞定，将前置节点的长度写入新节点的 header</span></div><div class="line">  p += zipPrevEncodeLength(p, prevlen);</div><div class="line">  <span class="comment">// 将节点值的长度写入新节点的 header</span></div><div class="line">  p += zipEncodeLength(p, encoding, slen);</div><div class="line">  <span class="comment">// 写入节点值</span></div><div class="line">  <span class="keyword">if</span> (ZIP_IS_STR(encoding))</div><div class="line">  &#123;</div><div class="line">    <span class="comment">/// string</span></div><div class="line">    <span class="comment">// T = O(N)</span></div><div class="line">    <span class="built_in">memcpy</span>(p, s, slen);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">  &#123;</div><div class="line">    <span class="comment">/// integer</span></div><div class="line">    <span class="comment">// T = O(1)</span></div><div class="line">    zipSaveInteger(p, value, encoding);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 更新列表的节点数量计数器</span></div><div class="line">  <span class="comment">// T = O(1)</span></div><div class="line">  ZIPLIST_INCR_LENGTH(zl, <span class="number">1</span>);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> zl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在skiplist之中查找</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Find pointer to the entry equal to the specified entry.</span></div><div class="line"> *</div><div class="line"> * 寻找节点值和 vstr 相等的列表节点，并返回该节点的指针。</div><div class="line"> *</div><div class="line"> * Skip 'skip' entries between every comparison.</div><div class="line"> *</div><div class="line"> * 每次比对之前都跳过 skip 个节点。</div><div class="line"> *</div><div class="line"> * Returns NULL when the field could not be found.</div><div class="line"> *</div><div class="line"> * 如果找不到相应的节点，则返回 NULL 。</div><div class="line"> *</div><div class="line"> * T = O(N^2)</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">ziplistFind</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *vstr, <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen, <span class="keyword">unsigned</span> <span class="keyword">int</span> skip)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> skipcnt = <span class="number">0</span>;</div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> vencoding = <span class="number">0</span>;</div><div class="line">  <span class="keyword">long</span> <span class="keyword">long</span> vll = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="comment">// 只要未到达列表末端，就一直迭代</span></div><div class="line">  <span class="comment">// T = O(N^2)</span></div><div class="line">  <span class="keyword">while</span> (p[<span class="number">0</span>] != ZIP_END)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevlensize, encoding, lensize, len;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *q;</div><div class="line"></div><div class="line">    ZIP_DECODE_PREVLENSIZE(p, prevlensize);</div><div class="line">    ZIP_DECODE_LENGTH(p + prevlensize, encoding, lensize, len);</div><div class="line">    q = p + prevlensize + lensize;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (skipcnt == <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line"></div><div class="line">      <span class="comment">/* Compare current entry with specified entry */</span></div><div class="line">      <span class="comment">// 对比字符串值</span></div><div class="line">      <span class="comment">// T = O(N)</span></div><div class="line">      <span class="keyword">if</span> (ZIP_IS_STR(encoding))</div><div class="line">      &#123;</div><div class="line">        <span class="keyword">if</span> (len == vlen &amp;&amp; <span class="built_in">memcmp</span>(q, vstr, vlen) == <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">          <span class="keyword">return</span> p;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span></div><div class="line">      &#123;</div><div class="line">        <span class="comment">/* Find out if the searched field can be encoded. Note that</span></div><div class="line">         * we do it only the first time, once done vencoding is set</div><div class="line">         * to non-zero and vll is set to the integer value. */</div><div class="line">        <span class="comment">// 因为传入值有可能被编码了，</span></div><div class="line">        <span class="comment">// 所以当第一次进行值对比时，程序会对传入值进行解码</span></div><div class="line">        <span class="comment">// 这个解码操作只会进行一次</span></div><div class="line">        <span class="keyword">if</span> (vencoding == <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">          <span class="keyword">if</span> (!zipTryEncoding(vstr, vlen, &amp;vll, &amp;vencoding))</div><div class="line">          &#123;</div><div class="line">            <span class="comment">/* If the entry can't be encoded we set it to</span></div><div class="line">             * UCHAR_MAX so that we don't retry again the next</div><div class="line">             * time. */</div><div class="line">            vencoding = UCHAR_MAX;</div><div class="line">          &#125;</div><div class="line">          <span class="comment">/* Must be non-zero by now */</span></div><div class="line">          assert(vencoding);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">/* Compare current entry with specified entry, do it only</span></div><div class="line">         * if vencoding != UCHAR_MAX because if there is no encoding</div><div class="line">         * possible for the field it can't be a valid integer. */</div><div class="line">        <span class="comment">// 对比整数值</span></div><div class="line">        <span class="keyword">if</span> (vencoding != UCHAR_MAX)</div><div class="line">        &#123;</div><div class="line">          <span class="comment">// T = O(1)</span></div><div class="line">          <span class="keyword">long</span> <span class="keyword">long</span> ll = zipLoadInteger(q, encoding);</div><div class="line">          <span class="keyword">if</span> (ll == vll)</div><div class="line">          &#123;</div><div class="line">            <span class="keyword">return</span> p;</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">/* Reset skip count */</span></div><div class="line">      skipcnt = skip;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">      <span class="comment">/* Skip entry */</span></div><div class="line">      skipcnt--;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* Move to next entry */</span></div><div class="line">    <span class="comment">// 后移指针，指向后置节点</span></div><div class="line">    p = q + len;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 没有找到指定的节点</span></div><div class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>返回skiplist的长度，如果长度超过<code>UINT16_MAX</code>，需要遍历整个skiplist才能得到整个压缩列表的长度。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> ziplistLen(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl)</div><div class="line">&#123;</div><div class="line"></div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="comment">// 节点数小于 UINT16_MAX</span></div><div class="line">  <span class="comment">// T = O(1)</span></div><div class="line">  <span class="keyword">if</span> (intrev16ifbe(ZIPLIST_LENGTH(zl)) &lt; <span class="built_in">UINT16_MAX</span>)</div><div class="line">  &#123;</div><div class="line">    len = intrev16ifbe(ZIPLIST_LENGTH(zl));</div><div class="line"></div><div class="line">    <span class="comment">// 节点数大于 UINT16_MAX 时，需要遍历整个列表才能计算出节点数</span></div><div class="line">    <span class="comment">// T = O(N)</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">  &#123;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = zl + ZIPLIST_HEADER_SIZE;</div><div class="line">    <span class="keyword">while</span> (*p != ZIP_END)</div><div class="line">    &#123;</div><div class="line">      p += zipRawEntryLength(p);</div><div class="line">      len++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* Re-store length if small enough */</span></div><div class="line">    <span class="keyword">if</span> (len &lt; <span class="built_in">UINT16_MAX</span>)</div><div class="line">      ZIPLIST_LENGTH(zl) = intrev16ifbe(len);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> len;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis 字符串]]></title>
      <url>/2017/11/04/redis-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      <content type="html"><![CDATA[<h1 id="redis-字符串"><a href="#redis-字符串" class="headerlink" title="redis 字符串"></a>redis 字符串</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在c语言之中，并没有提供string，所有对字符串的操作需要直接操作char型数组，这带来了繁琐的操作，稍有不慎就可能造成缓冲区溢出的错误，而且重复的内存分配和释放操作会拖慢整体的运行速度。因而redis实现了sds结构，用来代替C++中的string，存储二进制安全的字符串。</p>
<p>sds结构定义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 保存字符串对象的结构</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">  <span class="comment">// buf 中已占用空间的长度</span></div><div class="line">  <span class="keyword">int</span> len;</div><div class="line"></div><div class="line">  <span class="comment">// buf 中剩余可用空间的长度</span></div><div class="line">  <span class="keyword">int</span> <span class="built_in">free</span>;</div><div class="line"></div><div class="line">  <span class="comment">// 数据空间</span></div><div class="line">  <span class="keyword">char</span> buf[];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>sds结构图示:</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1fl6atyivzbj30ms06gq2z.jpg" alt=""></p>
<h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div><div class="line">458</div><div class="line">459</div><div class="line">460</div><div class="line">461</div><div class="line">462</div><div class="line">463</div><div class="line">464</div><div class="line">465</div><div class="line">466</div><div class="line">467</div><div class="line">468</div><div class="line">469</div><div class="line">470</div><div class="line">471</div><div class="line">472</div><div class="line">473</div><div class="line">474</div><div class="line">475</div><div class="line">476</div><div class="line">477</div><div class="line">478</div><div class="line">479</div><div class="line">480</div><div class="line">481</div><div class="line">482</div><div class="line">483</div><div class="line">484</div><div class="line">485</div><div class="line">486</div><div class="line">487</div><div class="line">488</div><div class="line">489</div><div class="line">490</div><div class="line">491</div><div class="line">492</div><div class="line">493</div><div class="line">494</div><div class="line">495</div><div class="line">496</div><div class="line">497</div><div class="line">498</div><div class="line">499</div><div class="line">500</div><div class="line">501</div><div class="line">502</div><div class="line">503</div><div class="line">504</div><div class="line">505</div><div class="line">506</div><div class="line">507</div><div class="line">508</div><div class="line">509</div><div class="line">510</div><div class="line">511</div><div class="line">512</div><div class="line">513</div><div class="line">514</div><div class="line">515</div><div class="line">516</div><div class="line">517</div><div class="line">518</div><div class="line">519</div><div class="line">520</div><div class="line">521</div><div class="line">522</div><div class="line">523</div><div class="line">524</div><div class="line">525</div><div class="line">526</div><div class="line">527</div><div class="line">528</div><div class="line">529</div><div class="line">530</div><div class="line">531</div><div class="line">532</div><div class="line">533</div><div class="line">534</div><div class="line">535</div><div class="line">536</div><div class="line">537</div><div class="line">538</div><div class="line">539</div><div class="line">540</div><div class="line">541</div><div class="line">542</div><div class="line">543</div><div class="line">544</div><div class="line">545</div><div class="line">546</div><div class="line">547</div><div class="line">548</div><div class="line">549</div><div class="line">550</div><div class="line">551</div><div class="line">552</div><div class="line">553</div><div class="line">554</div><div class="line">555</div><div class="line">556</div><div class="line">557</div><div class="line">558</div><div class="line">559</div><div class="line">560</div><div class="line">561</div><div class="line">562</div><div class="line">563</div><div class="line">564</div><div class="line">565</div><div class="line">566</div><div class="line">567</div><div class="line">568</div><div class="line">569</div><div class="line">570</div><div class="line">571</div><div class="line">572</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 根据给定的初始化字符串 init 和字符串长度 initlen</div><div class="line"> * 创建一个新的 sds</div><div class="line"> *</div><div class="line"> * 参数</div><div class="line"> *  init ：初始化字符串指针</div><div class="line"> *  initlen ：初始化字符串的长度</div><div class="line"> *</div><div class="line"> * 返回值</div><div class="line"> *  sds ：创建成功返回 sdshdr 相对应的 sds</div><div class="line"> *        创建失败返回 NULL</div><div class="line"> *</div><div class="line"> * 复杂度</div><div class="line"> *  T = O(N)</div><div class="line"> */</div><div class="line"><span class="comment">/* Create a new sds string with the content specified by the 'init' pointer</span></div><div class="line"> * and 'initlen'.</div><div class="line"> * If NULL is used for 'init' the string is initialized with zero bytes.</div><div class="line"> *</div><div class="line"> * The string is always null-termined (all the sds strings are, always) so</div><div class="line"> * even if you create an sds string with:</div><div class="line"> *</div><div class="line"> * mystring = sdsnewlen("abc",3");</div><div class="line"> *</div><div class="line"> * You can print the string with printf() as there is an implicit \0 at the</div><div class="line"> * end of the string. However the string is binary safe and can contain</div><div class="line"> * \0 characters in the middle, as the length is stored in the sds header. */</div><div class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></div><div class="line"></div><div class="line">  <span class="comment">// 根据是否有初始化内容，选择适当的内存分配方式</span></div><div class="line">  <span class="comment">// T = O(N)</span></div><div class="line">  <span class="keyword">if</span> (init)</div><div class="line">  &#123;</div><div class="line">    <span class="comment">// zmalloc 不初始化所分配的内存</span></div><div class="line">    sh = zmalloc(<span class="keyword">sizeof</span>(struct sdshdr) + initlen + <span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">  &#123;</div><div class="line">    <span class="comment">// zcalloc 将分配的内存全部初始化为 0</span></div><div class="line">    sh = zcalloc(<span class="keyword">sizeof</span>(struct sdshdr) + initlen + <span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 内存分配失败，返回</span></div><div class="line">  <span class="keyword">if</span> (sh == <span class="literal">NULL</span>)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 设置初始化长度</span></div><div class="line">  sh-&gt;len = initlen;</div><div class="line">  <span class="comment">// 新 sds 不预留任何空间</span></div><div class="line">  sh-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</div><div class="line">  <span class="comment">// 如果有指定初始化内容，将它们复制到 sdshdr 的 buf 中</span></div><div class="line">  <span class="comment">// T = O(N)</span></div><div class="line">  <span class="keyword">if</span> (initlen &amp;&amp; init)</div><div class="line">    <span class="built_in">memcpy</span>(sh-&gt;buf, init, initlen);</div><div class="line">  <span class="comment">// 以 \0 结尾</span></div><div class="line">  sh-&gt;buf[initlen] = <span class="string">'\0'</span>;</div><div class="line"></div><div class="line">  <span class="comment">// 返回 buf 部分，而不是整个 sdshdr</span></div><div class="line">  <span class="keyword">return</span> (<span class="keyword">char</span> *) sh-&gt;buf;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 创建并返回一个只保存了空字符串 "" 的 sds</div><div class="line"> *</div><div class="line"> * 返回值</div><div class="line"> *  sds ：创建成功返回 sdshdr 相对应的 sds</div><div class="line"> *        创建失败返回 NULL</div><div class="line"> *</div><div class="line"> * 复杂度</div><div class="line"> *  T = O(1)</div><div class="line"> */</div><div class="line"><span class="comment">/* Create an empty (zero length) sds string. Even in this case the string</span></div><div class="line"> * always has an implicit null term. */</div><div class="line"><span class="function">sds <span class="title">sdsempty</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> sdsnewlen(<span class="string">""</span>, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 根据给定字符串 init ，创建一个包含同样字符串的 sds</div><div class="line"> *</div><div class="line"> * 参数</div><div class="line"> *  init ：如果输入为 NULL ，那么创建一个空白 sds</div><div class="line"> *         否则，新创建的 sds 中包含和 init 内容相同字符串</div><div class="line"> *</div><div class="line"> * 返回值</div><div class="line"> *  sds ：创建成功返回 sdshdr 相对应的 sds</div><div class="line"> *        创建失败返回 NULL</div><div class="line"> *</div><div class="line"> * 复杂度</div><div class="line"> *  T = O(N)</div><div class="line"> */</div><div class="line"><span class="comment">/* Create a new sds string starting from a null termined C string. */</span></div><div class="line"><span class="function">sds <span class="title">sdsnew</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *init)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">size_t</span> initlen = (init == <span class="literal">NULL</span>) ? <span class="number">0</span> : <span class="built_in">strlen</span>(init);</div><div class="line">  <span class="keyword">return</span> sdsnewlen(init, initlen);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 复制给定 sds 的副本</div><div class="line"> *</div><div class="line"> * 返回值</div><div class="line"> *  sds ：创建成功返回输入 sds 的副本</div><div class="line"> *        创建失败返回 NULL</div><div class="line"> *</div><div class="line"> * 复杂度</div><div class="line"> *  T = O(N)</div><div class="line"> */</div><div class="line"><span class="comment">/* Duplicate an sds string. */</span></div><div class="line"><span class="function">sds <span class="title">sdsdup</span><span class="params">(<span class="keyword">const</span> sds s)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> sdsnewlen(s, sdslen(s));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 释放给定的 sds</div><div class="line"> *</div><div class="line"> * 复杂度</div><div class="line"> *  T = O(N)</div><div class="line"> */</div><div class="line"><span class="comment">/* Free an sds string. No operation is performed if 's' is NULL. */</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsfree</span><span class="params">(sds s)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> (s == <span class="literal">NULL</span>)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">/// 释放整个sds结构体</span></div><div class="line">  zfree(s - <span class="keyword">sizeof</span>(struct sdshdr));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 未使用函数，可能已废弃</span></div><div class="line"><span class="comment">/* Set the sds string length to the length as obtained with strlen(), so</span></div><div class="line"> * considering as content only up to the first null term character.</div><div class="line"> *</div><div class="line"> * This function is useful when the sds string is hacked manually in some</div><div class="line"> * way, like in the following example:</div><div class="line"> *</div><div class="line"> * s = sdsnew("foobar");</div><div class="line"> * s[2] = '\0';</div><div class="line"> * sdsupdatelen(s);</div><div class="line"> * printf("%d\n", sdslen(s));</div><div class="line"> *</div><div class="line"> * The output will be "2", but if we comment out the call to sdsupdatelen()</div><div class="line"> * the output will be "6" as the string was modified but the logical length</div><div class="line"> * remains 6 bytes. */</div><div class="line"><span class="comment">/// 缩短了sds的长度之后，更新sds结构体中各成员的值</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsupdatelen</span><span class="params">(sds s)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span> *) (<span class="title">s</span> - (<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></div><div class="line">  <span class="keyword">int</span> reallen = <span class="built_in">strlen</span>(s);</div><div class="line">  sh-&gt;<span class="built_in">free</span> += (sh-&gt;len - reallen);</div><div class="line">  sh-&gt;len = reallen;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 在不释放 SDS 的字符串空间的情况下，</div><div class="line"> * 重置 SDS 所保存的字符串为空字符串。</div><div class="line"> *</div><div class="line"> * 复杂度</div><div class="line"> *  T = O(1)</div><div class="line"> */</div><div class="line"><span class="comment">/* Modify an sds string on-place to make it empty (zero length).</span></div><div class="line"> * However all the existing buffer is not discarded but set as free space</div><div class="line"> * so that next append operations will not require allocations up to the</div><div class="line"> * number of bytes previously available. */</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsclear</span><span class="params">(sds s)</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">  <span class="comment">// 取出 sdshdr</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span> *) (<span class="title">s</span> - (<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></div><div class="line"></div><div class="line">  <span class="comment">// 重新计算属性</span></div><div class="line">  sh-&gt;<span class="built_in">free</span> += sh-&gt;len;</div><div class="line">  sh-&gt;len = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="comment">// 将结束符放到最前面（相当于惰性地删除 buf 中的内容）</span></div><div class="line">  sh-&gt;buf[<span class="number">0</span>] = <span class="string">'\0'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Enlarge the free space at the end of the sds string so that the caller</span></div><div class="line"> * is sure that after calling this function can overwrite up to addlen</div><div class="line"> * bytes after the end of the string, plus one more byte for nul term.</div><div class="line"> * </div><div class="line"> * Note: this does not change the *length* of the sds string as returned</div><div class="line"> * by sdslen(), but only the free buffer space we have. */</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 对 sds 中 buf 的长度进行扩展，确保在函数执行之后，</div><div class="line"> * buf 至少会有 addlen + 1 长度的空余空间</div><div class="line"> * （额外的 1 字节是为 \0 准备的）</div><div class="line"> *</div><div class="line"> * 返回值</div><div class="line"> *  sds ：扩展成功返回扩展后的 sds</div><div class="line"> *        扩展失败返回 NULL</div><div class="line"> *</div><div class="line"> * 复杂度</div><div class="line"> *  T = O(N)</div><div class="line"> */</div><div class="line"><span class="function">sds <span class="title">sdsMakeRoomFor</span><span class="params">(sds s, <span class="keyword">size_t</span> addlen)</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>, *<span class="title">newsh</span>;</span></div><div class="line"></div><div class="line">  <span class="comment">// 获取 s 目前的空余空间长度</span></div><div class="line">  <span class="keyword">size_t</span> <span class="built_in">free</span> = sdsavail(s);</div><div class="line"></div><div class="line">  <span class="keyword">size_t</span> len, newlen;</div><div class="line"></div><div class="line">  <span class="comment">// s 目前的空余空间已经足够，无须再进行扩展，直接返回</span></div><div class="line">  <span class="keyword">if</span> (<span class="built_in">free</span> &gt;= addlen)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 获取 s 目前已占用空间的长度</span></div><div class="line">  len = sdslen(s);</div><div class="line">  sh = (<span class="keyword">void</span> *) (s - (<span class="keyword">sizeof</span>(struct sdshdr)));</div><div class="line"></div><div class="line">  <span class="comment">// s 最少需要的长度</span></div><div class="line">  newlen = (len + addlen);</div><div class="line"></div><div class="line">  <span class="comment">/// 分配策略，如果new_len &lt; SDS_MAX_PREALLOC，那么分配的空余空间为new_len，</span></div><div class="line">  <span class="comment">/// 否则分配的空余空间为 SDS_MAX_PREALLOC</span></div><div class="line">  <span class="comment">// 根据新长度，为 s 分配新空间所需的大小</span></div><div class="line">  <span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</div><div class="line">  &#123;</div><div class="line">    <span class="comment">// 如果新长度小于 SDS_MAX_PREALLOC</span></div><div class="line">    <span class="comment">// 那么为它分配两倍于所需长度的空间</span></div><div class="line">    newlen *= <span class="number">2</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">  &#123;</div><div class="line">    <span class="comment">// 否则，分配长度为目前长度加上 SDS_MAX_PREALLOC</span></div><div class="line">    <span class="comment">/// 默认为1M</span></div><div class="line">    newlen += SDS_MAX_PREALLOC;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// T = O(N)</span></div><div class="line">  newsh = zrealloc(sh, <span class="keyword">sizeof</span>(struct sdshdr) + newlen + <span class="number">1</span>);</div><div class="line"></div><div class="line">  <span class="comment">// 内存不足，分配失败，返回</span></div><div class="line">  <span class="keyword">if</span> (newsh == <span class="literal">NULL</span>)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 更新 sds 的空余长度</span></div><div class="line">  newsh-&gt;<span class="built_in">free</span> = newlen - len;</div><div class="line"></div><div class="line">  <span class="comment">// 返回 sds</span></div><div class="line">  <span class="keyword">return</span> newsh-&gt;buf;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 回收 sds 中的空闲空间，</div><div class="line"> * 回收不会对 sds 中保存的字符串内容做任何修改。</div><div class="line"> *</div><div class="line"> * 返回值</div><div class="line"> *  sds ：内存调整后的 sds</div><div class="line"> *</div><div class="line"> * 复杂度</div><div class="line"> *  T = O(N)</div><div class="line"> */</div><div class="line"><span class="comment">/* Reallocate the sds string so that it has no free space at the end. The</span></div><div class="line"> * contained string remains not altered, but next concatenation operations</div><div class="line"> * will require a reallocation.</div><div class="line"> *</div><div class="line"> * After the call, the passed sds string is no longer valid and all the</div><div class="line"> * references must be substituted with the new pointer returned by the call. */</div><div class="line"><span class="comment">/// sds中不会占用任何空余的内存空间</span></div><div class="line"><span class="function">sds <span class="title">sdsRemoveFreeSpace</span><span class="params">(sds s)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></div><div class="line"></div><div class="line">  sh = (<span class="keyword">void</span> *) (s - (<span class="keyword">sizeof</span>(struct sdshdr)));</div><div class="line"></div><div class="line">  <span class="comment">// 进行内存重分配，让 buf 的长度仅仅足够保存字符串内容</span></div><div class="line">  <span class="comment">// T = O(N)</span></div><div class="line">  sh = zrealloc(sh, <span class="keyword">sizeof</span>(struct sdshdr) + sh-&gt;len + <span class="number">1</span>);</div><div class="line"></div><div class="line">  <span class="comment">// 空余空间为 0</span></div><div class="line">  sh-&gt;<span class="built_in">free</span> = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> sh-&gt;buf;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 返回给定 sds 分配的内存字节数</div><div class="line"> *</div><div class="line"> * 复杂度</div><div class="line"> *  T = O(1)</div><div class="line"> */</div><div class="line"><span class="comment">/* Return the total size of the allocation of the specifed sds string,</span></div><div class="line"> * including:</div><div class="line"> * 1) The sds header before the pointer.</div><div class="line"> * 2) The string.</div><div class="line"> * 3) The free buffer at the end if any.</div><div class="line"> * 4) The implicit null term.</div><div class="line"> */</div><div class="line"><span class="keyword">size_t</span> sdsAllocSize(sds s)</div><div class="line">&#123;</div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span> *) (<span class="title">s</span> - (<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">sizeof</span>(*sh) + sh-&gt;len + sh-&gt;<span class="built_in">free</span> + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Increment the sds length and decrements the left free space at the</span></div><div class="line"> * end of the string according to 'incr'. Also set the null term</div><div class="line"> * in the new end of the string.</div><div class="line"> *</div><div class="line"> * 根据 incr 参数，增加 sds 的长度，缩减空余空间，</div><div class="line"> * 并将 \0 放到新字符串的尾端</div><div class="line"> *</div><div class="line"> * This function is used in order to fix the string length after the</div><div class="line"> * user calls sdsMakeRoomFor(), writes something after the end of</div><div class="line"> * the current string, and finally needs to set the new length.</div><div class="line"> *</div><div class="line"> * 这个函数是在调用 sdsMakeRoomFor() 对字符串进行扩展，</div><div class="line"> * 然后用户在字符串尾部写入了某些内容之后，</div><div class="line"> * 用来正确更新 free 和 len 属性的。</div><div class="line"> *</div><div class="line"> * Note: it is possible to use a negative increment in order to</div><div class="line"> * right-trim the string.</div><div class="line"> *</div><div class="line"> * 如果 incr 参数为负数，那么对字符串进行右截断操作。</div><div class="line"> *</div><div class="line"> * Usage example:</div><div class="line"> *</div><div class="line"> * Using sdsIncrLen() and sdsMakeRoomFor() it is possible to mount the</div><div class="line"> * following schema, to cat bytes coming from the kernel to the end of an</div><div class="line"> * sds string without copying into an intermediate buffer:</div><div class="line"> *</div><div class="line"> * 以下是 sdsIncrLen 的用例：</div><div class="line"> *</div><div class="line"> * oldlen = sdslen(s);</div><div class="line"> * s = sdsMakeRoomFor(s, BUFFER_SIZE);</div><div class="line"> * nread = read(fd, s+oldlen, BUFFER_SIZE);</div><div class="line"> * ... check for nread &lt;= 0 and handle it ...</div><div class="line"> * sdsIncrLen(s, nread);</div><div class="line"> *</div><div class="line"> * 复杂度</div><div class="line"> *  T = O(1)</div><div class="line"> */</div><div class="line"><span class="comment">/// 增加sds的长度</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sdsIncrLen</span><span class="params">(sds s, <span class="keyword">int</span> incr)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span> *) (<span class="title">s</span> - (<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></div><div class="line"></div><div class="line">  <span class="comment">// 确保 sds 空间足够</span></div><div class="line">  assert(sh-&gt;<span class="built_in">free</span> &gt;= incr);</div><div class="line"></div><div class="line">  <span class="comment">// 更新属性</span></div><div class="line">  sh-&gt;len += incr;</div><div class="line">  sh-&gt;<span class="built_in">free</span> -= incr;</div><div class="line"></div><div class="line">  <span class="comment">// 这个 assert 其实可以忽略</span></div><div class="line">  <span class="comment">// 因为前一个 assert 已经确保 sh-&gt;free - incr &gt;= 0 了</span></div><div class="line">  assert(sh-&gt;<span class="built_in">free</span> &gt;= <span class="number">0</span>);</div><div class="line"></div><div class="line">  <span class="comment">// 放置新的结尾符号</span></div><div class="line">  s[sh-&gt;len] = <span class="string">'\0'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Grow the sds to have the specified length. Bytes that were not part of</span></div><div class="line"> * the original length of the sds will be set to zero.</div><div class="line"> *</div><div class="line"> * if the specified length is smaller than the current length, no operation</div><div class="line"> * is performed. */</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 将 sds 扩充至指定长度，未使用的空间以 0 字节填充。</div><div class="line"> *</div><div class="line"> * 返回值</div><div class="line"> *  sds ：扩充成功返回新 sds ，失败返回 NULL</div><div class="line"> *</div><div class="line"> * 复杂度：</div><div class="line"> *  T = O(N)</div><div class="line"> */</div><div class="line"><span class="function">sds <span class="title">sdsgrowzero</span><span class="params">(sds s, <span class="keyword">size_t</span> len)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span> *) (<span class="title">s</span> - (<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></div><div class="line">  <span class="keyword">size_t</span> totlen, curlen = sh-&gt;len;</div><div class="line"></div><div class="line">  <span class="comment">// 如果 len 比字符串的现有长度小，</span></div><div class="line">  <span class="comment">// 那么直接返回，不做动作</span></div><div class="line">  <span class="keyword">if</span> (len &lt;= curlen)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 扩展 sds</span></div><div class="line">  <span class="comment">// T = O(N)</span></div><div class="line">  s = sdsMakeRoomFor(s, len - curlen);</div><div class="line">  <span class="comment">// 如果内存不足，直接返回</span></div><div class="line">  <span class="keyword">if</span> (s == <span class="literal">NULL</span>)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* Make sure added region doesn't contain garbage */</span></div><div class="line">  <span class="comment">// 将新分配的空间用 0 填充，防止出现垃圾内容</span></div><div class="line">  <span class="comment">// T = O(N)</span></div><div class="line">  sh = (<span class="keyword">void</span> *) (s - (<span class="keyword">sizeof</span>(struct sdshdr)));</div><div class="line">  <span class="comment">/// 也处理了末尾的'\0'</span></div><div class="line">  <span class="built_in">memset</span>(s + curlen, <span class="number">0</span>, (len - curlen + <span class="number">1</span>)); <span class="comment">/* also set trailing \0 byte */</span></div><div class="line"></div><div class="line">  <span class="comment">// 更新属性</span></div><div class="line">  totlen = sh-&gt;len + sh-&gt;<span class="built_in">free</span>;</div><div class="line">  sh-&gt;len = len;</div><div class="line">  sh-&gt;<span class="built_in">free</span> = totlen - sh-&gt;len;</div><div class="line"></div><div class="line">  <span class="comment">// 返回新的 sds</span></div><div class="line">  <span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 将长度为 len 的字符串 t 追加到 sds 的字符串末尾</div><div class="line"> *</div><div class="line"> * 返回值</div><div class="line"> *  sds ：追加成功返回新 sds ，失败返回 NULL</div><div class="line"> *</div><div class="line"> * 复杂度</div><div class="line"> *  T = O(N)</div><div class="line"> */</div><div class="line"><span class="comment">/* Append the specified binary-safe string pointed by 't' of 'len' bytes to the</span></div><div class="line"> * end of the specified sds string 's'.</div><div class="line"> *</div><div class="line"> * After the call, the passed sds string is no longer valid and all the</div><div class="line"> * references must be substituted with the new pointer returned by the call. */</div><div class="line"><span class="function">sds <span class="title">sdscatlen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">void</span> *t, <span class="keyword">size_t</span> len)</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span>;</span></div><div class="line"></div><div class="line">  <span class="comment">// 原有字符串长度</span></div><div class="line">  <span class="keyword">size_t</span> curlen = sdslen(s);</div><div class="line"></div><div class="line">  <span class="comment">// 扩展 sds 空间</span></div><div class="line">  <span class="comment">// T = O(N)</span></div><div class="line">  s = sdsMakeRoomFor(s, len);</div><div class="line"></div><div class="line">  <span class="comment">// 内存不足？直接返回</span></div><div class="line">  <span class="keyword">if</span> (s == <span class="literal">NULL</span>)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 复制 t 中的内容到字符串后部</span></div><div class="line">  <span class="comment">// T = O(N)</span></div><div class="line">  sh = (<span class="keyword">void</span> *) (s - (<span class="keyword">sizeof</span>(struct sdshdr)));</div><div class="line">  <span class="built_in">memcpy</span>(s + curlen, t, len);</div><div class="line"></div><div class="line">  <span class="comment">// 更新属性</span></div><div class="line">  sh-&gt;len = curlen + len;</div><div class="line">  sh-&gt;<span class="built_in">free</span> = sh-&gt;<span class="built_in">free</span> - len;</div><div class="line"></div><div class="line">  <span class="comment">// 添加新结尾符号</span></div><div class="line">  s[curlen + len] = <span class="string">'\0'</span>;</div><div class="line"></div><div class="line">  <span class="comment">// 返回新 sds</span></div><div class="line">  <span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 将给定字符串 t 追加到 sds 的末尾</div><div class="line"> * </div><div class="line"> * 返回值</div><div class="line"> *  sds ：追加成功返回新 sds ，失败返回 NULL</div><div class="line"> *</div><div class="line"> * 复杂度</div><div class="line"> *  T = O(N)</div><div class="line"> */</div><div class="line"><span class="comment">/* Append the specified null termianted C string to the sds string 's'.</span></div><div class="line"> *</div><div class="line"> * After the call, the passed sds string is no longer valid and all the</div><div class="line"> * references must be substituted with the new pointer returned by the call. */</div><div class="line"><span class="function">sds <span class="title">sdscat</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> sdscatlen(s, t, <span class="built_in">strlen</span>(t));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 将另一个 sds 追加到一个 sds 的末尾</div><div class="line"> * </div><div class="line"> * 返回值</div><div class="line"> *  sds ：追加成功返回新 sds ，失败返回 NULL</div><div class="line"> *</div><div class="line"> * 复杂度</div><div class="line"> *  T = O(N)</div><div class="line"> */</div><div class="line"><span class="comment">/* Append the specified sds 't' to the existing sds 's'.</span></div><div class="line"> *</div><div class="line"> * After the call, the modified sds string is no longer valid and all the</div><div class="line"> * references must be substituted with the new pointer returned by the call. */</div><div class="line"><span class="function">sds <span class="title">sdscatsds</span><span class="params">(sds s, <span class="keyword">const</span> sds t)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> sdscatlen(s, t, sdslen(t));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 将字符串 t 的前 len 个字符复制到 sds s 当中，</div><div class="line"> * 并在字符串的最后添加终结符。</div><div class="line"> *</div><div class="line"> * 如果 sds 的长度少于 len 个字符，那么扩展 sds</div><div class="line"> *</div><div class="line"> * 复杂度</div><div class="line"> *  T = O(N)</div><div class="line"> *</div><div class="line"> * 返回值</div><div class="line"> *  sds ：复制成功返回新的 sds ，否则返回 NULL</div><div class="line"> */</div><div class="line"><span class="comment">/* Destructively modify the sds string 's' to hold the specified binary</span></div><div class="line"> * safe string pointed by 't' of length 'len' bytes. */</div><div class="line"><span class="function">sds <span class="title">sdscpylen</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t, <span class="keyword">size_t</span> len)</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span> *) (<span class="title">s</span> - (<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></div><div class="line"></div><div class="line">  <span class="comment">// sds 现有 buf 的长度</span></div><div class="line">  <span class="keyword">size_t</span> totlen = sh-&gt;<span class="built_in">free</span> + sh-&gt;len;</div><div class="line"></div><div class="line">  <span class="comment">// 如果 s 的 buf 长度不满足 len ，那么扩展它</span></div><div class="line">  <span class="keyword">if</span> (totlen &lt; len)</div><div class="line">  &#123;</div><div class="line">    <span class="comment">// T = O(N)</span></div><div class="line">    <span class="comment">/// 扩充空间</span></div><div class="line">    s = sdsMakeRoomFor(s, len - sh-&gt;len);</div><div class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    sh = (<span class="keyword">void</span> *) (s - (<span class="keyword">sizeof</span>(struct sdshdr)));</div><div class="line">    totlen = sh-&gt;<span class="built_in">free</span> + sh-&gt;len;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 复制内容</span></div><div class="line">  <span class="comment">// T = O(N)</span></div><div class="line">  <span class="built_in">memcpy</span>(s, t, len);</div><div class="line"></div><div class="line">  <span class="comment">// 添加终结符号</span></div><div class="line">  s[len] = <span class="string">'\0'</span>;</div><div class="line"></div><div class="line">  <span class="comment">// 更新属性</span></div><div class="line">  sh-&gt;len = len;</div><div class="line">  sh-&gt;<span class="built_in">free</span> = totlen - len;</div><div class="line"></div><div class="line">  <span class="comment">// 返回新的 sds</span></div><div class="line">  <span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 将字符串复制到 sds 当中，</div><div class="line"> * 覆盖原有的字符。</div><div class="line"> *</div><div class="line"> * 如果 sds 的长度少于字符串的长度，那么扩展 sds 。</div><div class="line"> *</div><div class="line"> * 复杂度</div><div class="line"> *  T = O(N)</div><div class="line"> *</div><div class="line"> * 返回值</div><div class="line"> *  sds ：复制成功返回新的 sds ，否则返回 NULL</div><div class="line"> */</div><div class="line"><span class="comment">/* Like sdscpylen() but 't' must be a null-termined string so that the length</span></div><div class="line"> * of the string is obtained with strlen(). */</div><div class="line"><span class="function">sds <span class="title">sdscpy</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *t)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> sdscpylen(s, t, <span class="built_in">strlen</span>(t));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>整数转换为字符串结构sds</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div></pre></td><td class="code"><pre><div class="line"><span class="comment"><span class="doctag">///</span> 将long long类型的数转换成为string</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_LLSTR_SIZE 21</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sdsll2str</span>(<span class="params"><span class="keyword">char</span> *s, <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">value</span></span>)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">char</span> *p, aux;</div><div class="line">  unsigned <span class="keyword">long</span> <span class="keyword">long</span> v;</div><div class="line">  size_t l;</div><div class="line"></div><div class="line">  <span class="comment">/* Generate the string representation, this method produces</span></div><div class="line">   * an reversed string. */</div><div class="line">  v = (<span class="keyword">value</span> &lt; <span class="number">0</span>) ? -<span class="keyword">value</span> : <span class="keyword">value</span>;</div><div class="line">  p = s;</div><div class="line">  <span class="keyword">do</span></div><div class="line">  &#123;</div><div class="line">    *p++ = <span class="string">'0'</span> + (v % <span class="number">10</span>);</div><div class="line">    v /= <span class="number">10</span>;</div><div class="line">  &#125; <span class="keyword">while</span> (v);</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">value</span> &lt; <span class="number">0</span>)</div><div class="line">  &#123;</div><div class="line">    *p++ = <span class="string">'-'</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* Compute length and add null term. */</span></div><div class="line">  l = p - s;</div><div class="line">  *p = <span class="string">'\0'</span>;</div><div class="line"></div><div class="line">  <span class="comment">/* Reverse the string. */</span></div><div class="line">  p--;</div><div class="line">  <span class="keyword">while</span> (s &lt; p)</div><div class="line">  &#123;</div><div class="line">    aux = *s;</div><div class="line">    *s = *p;</div><div class="line">    *p = aux;</div><div class="line">    s++;</div><div class="line">    p--;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> l;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Identical sdsll2str(), but for unsigned long long type. */</span></div><div class="line"><span class="comment"><span class="doctag">///</span> 将unsigned long long 类型的数转换成为字符串</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sdsull2str</span>(<span class="params"><span class="keyword">char</span> *s, unsigned <span class="keyword">long</span> <span class="keyword">long</span> v</span>)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">char</span> *p, aux;</div><div class="line">  size_t l;</div><div class="line"></div><div class="line">  <span class="comment">/* Generate the string representation, this method produces</span></div><div class="line">   * an reversed string. */</div><div class="line">  p = s;</div><div class="line">  <span class="keyword">do</span></div><div class="line">  &#123;</div><div class="line">    *p++ = <span class="string">'0'</span> + (v % <span class="number">10</span>);</div><div class="line">    v /= <span class="number">10</span>;</div><div class="line">  &#125; <span class="keyword">while</span> (v);</div><div class="line"></div><div class="line">  <span class="comment">/* Compute length and add null term. */</span></div><div class="line">  l = p - s;</div><div class="line">  *p = <span class="string">'\0'</span>;</div><div class="line"></div><div class="line">  <span class="comment">/* Reverse the string. */</span></div><div class="line">  p--;</div><div class="line">  <span class="keyword">while</span> (s &lt; p)</div><div class="line">  &#123;</div><div class="line">    aux = *s;</div><div class="line">    *s = *p;</div><div class="line">    *p = aux;</div><div class="line">    s++;</div><div class="line">    p--;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> l;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Create an sds string from a long long value. It is much faster than:</span></div><div class="line"> *</div><div class="line"> * sdscatprintf(sdsempty(),"%lld\n", value);</div><div class="line"> */</div><div class="line"><span class="comment">// 根据输入的 long long 值 value ，创建一个 SDS</span></div><div class="line"><span class="function">sds <span class="title">sdsfromlonglong</span>(<span class="params"><span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">value</span></span>)</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">char</span> buf[SDS_LLSTR_SIZE];</div><div class="line">  <span class="keyword">int</span> len = sdsll2str(buf, <span class="keyword">value</span>);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> sdsnewlen(buf, len);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>format输出函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* This function is similar to sdscatprintf, but much faster as it does</span></div><div class="line"> * not rely on sprintf() family functions implemented by the libc that</div><div class="line"> * are often very slow. Moreover directly handling the sds string as</div><div class="line"> * new data is concatenated provides a performance improvement.</div><div class="line"> *</div><div class="line"> * However this function only handles an incompatible subset of printf-alike</div><div class="line"> * format specifiers:</div><div class="line"> *</div><div class="line"> * %s - C String</div><div class="line"> * %S - SDS string</div><div class="line"> * %i - signed int</div><div class="line"> * %I - 64 bit signed integer (long long, int64_t)</div><div class="line"> * %u - unsigned int</div><div class="line"> * %U - 64 bit unsigned integer (unsigned long long, uint64_t)</div><div class="line"> * %% - Verbatim "%" character.</div><div class="line"> */</div><div class="line"></div><div class="line"><span class="comment">/// 上述符号标明了从不定长参数之中取参数，</span></div><div class="line"><span class="function">sds <span class="title">sdscatfmt</span><span class="params">(sds s, <span class="keyword">char</span> <span class="keyword">const</span> *fmt, ...)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> *<span class="title">sh</span> = (<span class="title">void</span> *) (<span class="title">s</span> - (<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">sdshdr</span>)));</span></div><div class="line">  <span class="keyword">size_t</span> initlen = sdslen(s);</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *f = fmt;</div><div class="line">  <span class="keyword">int</span> i;</div><div class="line">  va_list ap;</div><div class="line">  va_start(ap, fmt);</div><div class="line">  f = fmt;    <span class="comment">/* Next format specifier byte to process. */</span></div><div class="line">  i = initlen; <span class="comment">/* Position of the next byte to write to dest str. */</span></div><div class="line">  <span class="keyword">while</span> (*f)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">char</span> next, *str;</div><div class="line">    <span class="keyword">size_t</span> l;</div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> num;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> unum;</div><div class="line"></div><div class="line">    <span class="comment">/* Make sure there is always space for at least 1 char. */</span></div><div class="line">    <span class="keyword">if</span> (sh-&gt;<span class="built_in">free</span> == <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">      <span class="comment">/// 可用空间最低为1</span></div><div class="line">      s = sdsMakeRoomFor(s, <span class="number">1</span>);</div><div class="line">      sh = (<span class="keyword">void</span> *) (s - (<span class="keyword">sizeof</span>(struct sdshdr)));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (*f)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">case</span> <span class="string">'%'</span>:next = *(f + <span class="number">1</span>);</div><div class="line">        f++;</div><div class="line">        <span class="keyword">switch</span> (next)</div><div class="line">        &#123;</div><div class="line">          <span class="keyword">case</span> <span class="string">'s'</span>:</div><div class="line">          <span class="keyword">case</span> <span class="string">'S'</span>:str = va_arg(ap, <span class="keyword">char</span>*);</div><div class="line">            <span class="comment">/// s -&gt; char* | S -&gt; sds</span></div><div class="line">            l = (next == <span class="string">'s'</span>) ? <span class="built_in">strlen</span>(str) : sdslen(str);</div><div class="line">            <span class="keyword">if</span> (sh-&gt;<span class="built_in">free</span> &lt; l)</div><div class="line">            &#123;</div><div class="line">              s = sdsMakeRoomFor(s, l);</div><div class="line">              sh = (<span class="keyword">void</span> *) (s - (<span class="keyword">sizeof</span>(struct sdshdr)));</div><div class="line">            &#125;</div><div class="line">            <span class="built_in">memcpy</span>(s + i, str, l);</div><div class="line">            sh-&gt;len += l;</div><div class="line">            sh-&gt;<span class="built_in">free</span> -= l;</div><div class="line">            i += l;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">          <span class="keyword">case</span> <span class="string">'i'</span>:</div><div class="line">          <span class="keyword">case</span> <span class="string">'I'</span>:</div><div class="line">            <span class="comment">// i -&gt; int</span></div><div class="line">            <span class="keyword">if</span> (next == <span class="string">'i'</span>)</div><div class="line">            &#123;</div><div class="line">              num = va_arg(ap, <span class="keyword">int</span>);</div><div class="line">            &#125;</div><div class="line">              <span class="comment">// I long long</span></div><div class="line">            <span class="keyword">else</span></div><div class="line">            &#123;</div><div class="line">              num = va_arg(ap, <span class="keyword">long</span> <span class="keyword">long</span>);</div><div class="line">            &#125;</div><div class="line">            &#123;</div><div class="line">              <span class="keyword">char</span> buf[SDS_LLSTR_SIZE];</div><div class="line">              l = sdsll2str(buf, num);</div><div class="line">              <span class="keyword">if</span> (sh-&gt;<span class="built_in">free</span> &lt; l)</div><div class="line">              &#123;</div><div class="line">                s = sdsMakeRoomFor(s, l);</div><div class="line">                sh = (<span class="keyword">void</span> *) (s - (<span class="keyword">sizeof</span>(struct sdshdr)));</div><div class="line">              &#125;</div><div class="line">              <span class="built_in">memcpy</span>(s + i, buf, l);</div><div class="line">              sh-&gt;len += l;</div><div class="line">              sh-&gt;<span class="built_in">free</span> -= l;</div><div class="line">              i += l;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">          <span class="keyword">case</span> <span class="string">'u'</span>:</div><div class="line">          <span class="keyword">case</span> <span class="string">'U'</span>:</div><div class="line">            <span class="comment">/// u -&gt; unsigned int</span></div><div class="line">            <span class="keyword">if</span> (next == <span class="string">'u'</span>)</div><div class="line">            &#123;</div><div class="line">              unum = va_arg(ap, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</div><div class="line">            &#125;</div><div class="line">              <span class="comment">/// U unsigned long long</span></div><div class="line">            <span class="keyword">else</span></div><div class="line">            &#123;</div><div class="line">              unum = va_arg(ap, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>);</div><div class="line">            &#125;</div><div class="line">            &#123;</div><div class="line">              <span class="keyword">char</span> buf[SDS_LLSTR_SIZE];</div><div class="line">              l = sdsull2str(buf, unum);</div><div class="line">              <span class="keyword">if</span> (sh-&gt;<span class="built_in">free</span> &lt; l)</div><div class="line">              &#123;</div><div class="line">                s = sdsMakeRoomFor(s, l);</div><div class="line">                sh = (<span class="keyword">void</span> *) (s - (<span class="keyword">sizeof</span>(struct sdshdr)));</div><div class="line">              &#125;</div><div class="line">              <span class="built_in">memcpy</span>(s + i, buf, l);</div><div class="line">              sh-&gt;len += l;</div><div class="line">              sh-&gt;<span class="built_in">free</span> -= l;</div><div class="line">              i += l;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">            <span class="comment">/// 处理 %% 和 %&lt;unknown&gt;等模式</span></div><div class="line">          <span class="keyword">default</span>: <span class="comment">/* Handle %% and generally %&lt;unknown&gt;. */</span></div><div class="line">            s[i++] = next;</div><div class="line">            sh-&gt;len += <span class="number">1</span>;</div><div class="line">            sh-&gt;<span class="built_in">free</span> -= <span class="number">1</span>;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">default</span>:s[i++] = *f;</div><div class="line">        sh-&gt;len += <span class="number">1</span>;</div><div class="line">        sh-&gt;<span class="built_in">free</span> -= <span class="number">1</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    f++;</div><div class="line">  &#125;</div><div class="line">  va_end(ap);</div><div class="line"></div><div class="line">  <span class="comment">/* Add null-term */</span></div><div class="line">  s[i] = <span class="string">'\0'</span>;</div><div class="line">  <span class="keyword">return</span> s;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>sds结构输出函数，对不可打印字符做了特殊处理</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 将长度为 len 的字符串 p 以带引号（quoted）的格式</div><div class="line"> * 追加到给定 sds 的末尾</div><div class="line"> *</div><div class="line"> * T = O(N)</div><div class="line"> */</div><div class="line"><span class="comment">/* Append to the sds string "s" an escaped string representation where</span></div><div class="line"> * all the non-printable characters (tested with isprint()) are turned into</div><div class="line"> * escapes in the form "\n\r\a...." or "\x&lt;hex-number&gt;".</div><div class="line"> *</div><div class="line"> * After the call, the modified sds string is no longer valid and all the</div><div class="line"> * references must be substituted with the new pointer returned by the call. */</div><div class="line"><span class="function">sds <span class="title">sdscatrepr</span><span class="params">(sds s, <span class="keyword">const</span> <span class="keyword">char</span> *p, <span class="keyword">size_t</span> len)</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">  <span class="comment">/// 首尾加上"</span></div><div class="line">  s = sdscatlen(s, <span class="string">"\""</span>, <span class="number">1</span>);</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (len--)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">switch</span> (*p)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">case</span> <span class="string">'\\'</span>:</div><div class="line">      <span class="keyword">case</span> <span class="string">'"'</span>:s = sdscatprintf(s, <span class="string">"\\%c"</span>, *p);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> <span class="string">'\n'</span>: s = sdscatlen(s, <span class="string">"\\n"</span>, <span class="number">2</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> <span class="string">'\r'</span>: s = sdscatlen(s, <span class="string">"\\r"</span>, <span class="number">2</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> <span class="string">'\t'</span>: s = sdscatlen(s, <span class="string">"\\t"</span>, <span class="number">2</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> <span class="string">'\a'</span>: s = sdscatlen(s, <span class="string">"\\a"</span>, <span class="number">2</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> <span class="string">'\b'</span>: s = sdscatlen(s, <span class="string">"\\b"</span>, <span class="number">2</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        <span class="comment">/// 可以打印</span></div><div class="line">        <span class="keyword">if</span> (<span class="built_in">isprint</span>(*p))</div><div class="line">        &#123;</div><div class="line">          s = sdscatprintf(s, <span class="string">"%c"</span>, *p);</div><div class="line">        &#125;</div><div class="line">          <span class="comment">/// 不可以打印</span></div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">          s = sdscatprintf(s, <span class="string">"\\x%02x"</span>, (<span class="keyword">unsigned</span> <span class="keyword">char</span>) *p);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    p++;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> sdscatlen(s, <span class="string">"\""</span>, <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis 字典]]></title>
      <url>/2017/11/04/redis-%E5%AD%97%E5%85%B8/</url>
      <content type="html"><![CDATA[<h1 id="dict介绍"><a href="#dict介绍" class="headerlink" title="dict介绍"></a>dict介绍</h1><p>在redis之中，支撑字典的数据结构是链式hash。底层采用链式hash的字典如果发生rehash，如果字典中的数据量过多，rehash占用的时间会非常多。redis作为单线程事件循环工作模式的内存数据库，长时间的rehash会使得数据库出现短暂的卡顿，无法为所有用户提供及时的服务。因而，在redis中针对这种情况，rehash会分步执行。</p>
<p>下图是rehash结束的时候，描述dict结构的图片。</p>
<p><img src="http://img.blog.csdn.net/20160410111750819" alt=""></p>
<h1 id="dict结构通览"><a href="#dict结构通览" class="headerlink" title="dict结构通览"></a>dict结构通览</h1><h2 id="哈希表结点"><a href="#哈希表结点" class="headerlink" title="哈希表结点"></a>哈希表结点</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></div><div class="line">    </div><div class="line">    <span class="comment">// 键</span></div><div class="line">    <span class="keyword">void</span> *key;</div><div class="line"></div><div class="line">    <span class="comment">// 值</span></div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">void</span> *val;</div><div class="line">        <span class="keyword">uint64_t</span> u64;</div><div class="line">        <span class="keyword">int64_t</span> s64;</div><div class="line">    &#125; v;</div><div class="line"></div><div class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></div><div class="line"></div><div class="line">&#125; dictEntry;</div></pre></td></tr></table></figure>
<h2 id="类定义"><a href="#类定义" class="headerlink" title="类定义"></a>类定义</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 计算哈希值的函数</span></div><div class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// 复制键的函数</span></div><div class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</div><div class="line"></div><div class="line">    <span class="comment">// 复制值的函数</span></div><div class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</div><div class="line"></div><div class="line">    <span class="comment">// 对比键的函数</span></div><div class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</div><div class="line"></div><div class="line">    <span class="comment">// 销毁键的函数</span></div><div class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</div><div class="line">    </div><div class="line">    <span class="comment">// 销毁值的函数</span></div><div class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</div><div class="line"></div><div class="line">&#125; dictType;</div></pre></td></tr></table></figure>
<h2 id="dict定义"><a href="#dict定义" class="headerlink" title="dict定义"></a>dict定义</h2><h3 id="hash表定义"><a href="#hash表定义" class="headerlink" title="hash表定义"></a>hash表定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 哈希表</div><div class="line"> *</div><div class="line"> * 每个字典都使用两个哈希表，从而实现渐进式 rehash 。</div><div class="line"> */</div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></div><div class="line">    </div><div class="line">    <span class="comment">// 哈希表数组</span></div><div class="line">    dictEntry **table;</div><div class="line"></div><div class="line">    <span class="comment">// 哈希表大小</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</div><div class="line">    </div><div class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></div><div class="line">    <span class="comment">// 总是等于 size - 1</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</div><div class="line"></div><div class="line">    <span class="comment">// 该哈希表已有节点的数量</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</div><div class="line"></div><div class="line">&#125; dictht;</div></pre></td></tr></table></figure>
<h3 id="字典定义"><a href="#字典定义" class="headerlink" title="字典定义"></a>字典定义</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></div><div class="line"></div><div class="line">    <span class="comment">// 类型特定函数</span></div><div class="line">    dictType *type;</div><div class="line"></div><div class="line">    <span class="comment">// 私有数据</span></div><div class="line">    <span class="keyword">void</span> *privdata;</div><div class="line"></div><div class="line">    <span class="comment">// 哈希表</span></div><div class="line">    dictht ht[<span class="number">2</span>];</div><div class="line"></div><div class="line">    <span class="comment">// rehash 索引</span></div><div class="line">    <span class="comment">// 当 rehash 不在进行时，值为 -1</span></div><div class="line">    <span class="keyword">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></div><div class="line"></div><div class="line">    <span class="comment">// 目前正在运行的安全迭代器的数量</span></div><div class="line">    <span class="keyword">int</span> iterators; <span class="comment">/* number of iterators currently running */</span></div><div class="line"></div><div class="line">&#125; dict;</div></pre></td></tr></table></figure>
<h3 id="迭代器定义"><a href="#迭代器定义" class="headerlink" title="迭代器定义"></a>迭代器定义</h3><p>在C++之中，为了便于访问容器中的元素，提供了迭代器。在redis之中，也推出了仿照C++的迭代器实现，为上层应用提供统一的迭代接口提供了支持。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictIterator</span> &#123;</span></div><div class="line">        </div><div class="line">    <span class="comment">// 被迭代的字典</span></div><div class="line">    dict *d;</div><div class="line"></div><div class="line">    <span class="comment">// table ：正在被迭代的哈希表号码，值可以是 0 或 1 。</span></div><div class="line">    <span class="comment">// index ：迭代器当前所指向的哈希表索引位置。</span></div><div class="line">    <span class="comment">// safe ：标识这个迭代器是否安全</span></div><div class="line">    <span class="keyword">int</span> table, index, safe;</div><div class="line"></div><div class="line">    <span class="comment">// entry ：当前迭代到的节点的指针</span></div><div class="line">    <span class="comment">// nextEntry ：当前迭代节点的下一个节点</span></div><div class="line">    <span class="comment">//             因为在安全迭代器运作时， entry 所指向的节点可能会被修改，</span></div><div class="line">    <span class="comment">//             所以需要一个额外的指针来保存下一节点的位置，</span></div><div class="line">    <span class="comment">//             从而防止指针丢失</span></div><div class="line">    dictEntry *entry, *nextEntry;</div><div class="line"></div><div class="line">    <span class="keyword">long</span> <span class="keyword">long</span> fingerprint; <span class="comment">/* unsafe iterator fingerprint for misuse detection */</span></div><div class="line">&#125; dictIterator;</div></pre></td></tr></table></figure>
<h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><p>hash函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">dictGenHashFunction</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key, <span class="keyword">int</span> len)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="comment">/* 'm' and 'r' are mixing constants generated offline.</span></div><div class="line">   They're not really 'magic', they just happen to work well.  */</div><div class="line">  <span class="keyword">uint32_t</span> seed = dict_hash_function_seed;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> m = <span class="number">0x5bd1e995</span>;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">int</span> r = <span class="number">24</span>;</div><div class="line"></div><div class="line">  <span class="comment">/* Initialize the hash to a 'random' value */</span></div><div class="line">  <span class="keyword">uint32_t</span> h = seed ^len;</div><div class="line"></div><div class="line">  <span class="comment">/* Mix 4 bytes at a time into the hash */</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *data = (<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *) key;</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (len &gt;= <span class="number">4</span>)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">uint32_t</span> k = *(<span class="keyword">uint32_t</span> *) data;</div><div class="line"></div><div class="line">    k *= m;</div><div class="line">    k ^= k &gt;&gt; r;</div><div class="line">    k *= m;</div><div class="line"></div><div class="line">    h *= m;</div><div class="line">    h ^= k;</div><div class="line"></div><div class="line">    data += <span class="number">4</span>;</div><div class="line">    len -= <span class="number">4</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* Handle the last few bytes of the input array  */</span></div><div class="line">  <span class="keyword">switch</span> (len)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">case</span> <span class="number">3</span>: h ^= data[<span class="number">2</span>] &lt;&lt; <span class="number">16</span>;</div><div class="line">    <span class="keyword">case</span> <span class="number">2</span>: h ^= data[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>;</div><div class="line">    <span class="keyword">case</span> <span class="number">1</span>: h ^= data[<span class="number">0</span>];</div><div class="line">      h *= m;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="comment">/* Do a few final mixes of the hash to ensure the last few</span></div><div class="line">   * bytes are well-incorporated. */</div><div class="line">  h ^= h &gt;&gt; <span class="number">13</span>;</div><div class="line">  h *= m;</div><div class="line">  h ^= h &gt;&gt; <span class="number">15</span>;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>) h;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>大小写无关hash函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// 因为统一转换成为了小写字母，所以此hash函数是大小写无关的实现版本</span></div><div class="line"><span class="comment">/* And a case insensitive hash function (based on djb hash) */</span></div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">dictGenCaseHashFunction</span><span class="params">(<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> len)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = (<span class="keyword">unsigned</span> <span class="keyword">int</span>) dict_hash_function_seed;</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (len--)</div><div class="line">  &#123;</div><div class="line">    hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + (<span class="built_in">tolower</span>(*buf++));</div><div class="line">  &#125; <span class="comment">/* hash * 33 + c */</span></div><div class="line">  <span class="keyword">return</span> hash;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建dict</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 重置（或初始化）给定哈希表的各项属性值</div><div class="line"> *</div><div class="line"> * p.s. 上面的英文注释已经过期</div><div class="line"> *</div><div class="line"> * T = O(1)</div><div class="line"> */</div><div class="line">static void _dictReset(dictht *ht)</div><div class="line">&#123;</div><div class="line">  <span class="function"><span class="title">ht</span>-&gt;</span>table = NULL;</div><div class="line">  <span class="function"><span class="title">ht</span>-&gt;</span>size = <span class="number">0</span>;</div><div class="line">  <span class="function"><span class="title">ht</span>-&gt;</span>sizemask = <span class="number">0</span>;</div><div class="line">  <span class="function"><span class="title">ht</span>-&gt;</span>used = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 初始化哈希表</div><div class="line"> *</div><div class="line"> * T = O(1)</div><div class="line"> */</div><div class="line">int _dictInit(dict *d, dictType *type,</div><div class="line">              void *privDataPtr)</div><div class="line">&#123;</div><div class="line">  <span class="comment">// 初始化两个哈希表的各项属性值</span></div><div class="line">  <span class="comment">// 但暂时还不分配内存给哈希表数组</span></div><div class="line">  _<span class="function"><span class="title">dictReset</span>(&amp;d-&gt;</span>ht[<span class="number">0</span>]);</div><div class="line">  _<span class="function"><span class="title">dictReset</span>(&amp;d-&gt;</span>ht[<span class="number">1</span>]);</div><div class="line"></div><div class="line">  <span class="comment">// 设置类型特定函数</span></div><div class="line">  <span class="function"><span class="title">d</span>-&gt;</span>type = type;</div><div class="line"></div><div class="line">  <span class="comment">// 设置私有数据</span></div><div class="line">  <span class="function"><span class="title">d</span>-&gt;</span>privdata = privDataPtr;</div><div class="line"></div><div class="line">  <span class="comment">// 设置哈希表 rehash 状态</span></div><div class="line">  <span class="function"><span class="title">d</span>-&gt;</span>rehashidx = -<span class="number">1</span>;</div><div class="line"></div><div class="line">  <span class="comment">// 设置字典的安全迭代器数量</span></div><div class="line">  <span class="function"><span class="title">d</span>-&gt;</span>iterators = <span class="number">0</span>;</div><div class="line"></div><div class="line">  return DICT_OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 创建一个新的字典</div><div class="line"> *</div><div class="line"> * T = O(1)</div><div class="line"> */</div><div class="line">dict *dictCreate(dictType *type,</div><div class="line">                 void *privDataPtr)</div><div class="line">&#123;</div><div class="line">  <span class="comment">/// 创建dict结构体</span></div><div class="line">  dict *d = zmalloc(sizeof(*d));</div><div class="line"></div><div class="line">  <span class="comment">/// 初始化dict</span></div><div class="line">  _dictInit(d, type, privDataPtr);</div><div class="line"></div><div class="line">  return d;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>调整字典的大小</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 创建一个新的哈希表，并根据字典的情况，选择以下其中一个动作来进行：</div><div class="line"> *</div><div class="line"> * 1) 如果字典的 0 号哈希表为空，那么将新哈希表设置为 0 号哈希表</div><div class="line"> * 2) 如果字典的 0 号哈希表非空，那么将新哈希表设置为 1 号哈希表，</div><div class="line"> *    并打开字典的 rehash 标识，使得程序可以开始对字典进行 rehash</div><div class="line"> *</div><div class="line"> * size 参数不够大，或者 rehash 已经在进行时，返回 DICT_ERR 。</div><div class="line"> *</div><div class="line"> * 成功创建 0 号哈希表，或者 1 号哈希表时，返回 DICT_OK 。</div><div class="line"> *</div><div class="line"> * T = O(N)</div><div class="line"> */</div><div class="line"><span class="keyword">int</span> dictExpand(dict *d, <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>)</div><div class="line">&#123;</div><div class="line">  <span class="comment">// 新哈希表</span></div><div class="line">  dictht n; <span class="comment">/* the new hash table */</span></div><div class="line"></div><div class="line">  <span class="comment">// 根据 size 参数，计算哈希表的大小</span></div><div class="line">  <span class="comment">// T = O(1)</span></div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> realsize = _dictNextPower(<span class="built_in">size</span>);</div><div class="line"></div><div class="line">  <span class="comment">/* the size is invalid if it is smaller than the number of</span></div><div class="line">   * elements already inside the hash table */</div><div class="line">  <span class="comment">// 不能在字典正在 rehash 时进行</span></div><div class="line">  <span class="comment">// size 的值也不能小于 0 号哈希表的当前已使用节点</span></div><div class="line">  <span class="built_in">if</span> (dictIsRehashing(d) || d-&gt;ht[<span class="number">0</span>].used &gt; <span class="built_in">size</span>)</div><div class="line">  &#123;</div><div class="line">    <span class="built_in">return</span> DICT_ERR;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* Allocate the new hash table and initialize all pointers to NULL */</span></div><div class="line">  <span class="comment">// 为哈希表分配空间，并将所有指针指向 NULL</span></div><div class="line">  n.<span class="built_in">size</span> = realsize;</div><div class="line">  n.sizemask = realsize - <span class="number">1</span>;</div><div class="line">  <span class="comment">// T = O(N)</span></div><div class="line">  n.table = zcalloc(realsize * <span class="keyword">sizeof</span>(dictEntry *));</div><div class="line">  n.used = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="comment">/* Is this the first initialization? If so it's not really a rehashing</span></div><div class="line">   * we just set the first hash table so that it can accept keys. */</div><div class="line">  <span class="comment">// 如果 0 号哈希表为空，那么这是一次初始化：</span></div><div class="line">  <span class="comment">// 程序将新哈希表赋给 0 号哈希表的指针，然后字典就可以开始处理键值对了。</span></div><div class="line">  <span class="built_in">if</span> (d-&gt;ht[<span class="number">0</span>].table == NULL)</div><div class="line">  &#123;</div><div class="line">    d-&gt;ht[<span class="number">0</span>] = n;</div><div class="line">    <span class="built_in">return</span> DICT_OK;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* Prepare a second hash table for incremental rehashing */</span></div><div class="line">  <span class="comment">// 如果 0 号哈希表非空，那么这是一次 rehash ：</span></div><div class="line">  <span class="comment">// 程序将新哈希表设置为 1 号哈希表，</span></div><div class="line">  <span class="comment">// 并将字典的 rehash 标识打开，让程序可以开始对字典进行 rehash</span></div><div class="line">  d-&gt;ht[<span class="number">1</span>] = n;</div><div class="line">  d-&gt;rehashidx = <span class="number">0</span>;</div><div class="line">  <span class="built_in">return</span> DICT_OK;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 缩小给定字典</div><div class="line"> * 让它的已用节点数和字典大小之间的比率接近 1:1</div><div class="line"> *</div><div class="line"> * 返回 DICT_ERR 表示字典已经在 rehash ，或者 dict_can_resize 为假。</div><div class="line"> *</div><div class="line"> * 成功创建体积更小的 ht[1] ，可以开始 resize 时，返回 DICT_OK。</div><div class="line"> *</div><div class="line"> * T = O(N)</div><div class="line"> */</div><div class="line"><span class="keyword">int</span> dictResize(dict *d)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> minimal;</div><div class="line"></div><div class="line">  <span class="comment">// 不能在关闭 rehash 或者正在 rehash 的时候调用</span></div><div class="line">  <span class="built_in">if</span> (!dict_can_resize || dictIsRehashing(d))</div><div class="line">  &#123;</div><div class="line">    <span class="built_in">return</span> DICT_ERR;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 计算让比率接近 1：1 所需要的最少节点数量</span></div><div class="line">  minimal = d-&gt;ht[<span class="number">0</span>].used;</div><div class="line">  <span class="built_in">if</span> (minimal &lt; DICT_HT_INITIAL_SIZE)</div><div class="line">  &#123;</div><div class="line">    <span class="comment">/// dict最小的大小</span></div><div class="line">    minimal = DICT_HT_INITIAL_SIZE;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 调整字典的大小</span></div><div class="line">  <span class="comment">// T = O(N)</span></div><div class="line">  <span class="built_in">return</span> dictExpand(d, minimal);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行n次rehash处理</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Performs N steps of incremental rehashing. Returns 1 if there are still</span></div><div class="line"> * keys to move from the old to the new hash table, otherwise 0 is returned.</div><div class="line"> *</div><div class="line"> * 执行 N 步渐进式 rehash 。</div><div class="line"> *</div><div class="line"> * 返回 1 表示仍有键需要从 0 号哈希表移动到 1 号哈希表，</div><div class="line"> * 返回 0 则表示所有键都已经迁移完毕。</div><div class="line"> *</div><div class="line"> * Note that a rehashing step consists in moving a bucket (that may have more</div><div class="line"> * than one key as we use chaining) from the old to the new hash table.</div><div class="line"> *</div><div class="line"> * 注意，每步 rehash 都是以一个哈希表索引（桶）作为单位的，</div><div class="line"> * 一个桶里可能会有多个节点，</div><div class="line"> * 被 rehash 的桶里的所有节点都会被移动到新哈希表。</div><div class="line"> *</div><div class="line"> * T = O(N)</div><div class="line"> */</div><div class="line">int dictRehash(dict *d, int n)</div><div class="line">&#123;</div><div class="line"></div><div class="line">  <span class="comment">// 只可以在 rehash 进行中时执行</span></div><div class="line">  <span class="keyword">if</span> (!dictIsRehashing(d))</div><div class="line">  &#123;</div><div class="line">    return <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 进行 N 步迁移</span></div><div class="line">  <span class="comment">// T = O(N)</span></div><div class="line">  <span class="keyword">while</span> (n--)</div><div class="line">  &#123;</div><div class="line">    dictEntry *de, *nextde;</div><div class="line"></div><div class="line">    <span class="comment">/* Check if we already rehashed the whole table... */</span></div><div class="line">    <span class="comment">// 如果 0 号哈希表为空，那么表示 rehash 执行完毕</span></div><div class="line">    <span class="comment">// T = O(1)</span></div><div class="line">    <span class="function"><span class="title">if</span> (d-&gt;</span>ht[<span class="number">0</span>].used == <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">      <span class="comment">// 释放 0 号哈希表</span></div><div class="line">      <span class="function"><span class="title">zfree</span>(d-&gt;</span>ht[<span class="number">0</span>].table);</div><div class="line">      <span class="comment">// 将原来的 1 号哈希表设置为新的 0 号哈希表</span></div><div class="line">      <span class="function"><span class="title">d</span>-&gt;</span><span class="function"><span class="title">ht</span>[0] = d-&gt;</span>ht[<span class="number">1</span>];</div><div class="line">      <span class="comment">// 重置旧的 1 号哈希表</span></div><div class="line">      _<span class="function"><span class="title">dictReset</span>(&amp;d-&gt;</span>ht[<span class="number">1</span>]);</div><div class="line">      <span class="comment">// 关闭 rehash 标识</span></div><div class="line">      <span class="function"><span class="title">d</span>-&gt;</span>rehashidx = -<span class="number">1</span>;</div><div class="line">      <span class="comment">// 返回 0 ，向调用者表示 rehash 已经完成</span></div><div class="line">      return <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* Note that rehashidx can't overflow as we are sure there are more</span></div><div class="line">     * elements because ht[0].used != 0 */</div><div class="line">    <span class="comment">// 确保 rehashidx 没有越界</span></div><div class="line">    <span class="function"><span class="title">assert</span>(d-&gt;</span><span class="function"><span class="title">ht</span>[0].size &gt; (unsigned) d-&gt;</span>rehashidx);</div><div class="line"></div><div class="line">    <span class="comment">// 略过数组中为空的索引，找到下一个非空索引</span></div><div class="line">    <span class="function"><span class="title">while</span> (d-&gt;</span><span class="function"><span class="title">ht</span>[0].table[d-&gt;</span>rehashidx] == NULL)</div><div class="line">    &#123;</div><div class="line">      <span class="function"><span class="title">d</span>-&gt;</span>rehashidx++;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 指向该索引的链表表头节点</span></div><div class="line">    <span class="function"><span class="title">de</span> = d-&gt;</span><span class="function"><span class="title">ht</span>[0].table[d-&gt;</span>rehashidx];</div><div class="line">    <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></div><div class="line">    <span class="comment">// 将链表中的所有节点迁移到新哈希表</span></div><div class="line">    <span class="comment">// T = O(1)</span></div><div class="line">    <span class="keyword">while</span> (de)</div><div class="line">    &#123;</div><div class="line">      unsigned int h;</div><div class="line"></div><div class="line">      <span class="comment">// 保存下个节点的指针</span></div><div class="line">      <span class="function"><span class="title">nextde</span> = de-&gt;</span>next;</div><div class="line"></div><div class="line">      <span class="comment">/* Get the index in the new hash table */</span></div><div class="line">      <span class="comment">// 计算新哈希表的哈希值，以及节点插入的索引位置</span></div><div class="line">      <span class="function"><span class="title">h</span> = dictHashKey(d, de-&gt;</span><span class="function"><span class="title">key</span>) &amp; d-&gt;</span>ht[<span class="number">1</span>].sizemask;</div><div class="line"></div><div class="line">      <span class="comment">// 插入节点到新哈希表</span></div><div class="line">      <span class="function"><span class="title">de</span>-&gt;</span><span class="function"><span class="title">next</span> = d-&gt;</span>ht[<span class="number">1</span>].table[h];</div><div class="line">      <span class="function"><span class="title">d</span>-&gt;</span>ht[<span class="number">1</span>].table[h] = de;</div><div class="line"></div><div class="line">      <span class="comment">// 更新计数器</span></div><div class="line">      <span class="function"><span class="title">d</span>-&gt;</span>ht[<span class="number">0</span>].used--;</div><div class="line">      <span class="function"><span class="title">d</span>-&gt;</span>ht[<span class="number">1</span>].used++;</div><div class="line"></div><div class="line">      <span class="comment">// 继续处理下个节点</span></div><div class="line">      de = nextde;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 将刚迁移完的哈希表索引的指针设为空</span></div><div class="line">    <span class="function"><span class="title">d</span>-&gt;</span><span class="function"><span class="title">ht</span>[0].table[d-&gt;</span>rehashidx] = NULL;</div><div class="line">    <span class="comment">// 更新 rehash 索引</span></div><div class="line">    <span class="function"><span class="title">d</span>-&gt;</span>rehashidx++;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  return <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在限定时间内进行rehash</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 返回以毫秒为单位的 UNIX 时间戳</div><div class="line"> *</div><div class="line"> * T = O(1)</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">timeInMilliseconds</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></div><div class="line"></div><div class="line">  gettimeofday(&amp;tv, <span class="literal">NULL</span>);</div><div class="line">  <span class="keyword">return</span> (((<span class="keyword">long</span> <span class="keyword">long</span>) tv.tv_sec) * <span class="number">1000</span>) + (tv.tv_usec / <span class="number">1000</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Rehash for an amount of time between ms milliseconds and ms+1 milliseconds */</span></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 在给定毫秒数内，以 100 步为单位，对字典进行 rehash 。</div><div class="line"> *</div><div class="line"> * T = O(N)</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehashMilliseconds</span><span class="params">(dict *d, <span class="keyword">int</span> ms)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="comment">// 记录开始时间</span></div><div class="line">  <span class="keyword">long</span> <span class="keyword">long</span> start = timeInMilliseconds();</div><div class="line">  <span class="keyword">int</span> rehashes = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (dictRehash(d, <span class="number">100</span>))</div><div class="line">  &#123;</div><div class="line">    rehashes += <span class="number">100</span>;</div><div class="line">    <span class="comment">// 如果时间已过，跳出</span></div><div class="line">    <span class="keyword">if</span> (timeInMilliseconds() - start &gt; ms)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> rehashes;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>向字典之中添加键值对</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 尝试将给定键值对添加到字典中</div><div class="line"> *</div><div class="line"> * 只有给定键 key 不存在于字典时，添加操作才会成功</div><div class="line"> *</div><div class="line"> * 添加成功返回 DICT_OK ，失败返回 DICT_ERR</div><div class="line"> *</div><div class="line"> * 最坏 T = O(N) ，平滩 O(1) </div><div class="line"> */</div><div class="line"><span class="built_in">int</span> dictAdd(dict *d, <span class="keyword">void</span> *<span class="built_in">key</span>, <span class="keyword">void</span> *val)</div><div class="line">&#123;</div><div class="line">  <span class="comment">// 尝试添加键到字典，并返回包含了这个键的新哈希节点</span></div><div class="line">  <span class="comment">// T = O(N)</span></div><div class="line">  dictEntry *entry = dictAddRaw(d, <span class="built_in">key</span>);</div><div class="line"></div><div class="line">  <span class="comment">// 键已存在，添加失败</span></div><div class="line">  <span class="keyword">if</span> (!entry)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">return</span> DICT_ERR;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 键不存在，设置节点的值</span></div><div class="line">  <span class="comment">// T = O(1)</span></div><div class="line">  dictSetVal(d, entry, val);</div><div class="line"></div><div class="line">  <span class="comment">// 添加成功</span></div><div class="line">  <span class="keyword">return</span> DICT_OK;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Low level add. This function adds the entry but instead of setting</span></div><div class="line"> * a value returns the dictEntry structure to the user, that will make</div><div class="line"> * sure to fill the value field as he wishes.</div><div class="line"> *</div><div class="line"> * This function is also directly exposed to user API to be called</div><div class="line"> * mainly in order to store non-pointers inside the hash value, example:</div><div class="line"> *</div><div class="line"> * entry = dictAddRaw(dict,mykey);</div><div class="line"> * if (entry != NULL) dictSetSignedIntegerVal(entry,1000);</div><div class="line"> *</div><div class="line"> * Return values:</div><div class="line"> *</div><div class="line"> * If key already exists NULL is returned.</div><div class="line"> * If key was added, the hash entry is returned to be manipulated by the caller.</div><div class="line"> */</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 尝试将键插入到字典中</div><div class="line"> *</div><div class="line"> * 如果键已经在字典存在，那么返回 NULL</div><div class="line"> *</div><div class="line"> * 如果键不存在，那么程序创建新的哈希节点，</div><div class="line"> * 将节点和键关联，并插入到字典，然后返回节点本身。</div><div class="line"> *</div><div class="line"> * T = O(N)</div><div class="line"> */</div><div class="line">dictEntry *dictAddRaw(dict *d, <span class="keyword">void</span> *<span class="built_in">key</span>)</div><div class="line">&#123;</div><div class="line">  <span class="built_in">int</span> index;</div><div class="line">  dictEntry *entry;</div><div class="line">  dictht *ht;</div><div class="line"></div><div class="line">  <span class="comment">// 如果条件允许的话，进行单步 rehash</span></div><div class="line">  <span class="comment">// T = O(1)</span></div><div class="line">  <span class="keyword">if</span> (dictIsRehashing(d))</div><div class="line">  &#123;</div><div class="line">    _dictRehashStep(d);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* Get the index of the new element, or -1 if</span></div><div class="line">   * the element already exists. */</div><div class="line">  <span class="comment">// 计算键在哈希表中的索引值</span></div><div class="line">  <span class="comment">// 如果值为 -1 ，那么表示键已经存在</span></div><div class="line">  <span class="comment">// T = O(N)</span></div><div class="line">  <span class="keyword">if</span> ((index = _dictKeyIndex(d, <span class="built_in">key</span>)) == <span class="number">-1</span>)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">return</span> NULL;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// T = O(1)</span></div><div class="line">  <span class="comment">/* Allocate the memory and store the new entry */</span></div><div class="line">  <span class="comment">// 如果字典正在 rehash ，那么将新键添加到 1 号哈希表</span></div><div class="line">  <span class="comment">// 否则，将新键添加到 0 号哈希表</span></div><div class="line">  ht = dictIsRehashing(d) ? &amp;d-&gt;ht[<span class="number">1</span>] : &amp;d-&gt;ht[<span class="number">0</span>];</div><div class="line">  <span class="comment">// 为新节点分配空间</span></div><div class="line">  entry = zmalloc(sizeof(*entry));</div><div class="line">  <span class="comment">// 将新节点插入到链表表头</span></div><div class="line">  entry-&gt;next = ht-&gt;table[index];</div><div class="line">  ht-&gt;table[index] = entry;</div><div class="line">  <span class="comment">// 更新哈希表已使用节点数量</span></div><div class="line">  ht-&gt;used++;</div><div class="line"></div><div class="line">  <span class="comment">/* Set the hash entry fields. */</span></div><div class="line">  <span class="comment">// 设置新节点的键</span></div><div class="line">  <span class="comment">// T = O(1)</span></div><div class="line">  dictSetKey(d, entry, <span class="built_in">key</span>);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> entry;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>添加给定键值对到字典之中，如果已经存在，就替换为给定的新的值。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Add an element, discarding the old if the key already exists.</span></div><div class="line"> *</div><div class="line"> * 将给定的键值对添加到字典中，如果键已经存在，那么删除旧有的键值对。</div><div class="line"> *</div><div class="line"> * Return 1 if the key was added from scratch, 0 if there was already an</div><div class="line"> * element with such key and dictReplace() just performed a value update</div><div class="line"> * operation. </div><div class="line"> *</div><div class="line"> * 如果键值对为全新添加，那么返回 1 。</div><div class="line"> * 如果键值对是通过对原有的键值对更新得来的，那么返回 0 。</div><div class="line"> *</div><div class="line"> * T = O(N)</div><div class="line"> */</div><div class="line"><span class="built_in">int</span> dictReplace(dict *d, <span class="keyword">void</span> *<span class="built_in">key</span>, <span class="keyword">void</span> *val)</div><div class="line">&#123;</div><div class="line">  dictEntry *entry, auxentry;</div><div class="line"></div><div class="line">  <span class="comment">/* Try to add the element. If the key</span></div><div class="line">   * does not exists dictAdd will suceed. */</div><div class="line">  <span class="comment">// 尝试直接将键值对添加到字典</span></div><div class="line">  <span class="comment">// 如果键 key 不存在的话，添加会成功</span></div><div class="line">  <span class="comment">// T = O(N)</span></div><div class="line">  <span class="keyword">if</span> (dictAdd(d, <span class="built_in">key</span>, val) == DICT_OK)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* It already exists, get the entry */</span></div><div class="line">  <span class="comment">// 运行到这里，说明键 key 已经存在，那么找出包含这个 key 的节点</span></div><div class="line">  <span class="comment">// T = O(1)</span></div><div class="line">  entry = dictFind(d, <span class="built_in">key</span>);</div><div class="line">  <span class="comment">/* Set the new value and free the old one. Note that it is important</span></div><div class="line">   * to do that in this order, as the value may just be exactly the same</div><div class="line">   * as the previous one. In this context, think to reference counting,</div><div class="line">   * you want to increment (set), and then decrement (free), and not the</div><div class="line">   * reverse. */</div><div class="line">  <span class="comment">// 先保存原有的值的指针</span></div><div class="line">  auxentry = *entry;</div><div class="line">  <span class="comment">// 然后设置新的值</span></div><div class="line">  <span class="comment">// T = O(1)</span></div><div class="line">  dictSetVal(d, entry, val);</div><div class="line">  <span class="comment">// 然后释放旧值</span></div><div class="line">  <span class="comment">// T = O(1)</span></div><div class="line">  dictFreeVal(d, &amp;auxentry);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>返回给定key对应字典中的节点，如果key在字典之中不存在，就在字典之中创建这个节点。</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> * dictAddRaw() 根据给定 <span class="built_in">key</span> 释放存在，执行以下动作：</div><div class="line"> *</div><div class="line"> * <span class="number">1</span>) <span class="built_in">key</span> 已经存在，返回包含该 <span class="built_in">key</span> 的字典节点</div><div class="line"> * <span class="number">2</span>) <span class="built_in">key</span> 不存在，那么将 <span class="built_in">key</span> 添加到字典</div><div class="line"> *</div><div class="line"> * 不论发生以上的哪一种情况，</div><div class="line"> * dictAddRaw() 都总是返回包含给定 <span class="built_in">key</span> 的字典节点。</div><div class="line"> *</div><div class="line"> * T = O(N)</div><div class="line"> */</div><div class="line">dictEntry *dictReplaceRaw(dict *d, void *<span class="built_in">key</span>)</div><div class="line">&#123;</div><div class="line"></div><div class="line">  <span class="comment">// 使用 key 在字典中查找节点</span></div><div class="line">  <span class="comment">// T = O(1)</span></div><div class="line">  dictEntry *entry = dictFind(d, <span class="built_in">key</span>);</div><div class="line"></div><div class="line">  <span class="comment">// 如果节点找到了直接返回节点，否则添加并返回一个新节点</span></div><div class="line">  <span class="comment">// T = O(N)</span></div><div class="line">  return entry ? entry : dictAddRaw(d, <span class="built_in">key</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查找并删除包含给定键的节点。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 查找并删除包含给定键的节点</div><div class="line"> *</div><div class="line"> * 参数 nofree 决定是否调用键和值的释放函数</div><div class="line"> * 0 表示调用，1 表示不调用</div><div class="line"> *</div><div class="line"> * 找到并成功删除返回 DICT_OK ，没找到则返回 DICT_ERR</div><div class="line"> *</div><div class="line"> * T = O(1)</div><div class="line"> */</div><div class="line">static int dictGenericDelete(dict *<span class="keyword">d</span>, <span class="keyword">const</span> void *key, int nofree)</div><div class="line">&#123;</div><div class="line">  unsigned int <span class="keyword">h</span>, idx;</div><div class="line">  dictEntry *<span class="keyword">he</span>, *prevHe;</div><div class="line">  int <span class="keyword">table</span>;</div><div class="line"></div><div class="line">  <span class="comment">// 字典（的哈希表）为空</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">d</span>-&gt;ht[0].size == 0)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">return</span> DICT_ERR;</div><div class="line">  &#125; <span class="comment">/* d-&gt;ht[0].table is NULL */</span></div><div class="line"></div><div class="line">  <span class="comment">// 进行单步 rehash ，T = O(1)</span></div><div class="line">  <span class="keyword">if</span> (dictIsRehashing(<span class="keyword">d</span>))</div><div class="line">  &#123;</div><div class="line">    _dictRehashStep(<span class="keyword">d</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 计算哈希值</span></div><div class="line">  <span class="keyword">h</span> = dictHashKey(<span class="keyword">d</span>, key);</div><div class="line"></div><div class="line">  <span class="comment">// 遍历哈希表</span></div><div class="line">  <span class="comment">// T = O(1)</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">table</span> = 0; <span class="keyword">table</span> &lt;= 1; <span class="keyword">table</span>++)</div><div class="line">  &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 计算索引值</span></div><div class="line">    idx = <span class="keyword">h</span> &amp; <span class="keyword">d</span>-&gt;ht[<span class="keyword">table</span>].sizemask;</div><div class="line">    <span class="comment">// 指向该索引上的链表</span></div><div class="line">    <span class="keyword">he</span> = <span class="keyword">d</span>-&gt;ht[<span class="keyword">table</span>].<span class="keyword">table</span>[idx];</div><div class="line">    prevHe = NULL;</div><div class="line">    <span class="comment">// 遍历链表上的所有节点</span></div><div class="line">    <span class="comment">// T = O(1)</span></div><div class="line">    <span class="keyword">while</span> (<span class="keyword">he</span>)</div><div class="line">    &#123;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (dictCompareKeys(<span class="keyword">d</span>, key, <span class="keyword">he</span>-&gt;key))</div><div class="line">      &#123;</div><div class="line">        <span class="comment">// 超找目标节点</span></div><div class="line"></div><div class="line">        <span class="comment">/* Unlink the element from the list */</span></div><div class="line">        <span class="comment">// 从链表中删除</span></div><div class="line">        <span class="keyword">if</span> (prevHe)</div><div class="line">        &#123;</div><div class="line">          prevHe-&gt;next = <span class="keyword">he</span>-&gt;next;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">          <span class="keyword">d</span>-&gt;ht[<span class="keyword">table</span>].<span class="keyword">table</span>[idx] = <span class="keyword">he</span>-&gt;next;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 释放调用键和值的释放函数？</span></div><div class="line">        <span class="keyword">if</span> (!nofree)</div><div class="line">        &#123;</div><div class="line">          dictFreeKey(<span class="keyword">d</span>, <span class="keyword">he</span>);</div><div class="line">          dictFreeVal(<span class="keyword">d</span>, <span class="keyword">he</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 释放节点本身</span></div><div class="line">        zfree(<span class="keyword">he</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 更新已使用节点数量</span></div><div class="line">        <span class="keyword">d</span>-&gt;ht[<span class="keyword">table</span>].used--;</div><div class="line"></div><div class="line">        <span class="comment">// 返回已找到信号</span></div><div class="line">        <span class="keyword">return</span> DICT_OK;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      prevHe = <span class="keyword">he</span>;</div><div class="line">      <span class="keyword">he</span> = <span class="keyword">he</span>-&gt;next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 如果执行到这里，说明在 0 号哈希表中找不到给定键</span></div><div class="line">    <span class="comment">// 那么根据字典是否正在进行 rehash ，决定要不要查找 1 号哈希表</span></div><div class="line">    <span class="keyword">if</span> (!dictIsRehashing(<span class="keyword">d</span>))</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 没找到</span></div><div class="line">  <span class="keyword">return</span> DICT_ERR; <span class="comment">/* not found */</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 从字典中删除包含给定键的节点</div><div class="line"> * </div><div class="line"> * 并且调用键值的释放函数来删除键值</div><div class="line"> *</div><div class="line"> * 找到并成功删除返回 DICT_OK ，没找到则返回 DICT_ERR</div><div class="line"> * T = O(1)</div><div class="line"> */</div><div class="line">int dictDelete(dict *ht, <span class="keyword">const</span> void *key)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> dictGenericDelete(ht, key, 0);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 从字典中删除包含给定键的节点</div><div class="line"> * </div><div class="line"> * 但不调用键值的释放函数来删除键值</div><div class="line"> *</div><div class="line"> * 找到并成功删除返回 DICT_OK ，没找到则返回 DICT_ERR</div><div class="line"> * T = O(1)</div><div class="line"> */</div><div class="line">int dictDeleteNoFree(dict *ht, <span class="keyword">const</span> void *key)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> dictGenericDelete(ht, key, 1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>释放整个字典</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 删除哈希表上的所有节点，并重置哈希表的各项属性</div><div class="line"> *</div><div class="line"> * T = O(N)</div><div class="line"> */</div><div class="line">int _dictClear(dict *d, dictht *ht, void(callback)(void *))</div><div class="line">&#123;</div><div class="line">  unsigned long i;</div><div class="line"></div><div class="line">  <span class="comment">/* Free all the elements */</span></div><div class="line">  <span class="comment">// 遍历整个哈希表</span></div><div class="line">  <span class="comment">// T = O(N)</span></div><div class="line">  <span class="function"><span class="title">for</span> (i = 0; i &lt; ht-&gt;</span><span class="function"><span class="title">size</span> &amp;&amp; ht-&gt;</span>used &gt; <span class="number">0</span>; i++)</div><div class="line">  &#123;</div><div class="line">    dictEntry *he, *nextHe;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (callback &amp;&amp; (i &amp; <span class="number">65535</span>) == <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">      <span class="function"><span class="title">callback</span>(d-&gt;</span>privdata);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 跳过空索引</span></div><div class="line">    <span class="function"><span class="title">if</span> ((he = ht-&gt;</span>table[i]) == NULL)</div><div class="line">    &#123;</div><div class="line">      continue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 遍历整个链表</span></div><div class="line">    <span class="comment">// T = O(1)</span></div><div class="line">    <span class="keyword">while</span> (he)</div><div class="line">    &#123;</div><div class="line">      <span class="function"><span class="title">nextHe</span> = he-&gt;</span>next;</div><div class="line">      <span class="comment">// 删除键</span></div><div class="line">      dictFreeKey(d, he);</div><div class="line">      <span class="comment">// 删除值</span></div><div class="line">      dictFreeVal(d, he);</div><div class="line">      <span class="comment">// 释放节点</span></div><div class="line">      zfree(he);</div><div class="line"></div><div class="line">      <span class="comment">// 更新已使用节点计数</span></div><div class="line">      <span class="function"><span class="title">ht</span>-&gt;</span>used--;</div><div class="line"></div><div class="line">      <span class="comment">// 处理下个节点</span></div><div class="line">      he = nextHe;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* Free the table and the allocated cache structure */</span></div><div class="line">  <span class="comment">// 释放哈希表结构</span></div><div class="line">  <span class="function"><span class="title">zfree</span>(ht-&gt;</span>table);</div><div class="line"></div><div class="line">  <span class="comment">/* Re-initialize the table */</span></div><div class="line">  <span class="comment">// 重置哈希表属性</span></div><div class="line">  _dictReset(ht);</div><div class="line"></div><div class="line">  return DICT_OK; <span class="comment">/* never fails */</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Clear &amp; Release the hash table */</span></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 删除并释放整个字典</div><div class="line"> *</div><div class="line"> * T = O(N)</div><div class="line"> */</div><div class="line">void dictRelease(dict *d)</div><div class="line">&#123;</div><div class="line">  <span class="comment">// 删除并清空两个哈希表</span></div><div class="line">  _<span class="function"><span class="title">dictClear</span>(d, &amp;d-&gt;</span>ht[<span class="number">0</span>], NULL);</div><div class="line">  _<span class="function"><span class="title">dictClear</span>(d, &amp;d-&gt;</span>ht[<span class="number">1</span>], NULL);</div><div class="line">  <span class="comment">// 释放节点结构</span></div><div class="line">  zfree(d);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在字典之中查找指定的key</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 返回字典中包含键 key 的节点</div><div class="line"> *</div><div class="line"> * 找到返回节点，找不到返回 NULL</div><div class="line"> *</div><div class="line"> * T = O(1)</div><div class="line"> */</div><div class="line">dictEntry *dictFind(dict *<span class="keyword">d</span>, <span class="keyword">const</span> void *key)</div><div class="line">&#123;</div><div class="line">  dictEntry *<span class="keyword">he</span>;</div><div class="line">  unsigned int <span class="keyword">h</span>, idx, <span class="keyword">table</span>;</div><div class="line"></div><div class="line">  <span class="comment">// 字典（的哈希表）为空</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">d</span>-&gt;ht[0].size == 0)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">return</span> NULL;</div><div class="line">  &#125; <span class="comment">/* We don't have a table at all */</span></div><div class="line"></div><div class="line">  <span class="comment">// 如果条件允许的话，进行单步 rehash</span></div><div class="line">  <span class="keyword">if</span> (dictIsRehashing(<span class="keyword">d</span>))</div><div class="line">  &#123;</div><div class="line">    _dictRehashStep(<span class="keyword">d</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 计算键的哈希值</span></div><div class="line">  <span class="keyword">h</span> = dictHashKey(<span class="keyword">d</span>, key);</div><div class="line">  <span class="comment">// 在字典的哈希表中查找这个键</span></div><div class="line">  <span class="comment">// T = O(1)</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">table</span> = 0; <span class="keyword">table</span> &lt;= 1; <span class="keyword">table</span>++)</div><div class="line">  &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 计算索引值</span></div><div class="line">    idx = <span class="keyword">h</span> &amp; <span class="keyword">d</span>-&gt;ht[<span class="keyword">table</span>].sizemask;</div><div class="line"></div><div class="line">    <span class="comment">// 遍历给定索引上的链表的所有节点，查找 key</span></div><div class="line">    <span class="keyword">he</span> = <span class="keyword">d</span>-&gt;ht[<span class="keyword">table</span>].<span class="keyword">table</span>[idx];</div><div class="line">    <span class="comment">// T = O(1)</span></div><div class="line">    <span class="keyword">while</span> (<span class="keyword">he</span>)</div><div class="line">    &#123;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (dictCompareKeys(<span class="keyword">d</span>, key, <span class="keyword">he</span>-&gt;key))</div><div class="line">      &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">he</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">he</span> = <span class="keyword">he</span>-&gt;next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 如果程序遍历完 0 号哈希表，仍然没找到指定的键的节点</span></div><div class="line">    <span class="comment">// 那么程序会检查字典是否在进行 rehash ，</span></div><div class="line">    <span class="comment">// 然后才决定是直接返回 NULL ，还是继续查找 1 号哈希表</span></div><div class="line">    <span class="keyword">if</span> (!dictIsRehashing(<span class="keyword">d</span>))</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">return</span> NULL;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 进行到这里时，说明两个哈希表都没找到</span></div><div class="line">  <span class="keyword">return</span> NULL;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 获取包含给定键的节点的值</div><div class="line"> *</div><div class="line"> * 如果节点不为空，返回节点的值</div><div class="line"> * 否则返回 NULL</div><div class="line"> *</div><div class="line"> * T = O(1)</div><div class="line"> */</div><div class="line">void *dictFetchValue(dict *<span class="keyword">d</span>, <span class="keyword">const</span> void *key)</div><div class="line">&#123;</div><div class="line">  dictEntry *<span class="keyword">he</span>;</div><div class="line"></div><div class="line">  <span class="comment">// T = O(1)</span></div><div class="line">  <span class="keyword">he</span> = dictFind(<span class="keyword">d</span>, key);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">he</span> ? dictGetVal(<span class="keyword">he</span>) : NULL;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>迭代器相关</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 创建并返回给定字典的不安全迭代器</div><div class="line"> *</div><div class="line"> * T = O(1)</div><div class="line"> */</div><div class="line">dictIterator *dictGetIterator(dict *d)</div><div class="line">&#123;</div><div class="line">  dictIterator *iter = zmalloc(sizeof(*iter));</div><div class="line"></div><div class="line">  <span class="function"><span class="title">iter</span>-&gt;</span>d = d;</div><div class="line">  <span class="function"><span class="title">iter</span>-&gt;</span>table = <span class="number">0</span>;</div><div class="line">  <span class="function"><span class="title">iter</span>-&gt;</span>index = -<span class="number">1</span>;</div><div class="line">  <span class="function"><span class="title">iter</span>-&gt;</span>safe = <span class="number">0</span>;</div><div class="line">  <span class="function"><span class="title">iter</span>-&gt;</span>entry = NULL;</div><div class="line">  <span class="function"><span class="title">iter</span>-&gt;</span>nextEntry = NULL;</div><div class="line"></div><div class="line">  return iter;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 创建并返回给定节点的安全迭代器</div><div class="line"> *</div><div class="line"> * T = O(1)</div><div class="line"> */</div><div class="line">dictIterator *dictGetSafeIterator(dict *d)</div><div class="line">&#123;</div><div class="line">  dictIterator *i = dictGetIterator(d);</div><div class="line"></div><div class="line">  <span class="comment">// 设置安全迭代器标识</span></div><div class="line">  <span class="function"><span class="title">i</span>-&gt;</span>safe = <span class="number">1</span>;</div><div class="line"></div><div class="line">  return i;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 返回迭代器指向的当前节点</div><div class="line"> *</div><div class="line"> * 字典迭代完毕时，返回 NULL</div><div class="line"> *</div><div class="line"> * T = O(1)</div><div class="line"> */</div><div class="line">dictEntry *dictNext(dictIterator *iter)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</div><div class="line">  &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 进入这个循环有两种可能：</span></div><div class="line">    <span class="comment">// 1) 这是迭代器第一次运行</span></div><div class="line">    <span class="comment">// 2) 当前索引链表中的节点已经迭代完（NULL 为链表的表尾）</span></div><div class="line">    <span class="function"><span class="title">if</span> (iter-&gt;</span>entry == NULL)</div><div class="line">    &#123;</div><div class="line"></div><div class="line">      <span class="comment">// 指向被迭代的哈希表</span></div><div class="line">      <span class="function"><span class="title">dictht</span> *ht = &amp;iter-&gt;</span><span class="function"><span class="title">d</span>-&gt;</span><span class="function"><span class="title">ht</span>[iter-&gt;</span>table];</div><div class="line"></div><div class="line">      <span class="comment">// 初次迭代时执行</span></div><div class="line">      <span class="function"><span class="title">if</span> (iter-&gt;</span><span class="function"><span class="title">index</span> == -1 &amp;&amp; iter-&gt;</span>table == <span class="number">0</span>)</div><div class="line">      &#123;</div><div class="line">        <span class="comment">// 如果是安全迭代器，那么更新安全迭代器计数器</span></div><div class="line">        <span class="function"><span class="title">if</span> (iter-&gt;</span>safe)</div><div class="line">        &#123;</div><div class="line">          <span class="function"><span class="title">iter</span>-&gt;</span><span class="function"><span class="title">d</span>-&gt;</span>iterators++;</div><div class="line">          <span class="comment">// 如果是不安全迭代器，那么计算指纹</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">          <span class="function"><span class="title">iter</span>-&gt;</span><span class="function"><span class="title">fingerprint</span> = dictFingerprint(iter-&gt;</span>d);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// 更新索引</span></div><div class="line">      <span class="function"><span class="title">iter</span>-&gt;</span>index++;</div><div class="line"></div><div class="line">      <span class="comment">// 如果迭代器的当前索引大于当前被迭代的哈希表的大小</span></div><div class="line">      <span class="comment">// 那么说明这个哈希表已经迭代完毕</span></div><div class="line">      <span class="function"><span class="title">if</span> (iter-&gt;</span><span class="function"><span class="title">index</span> &gt;= (signed) ht-&gt;</span>size)</div><div class="line">      &#123;</div><div class="line">        <span class="comment">// 如果正在 rehash 的话，那么说明 1 号哈希表也正在使用中</span></div><div class="line">        <span class="comment">// 那么继续对 1 号哈希表进行迭代</span></div><div class="line">        <span class="function"><span class="title">if</span> (dictIsRehashing(iter-&gt;</span><span class="function"><span class="title">d</span>) &amp;&amp; iter-&gt;</span>table == <span class="number">0</span>)</div><div class="line">        &#123;</div><div class="line">          <span class="function"><span class="title">iter</span>-&gt;</span>table++;</div><div class="line">          <span class="function"><span class="title">iter</span>-&gt;</span>index = <span class="number">0</span>;</div><div class="line">          <span class="function"><span class="title">ht</span> = &amp;iter-&gt;</span><span class="function"><span class="title">d</span>-&gt;</span>ht[<span class="number">1</span>];</div><div class="line">          <span class="comment">// 如果没有 rehash ，那么说明迭代已经完成</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">          break;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// 如果进行到这里，说明这个哈希表并未迭代完</span></div><div class="line">      <span class="comment">// 更新节点指针，指向下个索引链表的表头节点</span></div><div class="line">      <span class="function"><span class="title">iter</span>-&gt;</span><span class="function"><span class="title">entry</span> = ht-&gt;</span><span class="function"><span class="title">table</span>[iter-&gt;</span>index];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">      <span class="comment">// 执行到这里，说明程序正在迭代某个链表</span></div><div class="line">      <span class="comment">// 将节点指针指向链表的下个节点</span></div><div class="line">      <span class="function"><span class="title">iter</span>-&gt;</span><span class="function"><span class="title">entry</span> = iter-&gt;</span>nextEntry;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 如果当前节点不为空，那么也记录下该节点的下个节点</span></div><div class="line">    <span class="comment">// 因为安全迭代器有可能会将迭代器返回的当前节点删除</span></div><div class="line">    <span class="function"><span class="title">if</span> (iter-&gt;</span>entry)</div><div class="line">    &#123;</div><div class="line">      <span class="comment">/* We need to save the 'next' here, the iterator user</span></div><div class="line">       * may delete the entry we are returning. */</div><div class="line">      <span class="function"><span class="title">iter</span>-&gt;</span><span class="function"><span class="title">nextEntry</span> = iter-&gt;</span><span class="function"><span class="title">entry</span>-&gt;</span>next;</div><div class="line">      <span class="function"><span class="title">return</span> iter-&gt;</span>entry;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 迭代完毕</span></div><div class="line">  return NULL;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 释放给定字典迭代器</div><div class="line"> *</div><div class="line"> * T = O(1)</div><div class="line"> */</div><div class="line">void dictReleaseIterator(dictIterator *iter)</div><div class="line">&#123;</div><div class="line"></div><div class="line">  <span class="function"><span class="title">if</span> (!(iter-&gt;</span><span class="function"><span class="title">index</span> == -1 &amp;&amp; iter-&gt;</span>table == <span class="number">0</span>))</div><div class="line">  &#123;</div><div class="line">    <span class="comment">// 释放安全迭代器时，安全迭代器计数器减一</span></div><div class="line">    <span class="function"><span class="title">if</span> (iter-&gt;</span>safe)</div><div class="line">    &#123;</div><div class="line">      <span class="function"><span class="title">iter</span>-&gt;</span><span class="function"><span class="title">d</span>-&gt;</span>iterators--;</div><div class="line">      <span class="comment">// 释放不安全迭代器时，验证指纹是否有变化</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">      <span class="function"><span class="title">assert</span>(iter-&gt;</span><span class="function"><span class="title">fingerprint</span> == dictFingerprint(iter-&gt;</span>d));</div><div class="line">  &#125;</div><div class="line">  zfree(iter);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>随机返回字典中的key</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 随机返回字典中任意一个节点。</div><div class="line"> *</div><div class="line"> * 可用于实现随机化算法。</div><div class="line"> *</div><div class="line"> * 如果字典为空，返回 NULL 。</div><div class="line"> *</div><div class="line"> * T = O(N)</div><div class="line">*/</div><div class="line">dictEntry *dictGetRandomKey(dict *d)</div><div class="line">&#123;</div><div class="line">  dictEntry *he, *orighe;</div><div class="line">  unsigned int h;</div><div class="line">  int listlen, listele;</div><div class="line"></div><div class="line">  <span class="comment">// 字典为空</span></div><div class="line">  <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>)</div><div class="line">  &#123;</div><div class="line">    return NULL;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 进行单步 rehash</span></div><div class="line">  <span class="keyword">if</span> (dictIsRehashing(d))</div><div class="line">  &#123;</div><div class="line">    _dictRehashStep(d);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 如果正在 rehash ，那么将 1 号哈希表也作为随机查找的目标</span></div><div class="line">  <span class="keyword">if</span> (dictIsRehashing(d))</div><div class="line">  &#123;</div><div class="line">    <span class="comment">// T = O(N)</span></div><div class="line">    <span class="keyword">do</span></div><div class="line">    &#123;</div><div class="line">      <span class="function"><span class="title">h</span> = random() % (d-&gt;</span><span class="function"><span class="title">ht</span>[0].size + d-&gt;</span>ht[<span class="number">1</span>].size);</div><div class="line">      <span class="function"><span class="title">he</span> = (h &gt;= d-&gt;</span><span class="function"><span class="title">ht</span>[0].size) ? d-&gt;</span><span class="function"><span class="title">ht</span>[1].table[h - d-&gt;</span>ht[<span class="number">0</span>].size] :</div><div class="line">           <span class="function"><span class="title">d</span>-&gt;</span>ht[<span class="number">0</span>].table[h];</div><div class="line">    &#125; <span class="keyword">while</span> (he == NULL);</div><div class="line">    <span class="comment">// 否则，只从 0 号哈希表中查找节点</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">  &#123;</div><div class="line">    <span class="comment">// T = O(N)</span></div><div class="line">    <span class="keyword">do</span></div><div class="line">    &#123;</div><div class="line">      <span class="function"><span class="title">h</span> = random() &amp; d-&gt;</span>ht[<span class="number">0</span>].sizemask;</div><div class="line">      <span class="function"><span class="title">he</span> = d-&gt;</span>ht[<span class="number">0</span>].table[h];</div><div class="line">    &#125; <span class="keyword">while</span> (he == NULL);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* Now we found a non empty bucket, but it is a linked</span></div><div class="line">   * list and we need to get a random element from the list.</div><div class="line">   * The only sane way to do so is counting the elements and</div><div class="line">   * select a random index. */</div><div class="line">  <span class="comment">// 目前 he 已经指向一个非空的节点链表</span></div><div class="line">  <span class="comment">// 程序将从这个链表随机返回一个节点</span></div><div class="line">  listlen = <span class="number">0</span>;</div><div class="line">  orighe = he;</div><div class="line">  <span class="comment">// 计算节点数量, T = O(1)</span></div><div class="line">  <span class="keyword">while</span> (he)</div><div class="line">  &#123;</div><div class="line">    <span class="function"><span class="title">he</span> = he-&gt;</span>next;</div><div class="line">    listlen++;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 取模，得出随机节点的索引</span></div><div class="line">  listele = random() % listlen;</div><div class="line">  he = orighe;</div><div class="line">  <span class="comment">// 按索引查找节点</span></div><div class="line">  <span class="comment">// T = O(1)</span></div><div class="line">  <span class="keyword">while</span> (listele--)</div><div class="line">  &#123;</div><div class="line">    <span class="function"><span class="title">he</span> = he-&gt;</span>next;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 返回随机节点</span></div><div class="line">  return he;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="dictScan"><a href="#dictScan" class="headerlink" title="dictScan"></a>dictScan</h2><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> <span class="built_in">cursor</span> = <span class="number">0</span>;</div><div class="line"><span class="built_in">do</span> &#123;  </div><div class="line">    <span class="built_in">cursor</span> = dictScan(ht, <span class="built_in">cursor</span>, scanCallback, privdata);  </div><div class="line">&#125; <span class="built_in">while</span> (<span class="built_in">cursor</span> &amp;&amp;  </div><div class="line">      maxiterations-- &amp;&amp;  </div><div class="line">      listLength(keys) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)count);</div></pre></td></tr></table></figure>
<p>dictScan函数用于迭代给定字典中的所有元素，函数保证，在迭代从开始到结束期间，一致存在于字典中的元素肯定会被迭代到，但是同一个元素可能会被返回多次。每一个元素返回的时候，会执行输入的回调函数fn，fn函数的第一个参数是privdata，第二个参数是字典结点de。dictScan函数能够应对迭代过程之中，字典中桶的数目发生改变的情况。因而，cursor采用的是高位向低位加1的算法实现，这种算法能够保证迭代过程之中，若字典的桶的大小发生改变，需要重复访问的字典之中的元素数目最小。</p>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>假设字典中桶的数目为8，在执行第7次迭代的时候字典大小扩容为16，此时cursor为11对应的遍历会重复hash值为3的桶中的元素，之后的遍历便不会再重复了。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1fl6207rzcmj30g105jwf5.jpg" alt=""></p>
<h3 id="缩容"><a href="#缩容" class="headerlink" title="缩容"></a>缩容</h3><p>假设字典的桶的数目原本为16，在进行第14次遍历的时候，字典的桶的数目缩容为8，此时cursor值为7，并不会产生重复访问的情况。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tKfTcgy1fl6250k3pvj30g1081my8.jpg" alt=""></p>
<p>更多情况参见 <a href="http://blog.csdn.net/breaksoftware/article/details/53509986" target="_blank" rel="external">csdn博客</a></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>cursor值每次加1，从高位向低位进位。首先处理桶数目较小的hash表，在大表中遍历的hash值是一个组合数序列，假设这些数为Vi，有 Vi &amp; m1 == cursor &amp; m0 (m1为大hash表的sizemask，m1为小hash表的sizemask)。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// http://blog.csdn.net/breaksoftware/article/details/53509986</span></div><div class="line">unsigned long dictScan(dict *d,</div><div class="line">                       unsigned long v,</div><div class="line">                       dictScanFunction *fn,</div><div class="line">                       void *privdata)</div><div class="line">&#123;</div><div class="line">  dictht *t0, *t1;</div><div class="line">  const dictEntry *de;</div><div class="line">  unsigned long m0, m1;</div><div class="line"></div><div class="line">  <span class="comment">// 跳过空字典</span></div><div class="line">  <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>)</div><div class="line">  &#123;</div><div class="line">    return <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 迭代只有一个哈希表的字典</span></div><div class="line">  <span class="comment">/// 直接顺序迭代所有的元素</span></div><div class="line">  <span class="keyword">if</span> (!dictIsRehashing(d))</div><div class="line">  &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 指向哈希表</span></div><div class="line">    <span class="function"><span class="title">t0</span> = &amp;(d-&gt;</span>ht[<span class="number">0</span>]);</div><div class="line"></div><div class="line">    <span class="comment">// 记录 mask</span></div><div class="line">    <span class="function"><span class="title">m0</span> = t0-&gt;</span>sizemask;</div><div class="line"></div><div class="line">    <span class="comment">/* Emit entries at cursor */</span></div><div class="line">    <span class="comment">// 指向哈希桶</span></div><div class="line">    <span class="comment">// hash值从v开始</span></div><div class="line">    <span class="function"><span class="title">de</span> = t0-&gt;</span>table[v &amp; m0];</div><div class="line">    <span class="comment">// 遍历桶中的所有节点</span></div><div class="line">    <span class="keyword">while</span> (de)</div><div class="line">    &#123;</div><div class="line">      fn(privdata, de);</div><div class="line">      <span class="function"><span class="title">de</span> = de-&gt;</span>next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 迭代有两个哈希表的字典</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">  &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 指向两个哈希表</span></div><div class="line">    <span class="function"><span class="title">t0</span> = &amp;d-&gt;</span>ht[<span class="number">0</span>];</div><div class="line">    <span class="function"><span class="title">t1</span> = &amp;d-&gt;</span>ht[<span class="number">1</span>];</div><div class="line"></div><div class="line">    <span class="comment">/* Make sure t0 is the smaller and t1 is the bigger table */</span></div><div class="line">    <span class="comment">// 确保 t0 比 t1 要小</span></div><div class="line">    <span class="function"><span class="title">if</span> (t0-&gt;</span><span class="function"><span class="title">size</span> &gt; t1-&gt;</span>size)</div><div class="line">    &#123;</div><div class="line">      <span class="function"><span class="title">t0</span> = &amp;d-&gt;</span>ht[<span class="number">1</span>];</div><div class="line">      <span class="function"><span class="title">t1</span> = &amp;d-&gt;</span>ht[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 记录掩码</span></div><div class="line">    <span class="function"><span class="title">m0</span> = t0-&gt;</span>sizemask;</div><div class="line">    <span class="function"><span class="title">m1</span> = t1-&gt;</span>sizemask;</div><div class="line"></div><div class="line">    <span class="comment">/// 处理完小的hash桶</span></div><div class="line">    <span class="comment">/* Emit entries at cursor */</span></div><div class="line">    <span class="comment">// 指向桶，并迭代桶中的所有节点</span></div><div class="line">    <span class="function"><span class="title">de</span> = t0-&gt;</span>table[v &amp; m0];</div><div class="line">    <span class="keyword">while</span> (de)</div><div class="line">    &#123;</div><div class="line">      fn(privdata, de);</div><div class="line">      <span class="function"><span class="title">de</span> = de-&gt;</span>next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* Iterate over indices in larger table that are the expansion</span></div><div class="line">     * of the index pointed to by the cursor in the smaller table */</div><div class="line">    <span class="comment">// Iterate over indices in larger table             // 迭代大表中的桶</span></div><div class="line">    <span class="comment">// that are the expansion of the index pointed to   // 这些桶被索引的 expansion 所指向</span></div><div class="line">    <span class="comment">// by the cursor in the smaller table               //</span></div><div class="line">    <span class="keyword">do</span></div><div class="line">    &#123;</div><div class="line">      <span class="comment">/* Emit entries at cursor */</span></div><div class="line">      <span class="comment">// 指向桶，并迭代桶中的所有节点</span></div><div class="line">      <span class="function"><span class="title">de</span> = t1-&gt;</span>table[v &amp; m1];</div><div class="line">      <span class="keyword">while</span> (de)</div><div class="line">      &#123;</div><div class="line">        fn(privdata, de);</div><div class="line">        <span class="function"><span class="title">de</span> = de-&gt;</span>next;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">/// 低位和v一致，高位按照所有可能的组合进行变动</span></div><div class="line">      <span class="comment">/* Increment bits not covered by the smaller mask */</span></div><div class="line">      v = (((v | m0) + <span class="number">1</span>) &amp; ~m0) | (v &amp; m0);</div><div class="line"></div><div class="line">      <span class="comment">/* Continue while bits covered by mask difference is non-zero */</span></div><div class="line">    &#125; <span class="keyword">while</span> (v &amp; (m0 ^ m1)); <span class="comment">// 相差的bit各种组合的数目之和</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/// 加法，施加在高位上，向低位进位</span></div><div class="line">  <span class="comment">/* Set unmasked bits so incrementing the reversed cursor</span></div><div class="line">   * operates on the masked bits of the smaller table */</div><div class="line">  v |= ~m0;</div><div class="line"></div><div class="line">  <span class="comment">/* Increment the reverse cursor */</span></div><div class="line">  v = rev(v);</div><div class="line">  v++;</div><div class="line">  v = rev(v);</div><div class="line"></div><div class="line">  return v;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[redis 链表]]></title>
      <url>/2017/11/04/redis-%E9%93%BE%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h1 id="redis-链表结构简介"><a href="#redis-链表结构简介" class="headerlink" title="redis 链表结构简介"></a>redis 链表结构简介</h1><p>链表是基本的数据结构，在stl中提供了list供程序员进行调用，在C语言中需要自己实现list。在redis中，实现list的代码在<code>adlist.h adlist.c</code>文件之中定义。redis中链表结点定义如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 双端链表节点</div><div class="line"> */</div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">  <span class="comment">// 前置节点</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></div><div class="line"></div><div class="line">  <span class="comment">// 后置节点</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></div><div class="line"></div><div class="line">  <span class="comment">// 节点的值</span></div><div class="line">  <span class="keyword">void</span> *value;</div><div class="line"></div><div class="line">&#125; listNode;</div></pre></td></tr></table></figure>
<p>在C语言之中，没有C++之中的类，但是可以结合函数指针达到类似的效果，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * 双端链表结构</div><div class="line"> */</div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">  <span class="comment">// 表头节点</span></div><div class="line">  listNode *head;</div><div class="line"></div><div class="line">  <span class="comment">// 表尾节点</span></div><div class="line">  listNode *tail;</div><div class="line"></div><div class="line">  <span class="comment">// 节点值复制函数</span></div><div class="line">  <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</div><div class="line"></div><div class="line">  <span class="comment">// 节点值释放函数</span></div><div class="line">  <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</div><div class="line"></div><div class="line">  <span class="comment">// 节点值对比函数</span></div><div class="line">  <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</div><div class="line"></div><div class="line">  <span class="comment">// 链表所包含的节点数量</span></div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</div><div class="line"></div><div class="line">&#125; <span class="built_in">list</span>;</div></pre></td></tr></table></figure>
<p>下述宏定义实际上调用的是list结构体之中对应的函数。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Functions implemented as macros */</span></div><div class="line"><span class="comment">// 返回给定链表所包含的节点数量</span></div><div class="line"><span class="comment">// T = O(1)</span></div><div class="line"><span class="selector-id">#define</span> <span class="selector-tag">listLength</span>(l) ((l)-&gt;len)</div><div class="line"><span class="comment">// 返回给定链表的表头节点</span></div><div class="line"><span class="comment">// T = O(1)</span></div><div class="line"><span class="selector-id">#define</span> <span class="selector-tag">listFirst</span>(l) ((l)-&gt;head)</div><div class="line"><span class="comment">// 返回给定链表的表尾节点</span></div><div class="line"><span class="comment">// T = O(1)</span></div><div class="line"><span class="selector-id">#define</span> <span class="selector-tag">listLast</span>(l) ((l)-&gt;tail)</div><div class="line"><span class="comment">// 返回给定节点的前置节点</span></div><div class="line"><span class="comment">// T = O(1)</span></div><div class="line"><span class="selector-id">#define</span> <span class="selector-tag">listPrevNode</span>(n) ((n)-&gt;prev)</div><div class="line"><span class="comment">// 返回给定节点的后置节点</span></div><div class="line"><span class="comment">// T = O(1)</span></div><div class="line"><span class="selector-id">#define</span> <span class="selector-tag">listNextNode</span>(n) ((n)-&gt;next)</div><div class="line"><span class="comment">// 返回给定节点的值</span></div><div class="line"><span class="comment">// T = O(1)</span></div><div class="line"><span class="selector-id">#define</span> <span class="selector-tag">listNodeValue</span>(n) ((n)-&gt;value)</div><div class="line"></div><div class="line"><span class="comment">// 将链表 l 的值复制函数设置为 m</span></div><div class="line"><span class="comment">// T = O(1)</span></div><div class="line"><span class="selector-id">#define</span> <span class="selector-tag">listSetDupMethod</span>(l, m) ((l)-&gt;dup = (m))</div><div class="line"><span class="comment">// 将链表 l 的值释放函数设置为 m</span></div><div class="line"><span class="comment">// T = O(1)</span></div><div class="line"><span class="selector-id">#define</span> <span class="selector-tag">listSetFreeMethod</span>(l, m) ((l)-&gt;free = (m))</div><div class="line"><span class="comment">// 将链表的对比函数设置为 m</span></div><div class="line"><span class="comment">// T = O(1)</span></div><div class="line"><span class="selector-id">#define</span> <span class="selector-tag">listSetMatchMethod</span>(l, m) ((l)-&gt;match = (m))</div><div class="line"></div><div class="line"><span class="comment">// 返回给定链表的值复制函数</span></div><div class="line"><span class="comment">// T = O(1)</span></div><div class="line"><span class="selector-id">#define</span> <span class="selector-tag">listGetDupMethod</span>(l) ((l)-&gt;dup)</div><div class="line"><span class="comment">// 返回给定链表的值释放函数</span></div><div class="line"><span class="comment">// T = O(1)</span></div><div class="line"><span class="selector-id">#define</span> <span class="selector-tag">listGetFree</span>(l) ((l)-&gt;free)</div><div class="line"><span class="comment">// 返回给定链表的值对比函数</span></div><div class="line"><span class="comment">// T = O(1)</span></div><div class="line"><span class="selector-id">#define</span> <span class="selector-tag">listGetMatchMethod</span>(l) ((l)-&gt;match)</div></pre></td></tr></table></figure>
<h1 id="list实现"><a href="#list实现" class="headerlink" title="list实现"></a>list实现</h1><h2 id="创建链表"><a href="#创建链表" class="headerlink" title="创建链表"></a>创建链表</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">list</span> *listCreate(void)</div><div class="line">&#123;</div><div class="line">  struct <span class="keyword">list</span> *<span class="keyword">list</span>;</div><div class="line"></div><div class="line">  <span class="comment">// 分配内存</span></div><div class="line">  <span class="keyword">if</span> ((<span class="keyword">list</span> = zmalloc(sizeof(*<span class="keyword">list</span>))) == <span class="keyword">NULL</span>)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">NULL</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 初始化属性</span></div><div class="line">  <span class="keyword">list</span>-&gt;head = <span class="keyword">list</span>-&gt;tail = <span class="keyword">NULL</span>;</div><div class="line">  <span class="keyword">list</span>-&gt;len = <span class="number">0</span>;</div><div class="line">  <span class="keyword">list</span>-&gt;dup = <span class="keyword">NULL</span>;</div><div class="line">  <span class="keyword">list</span>-&gt;free = <span class="keyword">NULL</span>;</div><div class="line">  <span class="keyword">list</span>-&gt;match = <span class="keyword">NULL</span>;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">list</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="释放链表"><a href="#释放链表" class="headerlink" title="释放链表"></a>释放链表</h2><p>释放链表之中的每一个结点，最后释放list结构体。</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Free the whole list.</span></div><div class="line"> *</div><div class="line"> * This function can't fail. */</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 释放整个链表，以及链表中所有节点</div><div class="line"> *</div><div class="line"> * T = O(N)</div><div class="line"> */</div><div class="line">void listRelease(<span class="keyword">list</span> *<span class="keyword">list</span>)</div><div class="line">&#123;</div><div class="line">  unsigned <span class="keyword">long</span> len;</div><div class="line">  listNode *current, *next;</div><div class="line"></div><div class="line">  <span class="comment">// 指向头指针</span></div><div class="line">  current = <span class="keyword">list</span>-&gt;head;</div><div class="line">  <span class="comment">// 遍历整个链表</span></div><div class="line">  len = <span class="keyword">list</span>-&gt;len;</div><div class="line">  <span class="keyword">while</span> (len--)</div><div class="line">  &#123;</div><div class="line">    next = current-&gt;next;</div><div class="line"></div><div class="line">    <span class="comment">// 如果有设置值释放函数，那么调用它</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">list</span>-&gt;free)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">list</span>-&gt;free(current-&gt;value);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 释放节点结构</span></div><div class="line">    zfree(current);</div><div class="line"></div><div class="line">    current = next;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 释放链表结构</span></div><div class="line">  zfree(<span class="keyword">list</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div><div class="line">287</div><div class="line">288</div><div class="line">289</div><div class="line">290</div><div class="line">291</div><div class="line">292</div><div class="line">293</div><div class="line">294</div><div class="line">295</div><div class="line">296</div><div class="line">297</div><div class="line">298</div><div class="line">299</div><div class="line">300</div><div class="line">301</div><div class="line">302</div><div class="line">303</div><div class="line">304</div><div class="line">305</div><div class="line">306</div><div class="line">307</div><div class="line">308</div><div class="line">309</div><div class="line">310</div><div class="line">311</div><div class="line">312</div><div class="line">313</div><div class="line">314</div><div class="line">315</div><div class="line">316</div><div class="line">317</div><div class="line">318</div><div class="line">319</div><div class="line">320</div><div class="line">321</div><div class="line">322</div><div class="line">323</div><div class="line">324</div><div class="line">325</div><div class="line">326</div><div class="line">327</div><div class="line">328</div><div class="line">329</div><div class="line">330</div><div class="line">331</div><div class="line">332</div><div class="line">333</div><div class="line">334</div><div class="line">335</div><div class="line">336</div><div class="line">337</div><div class="line">338</div><div class="line">339</div><div class="line">340</div><div class="line">341</div><div class="line">342</div><div class="line">343</div><div class="line">344</div><div class="line">345</div><div class="line">346</div><div class="line">347</div><div class="line">348</div><div class="line">349</div><div class="line">350</div><div class="line">351</div><div class="line">352</div><div class="line">353</div><div class="line">354</div><div class="line">355</div><div class="line">356</div><div class="line">357</div><div class="line">358</div><div class="line">359</div><div class="line">360</div><div class="line">361</div><div class="line">362</div><div class="line">363</div><div class="line">364</div><div class="line">365</div><div class="line">366</div><div class="line">367</div><div class="line">368</div><div class="line">369</div><div class="line">370</div><div class="line">371</div><div class="line">372</div><div class="line">373</div><div class="line">374</div><div class="line">375</div><div class="line">376</div><div class="line">377</div><div class="line">378</div><div class="line">379</div><div class="line">380</div><div class="line">381</div><div class="line">382</div><div class="line">383</div><div class="line">384</div><div class="line">385</div><div class="line">386</div><div class="line">387</div><div class="line">388</div><div class="line">389</div><div class="line">390</div><div class="line">391</div><div class="line">392</div><div class="line">393</div><div class="line">394</div><div class="line">395</div><div class="line">396</div><div class="line">397</div><div class="line">398</div><div class="line">399</div><div class="line">400</div><div class="line">401</div><div class="line">402</div><div class="line">403</div><div class="line">404</div><div class="line">405</div><div class="line">406</div><div class="line">407</div><div class="line">408</div><div class="line">409</div><div class="line">410</div><div class="line">411</div><div class="line">412</div><div class="line">413</div><div class="line">414</div><div class="line">415</div><div class="line">416</div><div class="line">417</div><div class="line">418</div><div class="line">419</div><div class="line">420</div><div class="line">421</div><div class="line">422</div><div class="line">423</div><div class="line">424</div><div class="line">425</div><div class="line">426</div><div class="line">427</div><div class="line">428</div><div class="line">429</div><div class="line">430</div><div class="line">431</div><div class="line">432</div><div class="line">433</div><div class="line">434</div><div class="line">435</div><div class="line">436</div><div class="line">437</div><div class="line">438</div><div class="line">439</div><div class="line">440</div><div class="line">441</div><div class="line">442</div><div class="line">443</div><div class="line">444</div><div class="line">445</div><div class="line">446</div><div class="line">447</div><div class="line">448</div><div class="line">449</div><div class="line">450</div><div class="line">451</div><div class="line">452</div><div class="line">453</div><div class="line">454</div><div class="line">455</div><div class="line">456</div><div class="line">457</div><div class="line">458</div><div class="line">459</div><div class="line">460</div><div class="line">461</div><div class="line">462</div><div class="line">463</div><div class="line">464</div><div class="line">465</div><div class="line">466</div><div class="line">467</div><div class="line">468</div><div class="line">469</div><div class="line">470</div><div class="line">471</div><div class="line">472</div><div class="line">473</div><div class="line">474</div><div class="line">475</div><div class="line">476</div><div class="line">477</div><div class="line">478</div><div class="line">479</div><div class="line">480</div><div class="line">481</div><div class="line">482</div><div class="line">483</div><div class="line">484</div><div class="line">485</div><div class="line">486</div><div class="line">487</div><div class="line">488</div><div class="line">489</div><div class="line">490</div><div class="line">491</div><div class="line">492</div><div class="line">493</div><div class="line">494</div><div class="line">495</div><div class="line">496</div><div class="line">497</div><div class="line">498</div><div class="line">499</div><div class="line">500</div><div class="line">501</div><div class="line">502</div><div class="line">503</div><div class="line">504</div><div class="line">505</div><div class="line">506</div><div class="line">507</div><div class="line">508</div><div class="line">509</div><div class="line">510</div><div class="line">511</div><div class="line">512</div><div class="line">513</div><div class="line">514</div><div class="line">515</div><div class="line">516</div><div class="line">517</div><div class="line">518</div><div class="line">519</div><div class="line">520</div><div class="line">521</div><div class="line">522</div><div class="line">523</div><div class="line">524</div><div class="line">525</div><div class="line">526</div><div class="line">527</div><div class="line">528</div><div class="line">529</div><div class="line">530</div><div class="line">531</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Add a new node to the list, to head, contaning the specified 'value'</span></div><div class="line"> * pointer as value.</div><div class="line"> *</div><div class="line"> * On error, NULL is returned and no operation is performed (i.e. the</div><div class="line"> * list remains unaltered).</div><div class="line"> * On success the 'list' pointer you pass to the function is returned. */</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 将一个包含有给定值指针 value 的新节点添加到链表的表头</div><div class="line"> *</div><div class="line"> * 如果为新节点分配内存出错，那么不执行任何动作，仅返回 NULL</div><div class="line"> *</div><div class="line"> * 如果执行成功，返回传入的链表指针</div><div class="line"> *</div><div class="line"> * T = O(1)</div><div class="line"> */</div><div class="line"><span class="keyword">list</span> *listAddNodeHead(<span class="keyword">list</span> *<span class="keyword">list</span>, void *value)</div><div class="line">&#123;</div><div class="line">  listNode *node;</div><div class="line"></div><div class="line">  <span class="comment">// 为节点分配内存</span></div><div class="line">  <span class="keyword">if</span> ((node = zmalloc(sizeof(*node))) == <span class="keyword">NULL</span>)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">NULL</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 保存值指针</span></div><div class="line">  node-&gt;value = value;</div><div class="line"></div><div class="line">  <span class="comment">// 添加节点到空链表</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">list</span>-&gt;len == <span class="number">0</span>)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">list</span>-&gt;head = <span class="keyword">list</span>-&gt;tail = node;</div><div class="line">    node-&gt;prev = node-&gt;next = <span class="keyword">NULL</span>;</div><div class="line">    <span class="comment">// 添加节点到非空链表</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">  &#123;</div><div class="line">    node-&gt;prev = <span class="keyword">NULL</span>;</div><div class="line">    node-&gt;next = <span class="keyword">list</span>-&gt;head;</div><div class="line">    <span class="keyword">list</span>-&gt;head-&gt;prev = node;</div><div class="line">    <span class="keyword">list</span>-&gt;head = node;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 更新链表节点数</span></div><div class="line">  <span class="keyword">list</span>-&gt;len++;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">list</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Add a new node to the list, to tail, containing the specified 'value'</span></div><div class="line"> * pointer as value.</div><div class="line"> *</div><div class="line"> * On error, NULL is returned and no operation is performed (i.e. the</div><div class="line"> * list remains unaltered).</div><div class="line"> * On success the 'list' pointer you pass to the function is returned. */</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 将一个包含有给定值指针 value 的新节点添加到链表的表尾</div><div class="line"> *</div><div class="line"> * 如果为新节点分配内存出错，那么不执行任何动作，仅返回 NULL</div><div class="line"> *</div><div class="line"> * 如果执行成功，返回传入的链表指针</div><div class="line"> *</div><div class="line"> * T = O(1)</div><div class="line"> */</div><div class="line"><span class="keyword">list</span> *listAddNodeTail(<span class="keyword">list</span> *<span class="keyword">list</span>, void *value)</div><div class="line">&#123;</div><div class="line">  listNode *node;</div><div class="line"></div><div class="line">  <span class="comment">// 为新节点分配内存</span></div><div class="line">  <span class="keyword">if</span> ((node = zmalloc(sizeof(*node))) == <span class="keyword">NULL</span>)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">NULL</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 保存值指针</span></div><div class="line">  node-&gt;value = value;</div><div class="line"></div><div class="line">  <span class="comment">// 目标链表为空</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">list</span>-&gt;len == <span class="number">0</span>)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">list</span>-&gt;head = <span class="keyword">list</span>-&gt;tail = node;</div><div class="line">    node-&gt;prev = node-&gt;next = <span class="keyword">NULL</span>;</div><div class="line">    <span class="comment">// 目标链表非空</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">  &#123;</div><div class="line">    node-&gt;prev = <span class="keyword">list</span>-&gt;tail;</div><div class="line">    node-&gt;next = <span class="keyword">NULL</span>;</div><div class="line">    <span class="keyword">list</span>-&gt;tail-&gt;next = node;</div><div class="line">    <span class="keyword">list</span>-&gt;tail = node;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 更新链表节点数</span></div><div class="line">  <span class="keyword">list</span>-&gt;len++;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">list</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 创建一个包含值 value 的新节点，并将它插入到 old_node 的之前或之后</div><div class="line"> *</div><div class="line"> * 如果 after 为 0 ，将新节点插入到 old_node 之前。</div><div class="line"> * 如果 after 为 1 ，将新节点插入到 old_node 之后。</div><div class="line"> *</div><div class="line"> * T = O(1)</div><div class="line"> */</div><div class="line"><span class="keyword">list</span> *listInsertNode(<span class="keyword">list</span> *<span class="keyword">list</span>, listNode *old_node, void *value, <span class="keyword">int</span> after)</div><div class="line">&#123;</div><div class="line">  listNode *node;</div><div class="line"></div><div class="line">  <span class="comment">// 创建新节点</span></div><div class="line">  <span class="keyword">if</span> ((node = zmalloc(sizeof(*node))) == <span class="keyword">NULL</span>)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">NULL</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 保存值</span></div><div class="line">  node-&gt;value = value;</div><div class="line"></div><div class="line">  <span class="comment">// 将新节点添加到给定节点之后</span></div><div class="line">  <span class="keyword">if</span> (after)</div><div class="line">  &#123;</div><div class="line">    node-&gt;prev = old_node;</div><div class="line">    node-&gt;next = old_node-&gt;next;</div><div class="line">    <span class="comment">// 给定节点是原表尾节点</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">list</span>-&gt;tail == old_node)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">list</span>-&gt;tail = node;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 将新节点添加到给定节点之前</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">  &#123;</div><div class="line">    node-&gt;next = old_node;</div><div class="line">    node-&gt;prev = old_node-&gt;prev;</div><div class="line">    <span class="comment">// 给定节点是原表头节点</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">list</span>-&gt;head == old_node)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">list</span>-&gt;head = node;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 更新新节点的前置指针</span></div><div class="line">  <span class="keyword">if</span> (node-&gt;prev != <span class="keyword">NULL</span>)</div><div class="line">  &#123;</div><div class="line">    node-&gt;prev-&gt;next = node;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 更新新节点的后置指针</span></div><div class="line">  <span class="keyword">if</span> (node-&gt;next != <span class="keyword">NULL</span>)</div><div class="line">  &#123;</div><div class="line">    node-&gt;next-&gt;prev = node;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 更新链表节点数</span></div><div class="line">  <span class="keyword">list</span>-&gt;len++;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">list</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Remove the specified node from the specified list.</span></div><div class="line"> * It's up to the caller to free the private value of the node.</div><div class="line"> *</div><div class="line"> * This function can't fail. */</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 从链表 list 中删除给定节点 node </div><div class="line"> * </div><div class="line"> * 对节点私有值(private value of the node)的释放工作由调用者进行。</div><div class="line"> *</div><div class="line"> * T = O(1)</div><div class="line"> */</div><div class="line">void listDelNode(<span class="keyword">list</span> *<span class="keyword">list</span>, listNode *node)</div><div class="line">&#123;</div><div class="line">  <span class="comment">// 调整前置节点的指针</span></div><div class="line">  <span class="keyword">if</span> (node-&gt;prev)</div><div class="line">  &#123;</div><div class="line">    node-&gt;prev-&gt;next = node-&gt;next;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">  &#123;</div><div class="line">    <span class="keyword">list</span>-&gt;head = node-&gt;next;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 调整后置节点的指针</span></div><div class="line">  <span class="keyword">if</span> (node-&gt;next)</div><div class="line">  &#123;</div><div class="line">    node-&gt;next-&gt;prev = node-&gt;prev;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">  &#123;</div><div class="line">    <span class="keyword">list</span>-&gt;tail = node-&gt;prev;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 释放值</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">list</span>-&gt;free)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">list</span>-&gt;free(node-&gt;value);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 释放节点</span></div><div class="line">  zfree(node);</div><div class="line"></div><div class="line">  <span class="comment">// 链表数减一</span></div><div class="line">  <span class="keyword">list</span>-&gt;len--;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Returns a list iterator 'iter'. After the initialization every</span></div><div class="line"> * call to listNext() will return the next element of the list.</div><div class="line"> *</div><div class="line"> * This function can't fail. */</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 为给定链表创建一个迭代器，</div><div class="line"> * 之后每次对这个迭代器调用 listNext 都返回被迭代到的链表节点</div><div class="line"> *</div><div class="line"> * direction 参数决定了迭代器的迭代方向：</div><div class="line"> *  AL_START_HEAD ：从表头向表尾迭代</div><div class="line"> *  AL_START_TAIL ：从表尾想表头迭代</div><div class="line"> *</div><div class="line"> * T = O(1)</div><div class="line"> */</div><div class="line">listIter *listGetIterator(<span class="keyword">list</span> *<span class="keyword">list</span>, <span class="keyword">int</span> direction)</div><div class="line">&#123;</div><div class="line">  <span class="comment">// 为迭代器分配内存</span></div><div class="line">  listIter *iter;</div><div class="line">  <span class="keyword">if</span> ((iter = zmalloc(sizeof(*iter))) == <span class="keyword">NULL</span>)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">NULL</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 根据迭代方向，设置迭代器的起始节点</span></div><div class="line">  <span class="keyword">if</span> (direction == AL_START_HEAD)</div><div class="line">  &#123;</div><div class="line">    iter-&gt;next = <span class="keyword">list</span>-&gt;head;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">  &#123;</div><div class="line">    iter-&gt;next = <span class="keyword">list</span>-&gt;tail;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 记录迭代方向</span></div><div class="line">  iter-&gt;direction = direction;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> iter;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Release the iterator memory */</span></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 释放迭代器</div><div class="line"> *</div><div class="line"> * T = O(1)</div><div class="line"> */</div><div class="line">void listReleaseIterator(listIter *iter)</div><div class="line">&#123;</div><div class="line">  zfree(iter);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Create an iterator in the list private iterator structure */</span></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 将迭代器的方向设置为 AL_START_HEAD ，</div><div class="line"> * 并将迭代指针重新指向表头节点。</div><div class="line"> *</div><div class="line"> * T = O(1)</div><div class="line"> */</div><div class="line">void listRewind(<span class="keyword">list</span> *<span class="keyword">list</span>, listIter *li)</div><div class="line">&#123;</div><div class="line">  li-&gt;next = <span class="keyword">list</span>-&gt;head;</div><div class="line">  li-&gt;direction = AL_START_HEAD;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 将迭代器的方向设置为 AL_START_TAIL ，</div><div class="line"> * 并将迭代指针重新指向表尾节点。</div><div class="line"> *</div><div class="line"> * T = O(1)</div><div class="line"> */</div><div class="line">void listRewindTail(<span class="keyword">list</span> *<span class="keyword">list</span>, listIter *li)</div><div class="line">&#123;</div><div class="line">  li-&gt;next = <span class="keyword">list</span>-&gt;tail;</div><div class="line">  li-&gt;direction = AL_START_TAIL;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Return the next element of an iterator.</span></div><div class="line"> * It's valid to remove the currently returned element using</div><div class="line"> * listDelNode(), but not to remove other elements.</div><div class="line"> *</div><div class="line"> * The function returns a pointer to the next element of the list,</div><div class="line"> * or NULL if there are no more elements, so the classical usage patter</div><div class="line"> * is:</div><div class="line"> *</div><div class="line"> * iter = listGetIterator(list,&lt;direction&gt;);</div><div class="line"> * while ((node = listNext(iter)) != NULL) &#123;</div><div class="line"> *     doSomethingWith(listNodeValue(node));</div><div class="line"> * &#125;</div><div class="line"> *</div><div class="line"> * */</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 返回迭代器当前所指向的节点。</div><div class="line"> *</div><div class="line"> * 删除当前节点是允许的，但不能修改链表里的其他节点。</div><div class="line"> *</div><div class="line"> * 函数要么返回一个节点，要么返回 NULL ，常见的用法是：</div><div class="line"> *</div><div class="line"> * iter = listGetIterator(list,&lt;direction&gt;);</div><div class="line"> * while ((node = listNext(iter)) != NULL) &#123;</div><div class="line"> *     doSomethingWith(listNodeValue(node));</div><div class="line"> * &#125;</div><div class="line"> *</div><div class="line"> * T = O(1)</div><div class="line"> */</div><div class="line">listNode *listNext(listIter *iter)</div><div class="line">&#123;</div><div class="line">  listNode *current = iter-&gt;next;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (current != <span class="keyword">NULL</span>)</div><div class="line">  &#123;</div><div class="line">    <span class="comment">// 根据方向选择下一个节点</span></div><div class="line">    <span class="keyword">if</span> (iter-&gt;direction == AL_START_HEAD)</div><div class="line">    &#123;</div><div class="line">      <span class="comment">// 保存下一个节点，防止当前节点被删除而造成指针丢失</span></div><div class="line">      iter-&gt;next = current-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">      <span class="comment">// 保存下一个节点，防止当前节点被删除而造成指针丢失</span></div><div class="line">      iter-&gt;next = current-&gt;prev;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> current;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Duplicate the whole list. On out of memory NULL is returned.</span></div><div class="line"> * On success a copy of the original list is returned.</div><div class="line"> *</div><div class="line"> * The 'Dup' method set with listSetDupMethod() function is used</div><div class="line"> * to copy the node value. Otherwise the same pointer value of</div><div class="line"> * the original node is used as value of the copied node.</div><div class="line"> *</div><div class="line"> * The original list both on success or error is never modified. */</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 复制整个链表。</div><div class="line"> *</div><div class="line"> * 复制成功返回输入链表的副本，</div><div class="line"> * 如果因为内存不足而造成复制失败，返回 NULL 。</div><div class="line"> *</div><div class="line"> * 如果链表有设置值复制函数 dup ，那么对值的复制将使用复制函数进行，</div><div class="line"> * 否则，新节点将和旧节点共享同一个指针。</div><div class="line"> *</div><div class="line"> * 无论复制是成功还是失败，输入节点都不会修改。</div><div class="line"> *</div><div class="line"> * T = O(N)</div><div class="line"> */</div><div class="line"><span class="keyword">list</span> *listDup(<span class="keyword">list</span> *orig)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">list</span> *copy;</div><div class="line">  listIter *iter;</div><div class="line">  listNode *node;</div><div class="line"></div><div class="line">  <span class="comment">// 创建新链表</span></div><div class="line">  <span class="keyword">if</span> ((copy = listCreate()) == <span class="keyword">NULL</span>)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">NULL</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 设置节点值处理函数</span></div><div class="line">  copy-&gt;dup = orig-&gt;dup;</div><div class="line">  copy-&gt;free = orig-&gt;free;</div><div class="line">  copy-&gt;match = orig-&gt;match;</div><div class="line"></div><div class="line">  <span class="comment">// 迭代整个输入链表</span></div><div class="line">  iter = listGetIterator(orig, AL_START_HEAD);</div><div class="line">  <span class="keyword">while</span> ((node = listNext(iter)) != <span class="keyword">NULL</span>)</div><div class="line">  &#123;</div><div class="line">    void *value;</div><div class="line"></div><div class="line">    <span class="comment">// 复制节点值到新节点</span></div><div class="line">    <span class="keyword">if</span> (copy-&gt;dup)</div><div class="line">    &#123;</div><div class="line">      value = copy-&gt;dup(node-&gt;value);</div><div class="line">      <span class="keyword">if</span> (value == <span class="keyword">NULL</span>)</div><div class="line">      &#123;</div><div class="line">        listRelease(copy);</div><div class="line">        listReleaseIterator(iter);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">NULL</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">      value = node-&gt;value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 将节点添加到链表</span></div><div class="line">    <span class="keyword">if</span> (listAddNodeTail(copy, value) == <span class="keyword">NULL</span>)</div><div class="line">    &#123;</div><div class="line">      listRelease(copy);</div><div class="line">      listReleaseIterator(iter);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">NULL</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 释放迭代器</span></div><div class="line">  listReleaseIterator(iter);</div><div class="line"></div><div class="line">  <span class="comment">// 返回副本</span></div><div class="line">  <span class="keyword">return</span> copy;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Search the list for a node matching a given key.</span></div><div class="line"> * The match is performed using the 'match' method</div><div class="line"> * set with listSetMatchMethod(). If no 'match' method</div><div class="line"> * is set, the 'value' pointer of every node is directly</div><div class="line"> * compared with the 'key' pointer.</div><div class="line"> *</div><div class="line"> * On success the first matching node pointer is returned</div><div class="line"> * (search starts from head). If no matching node exists</div><div class="line"> * NULL is returned. */</div><div class="line"><span class="comment">/* </span></div><div class="line"> * 查找链表 list 中值和 key 匹配的节点。</div><div class="line"> * </div><div class="line"> * 对比操作由链表的 match 函数负责进行，</div><div class="line"> * 如果没有设置 match 函数，</div><div class="line"> * 那么直接通过对比值的指针来决定是否匹配。</div><div class="line"> *</div><div class="line"> * 如果匹配成功，那么第一个匹配的节点会被返回。</div><div class="line"> * 如果没有匹配任何节点，那么返回 NULL 。</div><div class="line"> *</div><div class="line"> * T = O(N)</div><div class="line"> */</div><div class="line">listNode *listSearchKey(<span class="keyword">list</span> *<span class="keyword">list</span>, void *key)</div><div class="line">&#123;</div><div class="line">  listIter *iter;</div><div class="line">  listNode *node;</div><div class="line"></div><div class="line">  <span class="comment">// 迭代整个链表</span></div><div class="line">  iter = listGetIterator(<span class="keyword">list</span>, AL_START_HEAD);</div><div class="line">  <span class="keyword">while</span> ((node = listNext(iter)) != <span class="keyword">NULL</span>)</div><div class="line">  &#123;</div><div class="line"></div><div class="line">    <span class="comment">// 对比</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">list</span>-&gt;match)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">list</span>-&gt;match(node-&gt;value, key))</div><div class="line">      &#123;</div><div class="line">        listReleaseIterator(iter);</div><div class="line">        <span class="comment">// 找到</span></div><div class="line">        <span class="keyword">return</span> node;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">      <span class="keyword">if</span> (key == node-&gt;value)</div><div class="line">      &#123;</div><div class="line">        listReleaseIterator(iter);</div><div class="line">        <span class="comment">// 找到</span></div><div class="line">        <span class="keyword">return</span> node;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  listReleaseIterator(iter);</div><div class="line"></div><div class="line">  <span class="comment">// 未找到</span></div><div class="line">  <span class="keyword">return</span> <span class="keyword">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Return the element at the specified zero-based index</span></div><div class="line"> * where 0 is the head, 1 is the element next to head</div><div class="line"> * and so on. Negative integers are used in order to count</div><div class="line"> * from the tail, -1 is the last element, -2 the penultimate</div><div class="line"> * and so on. If the index is out of range NULL is returned. */</div><div class="line"><span class="comment">/*</span></div><div class="line"> * 返回链表在给定索引上的值。</div><div class="line"> *</div><div class="line"> * 索引以 0 为起始，也可以是负数， -1 表示链表最后一个节点，诸如此类。</div><div class="line"> *</div><div class="line"> * 如果索引超出范围（out of range），返回 NULL 。</div><div class="line"> *</div><div class="line"> * T = O(N)</div><div class="line"> */</div><div class="line">listNode *listIndex(<span class="keyword">list</span> *<span class="keyword">list</span>, <span class="keyword">long</span> index)</div><div class="line">&#123;</div><div class="line">  listNode *n;</div><div class="line"></div><div class="line">  <span class="comment">// 如果索引为负数，从表尾开始查找</span></div><div class="line">  <span class="keyword">if</span> (index &lt; <span class="number">0</span>)</div><div class="line">  &#123;</div><div class="line">    index = (-index) - <span class="number">1</span>;</div><div class="line">    n = <span class="keyword">list</span>-&gt;tail;</div><div class="line">    <span class="keyword">while</span> (index-- &amp;&amp; n)</div><div class="line">    &#123;</div><div class="line">      n = n-&gt;prev;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 如果索引为正数，从表头开始查找</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">  &#123;</div><div class="line">    n = <span class="keyword">list</span>-&gt;head;</div><div class="line">    <span class="keyword">while</span> (index-- &amp;&amp; n)</div><div class="line">    &#123;</div><div class="line">      n = n-&gt;next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> n;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/* Rotate the list removing the tail node and inserting it to the head. */</span></div><div class="line"><span class="comment">/*</span></div><div class="line"> * 取出链表的表尾节点，并将它移动到表头，成为新的表头节点。</div><div class="line"> *</div><div class="line"> * T = O(1)</div><div class="line"> */</div><div class="line">void listRotate(<span class="keyword">list</span> *<span class="keyword">list</span>)</div><div class="line">&#123;</div><div class="line">  listNode *tail = <span class="keyword">list</span>-&gt;tail;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (listLength(<span class="keyword">list</span>) &lt;= <span class="number">1</span>)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* Detach current tail */</span></div><div class="line">  <span class="comment">// 取出表尾节点</span></div><div class="line">  <span class="keyword">list</span>-&gt;tail = tail-&gt;prev;</div><div class="line">  <span class="keyword">list</span>-&gt;tail-&gt;next = <span class="keyword">NULL</span>;</div><div class="line"></div><div class="line">  <span class="comment">/* Move it as head */</span></div><div class="line">  <span class="comment">// 插入到表头</span></div><div class="line">  <span class="keyword">list</span>-&gt;head-&gt;prev = tail;</div><div class="line">  tail-&gt;prev = <span class="keyword">NULL</span>;</div><div class="line">  tail-&gt;next = <span class="keyword">list</span>-&gt;head;</div><div class="line">  <span class="keyword">list</span>-&gt;head = tail;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> redis </category>
            
        </categories>
        
        
        <tags>
            
            <tag> redis </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[muduo EventLoopThread相关]]></title>
      <url>/2017/06/24/muduo-EventLoopThread%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<h1 id="EventLoopThread分析"><a href="#EventLoopThread分析" class="headerlink" title="EventLoopThread分析"></a>EventLoopThread分析</h1><p>比较好的服务器模型是采用继续one loop in one thread的方式。并且最好设置EventLoop的数目最好不要超过cpu的核数，这样减少线程之间的对于cpu的争用。</p>
<p>EventLoop的用途是新建一个线程，在此线程上初始化EventLoop对象，启动事件循环，并且返回新建的事件循环。其具体实现可以类比为使用count设为1的CountDownLatch来完成。为了新建在新的线程上的事件循环采用下述方式：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">EventLoop</span>* <span class="selector-tag">EventLoopThread</span><span class="selector-pseudo">::startLoop()</span></div><div class="line">&#123;</div><div class="line">  <span class="selector-tag">assert</span>(!thread_.started());</div><div class="line">  <span class="selector-tag">thread_</span><span class="selector-class">.start</span>();</div><div class="line"></div><div class="line">  &#123;</div><div class="line">    <span class="selector-tag">MutexLockGuard</span> <span class="selector-tag">lock</span>(mutex_);</div><div class="line">    <span class="selector-tag">while</span> (loop_ == NULL)</div><div class="line">    &#123;</div><div class="line">      <span class="selector-tag">cond_</span><span class="selector-class">.wait</span>();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="selector-tag">return</span> <span class="selector-tag">loop_</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>thread在启动时会调用如下函数，新建并且启动EventLoop。创建EventLoop完成之后，会使用notify通知调用startLoop的线程，新的EventLoop已经就绪。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="literal">void</span> EventLoopThread<span class="type">::threadFunc</span>()</div><div class="line">&#123;</div><div class="line">  EventLoop <span class="keyword">loop</span>;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (callback_)</div><div class="line">  &#123;</div><div class="line">    callback_(&amp;<span class="keyword">loop</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  &#123;</div><div class="line">    MutexLockGuard lock(mutex_);</div><div class="line">    loop_ = &amp;<span class="keyword">loop</span>;</div><div class="line">    cond_.notify();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">loop</span>.<span class="keyword">loop</span>();</div><div class="line">  <span class="comment">//assert(exiting_);</span></div><div class="line">  loop_ = <span class="built_in">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="EventLoopThreadPool"><a href="#EventLoopThreadPool" class="headerlink" title="EventLoopThreadPool"></a>EventLoopThreadPool</h1><p>用途：创建一个EventLoop pool, 创建给定数目的线程，每个线程之上新建一个EventLoop对象并且启动事件循环。</p>
<p>其关键方法是getNextLoop, 他会采用round robin方式，每次返回下一个可用的事件循环。若pool不为空，只返回pool之中的事件循环，否则返回<code>baseLoop_</code>。这一做法在于后面TcpServer之中，只使用<code>baseLoop_</code>来处理连接建立，使用pool之中的线程用来处理和客户端的io事件。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">EventLoop* EventLoopThreadPool::getNextLoop()</div><div class="line">&#123;</div><div class="line">  baseLoop<span class="number">_</span>-&gt;assertInLoopThread();</div><div class="line">  assert(started<span class="number">_</span>);</div><div class="line">  EventLoop* loop = baseLoop<span class="number">_</span>;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!loops<span class="number">_</span>.empty())</div><div class="line">  &#123;</div><div class="line">    <span class="regexp">//</span> round-robin</div><div class="line">    loop = loops<span class="number">_</span>[<span class="keyword">next</span><span class="number">_</span>];</div><div class="line">    ++<span class="keyword">next</span><span class="number">_</span>;</div><div class="line">    <span class="keyword">if</span> (implicit_cast&lt;size_t&gt;(<span class="keyword">next</span><span class="number">_</span>) &gt;= loops<span class="number">_</span>.size())</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">next</span><span class="number">_</span> = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> loop;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> muduo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> muduo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[muduo EventLoop解析]]></title>
      <url>/2017/06/24/muduo-EventLoop%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="线程安全回调"><a href="#线程安全回调" class="headerlink" title="线程安全回调"></a>线程安全回调</h1><p>在很多情况下，需要将函数操作转移到io线程之中进行，muduo EventLoop支持queueInLoop 和 runInLoop 调用，视调用线程情况，将回调函数暂时存放在vector之中，在时间循环的末尾统一进行调用处理。</p>
<p>为了保证输入的回调函数能够尽快完成，不然这些回调函数可能需要等到poller超时返回之后才能得以运行。muduo在事件循环中使用了eventFd，对于可能阻塞在Poller的情况，会向eventFd写入1，触发Poller调用返回，从而使回调函数得以执行。</p>
<p>当然，可能在其他线程之中调用queueInLoop函数，为了线程安全，存入新的回调函数的时候需要进行加锁处理。</p>
<h1 id="定时回调实现"><a href="#定时回调实现" class="headerlink" title="定时回调实现"></a>定时回调实现</h1><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>在muduo之中，对于定时回调的实现主要代码在<code>TimerQueue.cc</code> 以及<code>TimerQueue.h</code>之中。其核心思路是使用timerFd。timerFd用于通知事件循环最近一次的超时事件发生了，然后在对timerFd包装的channel的read回调函数之中，会对所有当前超时所对应的回调函数，一一调用。对于需要反复设置的定时器，也做好处理，保证timerFd能在合适的时间触发可读事件。</p>
<h2 id="新增回调函数"><a href="#新增回调函数" class="headerlink" title="新增回调函数"></a>新增回调函数</h2><p>为了方便的拿到最近一个超时的时刻，并且应对多个回调函数对应一个超时条件的情况，在muduo之中使用set存放他所管理的时间回调函数，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::pair&lt;Timestamp, Timer*&gt; Entry;</div><div class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">set</span>&lt;Entry&gt; TimerList;</div><div class="line">TimerList timers_;</div></pre></td></tr></table></figure>
<p>如果要新增回调函数，首先将其插入到timers_之中，如果发现在加入新的定时回调之后，最早超时的时刻有变，那么重新设置timerFd，保证新增的回调函数能在准确的时间被调用。</p>
<h2 id="cancel定时回调"><a href="#cancel定时回调" class="headerlink" title="cancel定时回调"></a>cancel定时回调</h2><p>如果当前事件循环正在调用定时回调函数，那么在此期间不可cancel定时回调，否则会引发未定义行为。我们只需要做好记录，确保要cancel的回调函数不会被重新设置。相反，若事件循环当前没有调用超时回调函数，那么直接将对应的定时回调从对应的数据结构之中删除即可。</p>
<p>这里的问题在于，如果在正在调用定时回调函数的时候来cancel，可能会造成cancel失败，这里的cancel并不是强保证。但是cancel之后，总能保证在后续reset处理之后不会再调用cancel的定时回调函数。</p>
<h1 id="boost-any"><a href="#boost-any" class="headerlink" title="boost::any"></a>boost::any</h1><p>有时候需要在不同线程的EventLoop之中记录一些EventLoop相关的信息，和muduo::TcpConnection一样，这里使用了boost::any.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">setContext</span><span class="params">(<span class="keyword">const</span> boost::any&amp; context)</span></span></div><div class="line">&#123; context_ = context; &#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> boost::<span class="function">any&amp; <span class="title">getContext</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line">&#123; <span class="keyword">return</span> context_; &#125;</div><div class="line"></div><div class="line">boost::<span class="function">any* <span class="title">getMutableContext</span><span class="params">()</span></span></div><div class="line">&#123; <span class="keyword">return</span> &amp;context_; &#125;</div><div class="line"></div><div class="line">boost::any context_;</div></pre></td></tr></table></figure>
<h1 id="一些转调用"><a href="#一些转调用" class="headerlink" title="一些转调用"></a>一些转调用</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateChannel</span><span class="params">(Channel* channel)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeChannel</span><span class="params">(Channel* channel)</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">hasChannel</span><span class="params">(Channel* channel)</span></span>;</div><div class="line"><span class="comment">// 转调用Poller之中的定义</span></div><div class="line">其调用流程是Channel -&gt; EventLoop -&gt; Poller</div></pre></td></tr></table></figure>
<h1 id="loop分析"><a href="#loop分析" class="headerlink" title="loop分析"></a>loop分析</h1><p>事件循环的退出很简单，一旦<code>quit_</code>为false，那么循环便无法继续。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> <span class="string">EventLoop:</span>:loop()</div><div class="line">&#123;</div><div class="line">  <span class="keyword">assert</span>(!looping_);</div><div class="line">  assertInLoopThread();</div><div class="line">  looping_ = <span class="literal">true</span>;</div><div class="line">  quit_ = <span class="literal">false</span>;  <span class="comment">// <span class="doctag">FIXME:</span> what if someone calls quit() before loop() ?</span></div><div class="line">  LOG_TRACE &lt;&lt; <span class="string">"EventLoop "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">" start looping"</span>;</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (!quit_)</div><div class="line">  &#123;</div><div class="line">    activeChannels_.clear();</div><div class="line">    pollReturnTime_ = poller_-&gt;poll(kPollTimeMs, &amp;activeChannels_);</div><div class="line">    ++iteration_;</div><div class="line">    <span class="keyword">if</span> (<span class="string">Logger:</span>:logLevel() &lt;= <span class="string">Logger:</span>:TRACE)</div><div class="line">    &#123;</div><div class="line">      printActiveChannels();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// TODO sort channel by priority</span></div><div class="line">    eventHandling_ = <span class="literal">true</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="string">ChannelList:</span>:iterator it = activeChannels_.begin();</div><div class="line">        it != activeChannels_.end(); ++it)</div><div class="line">    &#123;</div><div class="line">      currentActiveChannel_ = *it;</div><div class="line">      currentActiveChannel_-&gt;handleEvent(pollReturnTime_);</div><div class="line">    &#125;</div><div class="line">    currentActiveChannel_ = NULL;</div><div class="line">    eventHandling_ = <span class="literal">false</span>;</div><div class="line">    doPendingFunctors();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  LOG_TRACE &lt;&lt; <span class="string">"EventLoop "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">" stop looping"</span>;</div><div class="line">  looping_ = <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>事件循环之中主要做两件事，调用poller获取当前的activeChannel, 然后调用这些channel的回调函数。接着处理之前从外面调入的为了保证线程安全需要在io线程之中调用的回调函数。此过程循环进行，直到显示调用quit退出事件循环。</p>
]]></content>
      
        <categories>
            
            <category> muduo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> muduo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[muduo InetAddress]]></title>
      <url>/2017/06/24/muduo-InetAddress/</url>
      <content type="html"><![CDATA[<h1 id="功能解析"><a href="#功能解析" class="headerlink" title="功能解析"></a>功能解析</h1><p>这是一个简单的对sockfd的wrapper类，主要借助C++的RAII机制实现sockfd的自动管理。当Socket对象被析构的时候会自动关闭sockfd。</p>
<h1 id="重点函数"><a href="#重点函数" class="headerlink" title="重点函数"></a>重点函数</h1><p>可以适当关注一下以下方法，特别是对于tcp信息的获取，设置<code>TCP_NODELAY，SO_REUSEADDR，SO_REUSEPORT，SO_KEEPALIVE</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> Socket::getTcpInfo(struct tcp_info* tcpi) <span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(*tcpi);</div><div class="line">  bzero(tcpi, len);</div><div class="line">  <span class="keyword">return</span> ::getsockopt(sockfd_, SOL_TCP, TCP_INFO, tcpi, &amp;len) == <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">bool</span> Socket::getTcpInfoString(<span class="keyword">char</span>* buf, <span class="keyword">int</span> len) <span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_info</span> <span class="title">tcpi</span>;</span></div><div class="line">  <span class="keyword">bool</span> ok = getTcpInfo(&amp;tcpi);</div><div class="line">  <span class="keyword">if</span> (ok)</div><div class="line">  &#123;</div><div class="line">    <span class="built_in">snprintf</span>(buf, len, <span class="string">"unrecovered=%u "</span></div><div class="line">             <span class="string">"rto=%u ato=%u snd_mss=%u rcv_mss=%u "</span></div><div class="line">             <span class="string">"lost=%u retrans=%u rtt=%u rttvar=%u "</span></div><div class="line">             <span class="string">"sshthresh=%u cwnd=%u total_retrans=%u"</span>,</div><div class="line">             tcpi.tcpi_retransmits,  <span class="comment">// Number of unrecovered [RTO] timeouts</span></div><div class="line">             tcpi.tcpi_rto,          <span class="comment">// Retransmit timeout in usec</span></div><div class="line">             tcpi.tcpi_ato,          <span class="comment">// Predicted tick of soft clock in usec</span></div><div class="line">             tcpi.tcpi_snd_mss,</div><div class="line">             tcpi.tcpi_rcv_mss,</div><div class="line">             tcpi.tcpi_lost,         <span class="comment">// Lost packets</span></div><div class="line">             tcpi.tcpi_retrans,      <span class="comment">// Retransmitted packets out</span></div><div class="line">             tcpi.tcpi_rtt,          <span class="comment">// Smoothed round trip time in usec</span></div><div class="line">             tcpi.tcpi_rttvar,       <span class="comment">// Medium deviation</span></div><div class="line">             tcpi.tcpi_snd_ssthresh,</div><div class="line">             tcpi.tcpi_snd_cwnd,</div><div class="line">             tcpi.tcpi_total_retrans);  <span class="comment">// Total retransmits for entire connection</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> ok;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> Socket::bindAddress(<span class="keyword">const</span> InetAddress&amp; addr)</div><div class="line">&#123;</div><div class="line">  sockets::bindOrDie(sockfd_, addr.getSockAddr());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> Socket::listen()</div><div class="line">&#123;</div><div class="line">  sockets::listenOrDie(sockfd_);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> Socket::accept(InetAddress* peeraddr)</div><div class="line">&#123;</div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> <span class="title">addr</span>;</span></div><div class="line">  bzero(&amp;addr, <span class="keyword">sizeof</span> addr);</div><div class="line">  <span class="keyword">int</span> connfd = sockets::accept(sockfd_, &amp;addr);</div><div class="line">  <span class="keyword">if</span> (connfd &gt;= <span class="number">0</span>)</div><div class="line">  &#123;</div><div class="line">    peeraddr-&gt;setSockAddrInet6(addr);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> connfd;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> Socket::shutdownWrite()</div><div class="line">&#123;</div><div class="line">  sockets::shutdownWrite(sockfd_);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> Socket::setTcpNoDelay(<span class="keyword">bool</span> on)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> optval = on ? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line">  ::setsockopt(sockfd_, IPPROTO_TCP, TCP_NODELAY,</div><div class="line">               &amp;optval, <span class="keyword">static_cast</span>&lt;<span class="keyword">socklen_t</span>&gt;(<span class="keyword">sizeof</span> optval));</div><div class="line">  <span class="comment">// FIXME CHECK</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> Socket::setReuseAddr(<span class="keyword">bool</span> on)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> optval = on ? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line">  ::setsockopt(sockfd_, SOL_SOCKET, SO_REUSEADDR,</div><div class="line">               &amp;optval, <span class="keyword">static_cast</span>&lt;<span class="keyword">socklen_t</span>&gt;(<span class="keyword">sizeof</span> optval));</div><div class="line">  <span class="comment">// FIXME CHECK</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> Socket::setReusePort(<span class="keyword">bool</span> on)</div><div class="line">&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SO_REUSEPORT</span></div><div class="line">  <span class="keyword">int</span> optval = on ? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> ret = ::setsockopt(sockfd_, SOL_SOCKET, SO_REUSEPORT,</div><div class="line">                         &amp;optval, <span class="keyword">static_cast</span>&lt;<span class="keyword">socklen_t</span>&gt;(<span class="keyword">sizeof</span> optval));</div><div class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; on)</div><div class="line">  &#123;</div><div class="line">    LOG_SYSERR &lt;&lt; <span class="string">"SO_REUSEPORT failed."</span>;</div><div class="line">  &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">  <span class="keyword">if</span> (on)</div><div class="line">  &#123;</div><div class="line">    LOG_ERROR &lt;&lt; <span class="string">"SO_REUSEPORT is not supported."</span>;</div><div class="line">  &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> Socket::setKeepAlive(<span class="keyword">bool</span> on)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> optval = on ? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line">  ::setsockopt(sockfd_, SOL_SOCKET, SO_KEEPALIVE,</div><div class="line">               &amp;optval, <span class="keyword">static_cast</span>&lt;<span class="keyword">socklen_t</span>&gt;(<span class="keyword">sizeof</span> optval));</div><div class="line">  <span class="comment">// FIXME CHECK</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="SO-REUSEADDR和SO-REUSEPORT"><a href="#SO-REUSEADDR和SO-REUSEPORT" class="headerlink" title="SO_REUSEADDR和SO_REUSEPORT"></a>SO_REUSEADDR和SO_REUSEPORT</h1><h2 id="SO-REUSEPORT功能"><a href="#SO-REUSEPORT功能" class="headerlink" title="SO_REUSEPORT功能"></a>SO_REUSEPORT功能</h2><ol>
<li>允许多个套接字 bind()/listen() 同一个TCP/UDP端口<br>每一个线程拥有自己的服务器套接字</li>
<li>在服务器套接字上没有了锁的竞争，因为每个进程一个服务器套接字</li>
<li>内核层面实现负载均衡</li>
<li>安全层面，监听同一个端口的套接字只能位于同一个用户下面</li>
</ol>
<h2 id="SO-REUSEADDR提供如下四个功能："><a href="#SO-REUSEADDR提供如下四个功能：" class="headerlink" title="SO_REUSEADDR提供如下四个功能："></a>SO_REUSEADDR提供如下四个功能：</h2><ol>
<li>SO_REUSEADDR允许启动一个监听服务器并捆绑其众所周知端口，即使以前建立的将此端口用做他们的本地端口的连接仍存在。这通常是重启监听服务器时出现，若不设置此选项，则bind时将出错。</li>
<li>SO_REUSEADDR允许在同一端口上启动同一服务器的多个实例，只要每个实例捆绑一个不同的本地IP地址即可。对于TCP，我们根本不可能启动捆绑相同IP地址和相同端口号的多个服务器。</li>
<li>SO_REUSEADDR允许单个进程捆绑同一端口到多个套接口上，只要每个捆绑指定不同的本地IP地址即可。这一般不用于TCP服务器。</li>
<li>SO_REUSEADDR允许完全重复的捆绑：当一个IP地址和端口绑定到某个套接口上时，还允许此IP地址和端口捆绑到另一个套接口上。一般来说，这个特性仅在支持多播的系统上才有，而且只对UDP套接口而言（TCP不支持多播）。</li>
</ol>
<h2 id="SO-REUSEPORT选项有如下语义："><a href="#SO-REUSEPORT选项有如下语义：" class="headerlink" title="SO_REUSEPORT选项有如下语义："></a>SO_REUSEPORT选项有如下语义：</h2><ol>
<li>此选项允许完全重复捆绑，但仅在想捆绑相同IP地址和端口的套接口都指定了此套接口选项才行。</li>
<li>如果被捆绑的IP地址是一个多播地址，则SO_REUSEADDR和SO_REUSEPORT等效。</li>
</ol>
<h2 id="man"><a href="#man" class="headerlink" title="man"></a>man</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">SO_REUSEADDR</div><div class="line">      Indicates that the rules used <span class="keyword">in</span> validating  addresses  supplied</div><div class="line">      <span class="keyword">in</span>  a  bind(2)  call should allow reuse of local addresses.  <span class="keyword">For</span></div><div class="line">      AF_INET sockets this means that a socket may bind,  except  when</div><div class="line">      there  is an active listening socket bound <span class="keyword">to</span> the address.  When</div><div class="line">      the listening socket is bound <span class="keyword">to</span> INADDR_ANY with a specific<span class="built_in"> port</span></div><div class="line">      then  it  is  <span class="keyword">not</span>  possible  <span class="keyword">to</span>  bind <span class="keyword">to</span> this<span class="built_in"> port </span><span class="keyword">for</span> any local</div><div class="line">      address.  Argument is an integer boolean flag.</div></pre></td></tr></table></figure>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SO_REUSEPORT</div><div class="line">    One <span class="keyword">of</span> <span class="keyword">the</span> features merged <span class="keyword">in</span> <span class="keyword">the</span> <span class="number">3.9</span> development cycle was TCP <span class="keyword">and</span> UDP support <span class="keyword">for</span> <span class="keyword">the</span> SO_REUSEPORT socket option; <span class="keyword">that</span> support was implemented <span class="keyword">in</span> a series <span class="keyword">of</span> patches <span class="keyword">by</span> Tom Herbert. The new socket option allows multiple sockets <span class="keyword">on</span> <span class="keyword">the</span> same host <span class="keyword">to</span> bind <span class="keyword">to</span> <span class="keyword">the</span> same port, <span class="keyword">and</span> <span class="keyword">is</span> intended <span class="keyword">to</span> improve <span class="keyword">the</span> performance <span class="keyword">of</span> multithreaded network server applications <span class="built_in">running</span> <span class="keyword">on</span> top <span class="keyword">of</span> multicore systems.</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> muduo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> muduo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[muduo socket解析]]></title>
      <url>/2017/06/24/muduo-socket%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="功能解析"><a href="#功能解析" class="headerlink" title="功能解析"></a>功能解析</h1><p>这是一个简单的对sockfd的wrapper类，主要借助C++的RAII机制实现sockfd的自动管理。当Socket对象被析构的时候会自动关闭sockfd。</p>
<h1 id="重点函数"><a href="#重点函数" class="headerlink" title="重点函数"></a>重点函数</h1><p>可以适当关注一下以下方法，特别是对于tcp信息的获取，设置<code>TCP_NODELAY，SO_REUSEADDR，SO_REUSEPORT，SO_KEEPALIVE</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> Socket::getTcpInfo(struct tcp_info* tcpi) <span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(*tcpi);</div><div class="line">  bzero(tcpi, len);</div><div class="line">  <span class="keyword">return</span> ::getsockopt(sockfd_, SOL_TCP, TCP_INFO, tcpi, &amp;len) == <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">bool</span> Socket::getTcpInfoString(<span class="keyword">char</span>* buf, <span class="keyword">int</span> len) <span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcp_info</span> <span class="title">tcpi</span>;</span></div><div class="line">  <span class="keyword">bool</span> ok = getTcpInfo(&amp;tcpi);</div><div class="line">  <span class="keyword">if</span> (ok)</div><div class="line">  &#123;</div><div class="line">    <span class="built_in">snprintf</span>(buf, len, <span class="string">"unrecovered=%u "</span></div><div class="line">             <span class="string">"rto=%u ato=%u snd_mss=%u rcv_mss=%u "</span></div><div class="line">             <span class="string">"lost=%u retrans=%u rtt=%u rttvar=%u "</span></div><div class="line">             <span class="string">"sshthresh=%u cwnd=%u total_retrans=%u"</span>,</div><div class="line">             tcpi.tcpi_retransmits,  <span class="comment">// Number of unrecovered [RTO] timeouts</span></div><div class="line">             tcpi.tcpi_rto,          <span class="comment">// Retransmit timeout in usec</span></div><div class="line">             tcpi.tcpi_ato,          <span class="comment">// Predicted tick of soft clock in usec</span></div><div class="line">             tcpi.tcpi_snd_mss,</div><div class="line">             tcpi.tcpi_rcv_mss,</div><div class="line">             tcpi.tcpi_lost,         <span class="comment">// Lost packets</span></div><div class="line">             tcpi.tcpi_retrans,      <span class="comment">// Retransmitted packets out</span></div><div class="line">             tcpi.tcpi_rtt,          <span class="comment">// Smoothed round trip time in usec</span></div><div class="line">             tcpi.tcpi_rttvar,       <span class="comment">// Medium deviation</span></div><div class="line">             tcpi.tcpi_snd_ssthresh,</div><div class="line">             tcpi.tcpi_snd_cwnd,</div><div class="line">             tcpi.tcpi_total_retrans);  <span class="comment">// Total retransmits for entire connection</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> ok;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> Socket::bindAddress(<span class="keyword">const</span> InetAddress&amp; addr)</div><div class="line">&#123;</div><div class="line">  sockets::bindOrDie(sockfd_, addr.getSockAddr());</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> Socket::listen()</div><div class="line">&#123;</div><div class="line">  sockets::listenOrDie(sockfd_);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> Socket::accept(InetAddress* peeraddr)</div><div class="line">&#123;</div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> <span class="title">addr</span>;</span></div><div class="line">  bzero(&amp;addr, <span class="keyword">sizeof</span> addr);</div><div class="line">  <span class="keyword">int</span> connfd = sockets::accept(sockfd_, &amp;addr);</div><div class="line">  <span class="keyword">if</span> (connfd &gt;= <span class="number">0</span>)</div><div class="line">  &#123;</div><div class="line">    peeraddr-&gt;setSockAddrInet6(addr);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> connfd;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> Socket::shutdownWrite()</div><div class="line">&#123;</div><div class="line">  sockets::shutdownWrite(sockfd_);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> Socket::setTcpNoDelay(<span class="keyword">bool</span> on)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> optval = on ? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line">  ::setsockopt(sockfd_, IPPROTO_TCP, TCP_NODELAY,</div><div class="line">               &amp;optval, <span class="keyword">static_cast</span>&lt;<span class="keyword">socklen_t</span>&gt;(<span class="keyword">sizeof</span> optval));</div><div class="line">  <span class="comment">// FIXME CHECK</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> Socket::setReuseAddr(<span class="keyword">bool</span> on)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> optval = on ? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line">  ::setsockopt(sockfd_, SOL_SOCKET, SO_REUSEADDR,</div><div class="line">               &amp;optval, <span class="keyword">static_cast</span>&lt;<span class="keyword">socklen_t</span>&gt;(<span class="keyword">sizeof</span> optval));</div><div class="line">  <span class="comment">// FIXME CHECK</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> Socket::setReusePort(<span class="keyword">bool</span> on)</div><div class="line">&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SO_REUSEPORT</span></div><div class="line">  <span class="keyword">int</span> optval = on ? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line">  <span class="keyword">int</span> ret = ::setsockopt(sockfd_, SOL_SOCKET, SO_REUSEPORT,</div><div class="line">                         &amp;optval, <span class="keyword">static_cast</span>&lt;<span class="keyword">socklen_t</span>&gt;(<span class="keyword">sizeof</span> optval));</div><div class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; on)</div><div class="line">  &#123;</div><div class="line">    LOG_SYSERR &lt;&lt; <span class="string">"SO_REUSEPORT failed."</span>;</div><div class="line">  &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">else</span></span></div><div class="line">  <span class="keyword">if</span> (on)</div><div class="line">  &#123;</div><div class="line">    LOG_ERROR &lt;&lt; <span class="string">"SO_REUSEPORT is not supported."</span>;</div><div class="line">  &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> Socket::setKeepAlive(<span class="keyword">bool</span> on)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> optval = on ? <span class="number">1</span> : <span class="number">0</span>;</div><div class="line">  ::setsockopt(sockfd_, SOL_SOCKET, SO_KEEPALIVE,</div><div class="line">               &amp;optval, <span class="keyword">static_cast</span>&lt;<span class="keyword">socklen_t</span>&gt;(<span class="keyword">sizeof</span> optval));</div><div class="line">  <span class="comment">// FIXME CHECK</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="SO-REUSEADDR和SO-REUSEPORT"><a href="#SO-REUSEADDR和SO-REUSEPORT" class="headerlink" title="SO_REUSEADDR和SO_REUSEPORT"></a>SO_REUSEADDR和SO_REUSEPORT</h1><h2 id="SO-REUSEPORT功能"><a href="#SO-REUSEPORT功能" class="headerlink" title="SO_REUSEPORT功能"></a>SO_REUSEPORT功能</h2><ol>
<li>允许多个套接字 bind()/listen() 同一个TCP/UDP端口<br>每一个线程拥有自己的服务器套接字</li>
<li>在服务器套接字上没有了锁的竞争，因为每个进程一个服务器套接字</li>
<li>内核层面实现负载均衡</li>
<li>安全层面，监听同一个端口的套接字只能位于同一个用户下面</li>
</ol>
<h2 id="SO-REUSEADDR提供如下四个功能："><a href="#SO-REUSEADDR提供如下四个功能：" class="headerlink" title="SO_REUSEADDR提供如下四个功能："></a>SO_REUSEADDR提供如下四个功能：</h2><ol>
<li>SO_REUSEADDR允许启动一个监听服务器并捆绑其众所周知端口，即使以前建立的将此端口用做他们的本地端口的连接仍存在。这通常是重启监听服务器时出现，若不设置此选项，则bind时将出错。</li>
<li>SO_REUSEADDR允许在同一端口上启动同一服务器的多个实例，只要每个实例捆绑一个不同的本地IP地址即可。对于TCP，我们根本不可能启动捆绑相同IP地址和相同端口号的多个服务器。</li>
<li>SO_REUSEADDR允许单个进程捆绑同一端口到多个套接口上，只要每个捆绑指定不同的本地IP地址即可。这一般不用于TCP服务器。</li>
<li>SO_REUSEADDR允许完全重复的捆绑：当一个IP地址和端口绑定到某个套接口上时，还允许此IP地址和端口捆绑到另一个套接口上。一般来说，这个特性仅在支持多播的系统上才有，而且只对UDP套接口而言（TCP不支持多播）。</li>
</ol>
<h2 id="SO-REUSEPORT选项有如下语义："><a href="#SO-REUSEPORT选项有如下语义：" class="headerlink" title="SO_REUSEPORT选项有如下语义："></a>SO_REUSEPORT选项有如下语义：</h2><ol>
<li>此选项允许完全重复捆绑，但仅在想捆绑相同IP地址和端口的套接口都指定了此套接口选项才行。</li>
<li>如果被捆绑的IP地址是一个多播地址，则SO_REUSEADDR和SO_REUSEPORT等效。</li>
</ol>
<h2 id="man"><a href="#man" class="headerlink" title="man"></a>man</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">SO_REUSEADDR</div><div class="line">      Indicates that the rules used <span class="keyword">in</span> validating  addresses  supplied</div><div class="line">      <span class="keyword">in</span>  a  bind(2)  call should allow reuse of local addresses.  <span class="keyword">For</span></div><div class="line">      AF_INET sockets this means that a socket may bind,  except  when</div><div class="line">      there  is an active listening socket bound <span class="keyword">to</span> the address.  When</div><div class="line">      the listening socket is bound <span class="keyword">to</span> INADDR_ANY with a specific<span class="built_in"> port</span></div><div class="line">      then  it  is  <span class="keyword">not</span>  possible  <span class="keyword">to</span>  bind <span class="keyword">to</span> this<span class="built_in"> port </span><span class="keyword">for</span> any local</div><div class="line">      address.  Argument is an integer boolean flag.</div></pre></td></tr></table></figure>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SO_REUSEPORT</div><div class="line">    One <span class="keyword">of</span> <span class="keyword">the</span> features merged <span class="keyword">in</span> <span class="keyword">the</span> <span class="number">3.9</span> development cycle was TCP <span class="keyword">and</span> UDP support <span class="keyword">for</span> <span class="keyword">the</span> SO_REUSEPORT socket option; <span class="keyword">that</span> support was implemented <span class="keyword">in</span> a series <span class="keyword">of</span> patches <span class="keyword">by</span> Tom Herbert. The new socket option allows multiple sockets <span class="keyword">on</span> <span class="keyword">the</span> same host <span class="keyword">to</span> bind <span class="keyword">to</span> <span class="keyword">the</span> same port, <span class="keyword">and</span> <span class="keyword">is</span> intended <span class="keyword">to</span> improve <span class="keyword">the</span> performance <span class="keyword">of</span> multithreaded network server applications <span class="built_in">running</span> <span class="keyword">on</span> top <span class="keyword">of</span> multicore systems.</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> muduo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> muduo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[muduo TcpServer解析]]></title>
      <url>/2017/06/24/muduo-TcpServer%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="TcpServer简介"><a href="#TcpServer简介" class="headerlink" title="TcpServer简介"></a>TcpServer简介</h1><p>在tcp网络编程之中，服务器比客户端更容易实现。对应TcpServer的实现，总共不过200多行代码。</p>
<p>核心数据成员：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">string</span>, TcpConnectionPtr&gt; ConnectionMap;</div><div class="line">ConnectionMap connections_;</div></pre></td></tr></table></figure>
<p>TcpServer的使用流程如下所示：</p>
<ol>
<li>创建TcpServer对象</li>
<li>设置各种回调函数，包括MessageCallback以及ConnectionCallback</li>
<li>设置io的线程数目</li>
<li>开启监听</li>
</ol>
<h1 id="创建连接"><a href="#创建连接" class="headerlink" title="创建连接"></a>创建连接</h1><p>当Acceptor成功接受了一个连接之后，会调用newConnection函数。</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">void TcpServer::newConnection(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> InetAddress&amp; peerAddr)</div><div class="line">&#123;</div><div class="line">  loop_-&gt;assertInLoopThread();</div><div class="line">  EventLoop* ioLoop = threadPool_-&gt;getNextLoop();</div><div class="line">  <span class="keyword">char</span> buf[<span class="number">64</span>];</div><div class="line">  snprintf(buf, sizeof buf, <span class="string">"-%s#%d"</span>, ipPort_.c_str(), nextConnId_);</div><div class="line">  ++nextConnId_;</div><div class="line">  string connName = name_ + buf;</div><div class="line"></div><div class="line">  LOG_INFO &lt;&lt; <span class="string">"TcpServer::newConnection ["</span> &lt;&lt; name_</div><div class="line">           &lt;&lt; <span class="string">"] - new connection ["</span> &lt;&lt; connName</div><div class="line">           &lt;&lt; <span class="string">"] from "</span> &lt;&lt; peerAddr.toIpPort();</div><div class="line">  InetAddress localAddr(sockets::getLocalAddr(sockfd));</div><div class="line">  <span class="comment">// FIXME poll with zero timeout to double confirm the new connection</span></div><div class="line">  <span class="comment">// FIXME use make_shared if necessary</span></div><div class="line">  TcpConnectionPtr conn(<span class="keyword">new</span> TcpConnection(ioLoop,</div><div class="line">                                          connName,</div><div class="line">                                          sockfd,</div><div class="line">                                          localAddr,</div><div class="line">                                          peerAddr));</div><div class="line">  connections_[connName] = conn;</div><div class="line">  conn-&gt;setConnectionCallback(connectionCallback_);</div><div class="line">  conn-&gt;setMessageCallback(messageCallback_);</div><div class="line">  conn-&gt;setWriteCompleteCallback(writeCompleteCallback_);</div><div class="line">  conn-&gt;setCloseCallback(</div><div class="line">      std::bind(&amp;TcpServer::removeConnection, this, _1)); <span class="comment">// <span class="doctag">FIXME:</span> unsafe</span></div><div class="line">  ioLoop-&gt;runInLoop(std::bind(&amp;TcpConnection::connectEstablished, conn));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上述代码可见，TcpServer为新的连接对应的sockfd创建了TcpConnection对象，并且设置了各种回调。重点操作是对于负载均衡的处理，TcpServer从EventLoop池中取出一个loop用于处理新的连接对应的io时间，实现了多线程负载均衡服务。在muduo的TcpServer之中，使用专一的loop用来处理接受连接，使用EventLoop池中的loop用来处理与客户端之间的io事件。</p>
<h1 id="移除连接"><a href="#移除连接" class="headerlink" title="移除连接"></a>移除连接</h1><p>在muduo的TcpServer之中，移除连接需要从对应的io线程之中移除连接，而非接受连接的那个线程。所以，对于removeConnection以及TcpServer的析构函数需要进行特殊处理，将remove操作锁定在连接对应的io线程之中运行。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">void TcpServer::removeConnectionInLoop(<span class="keyword">const</span> TcpConnectionPtr&amp; conn)</div><div class="line">&#123;</div><div class="line">  loop_-&gt;assertInLoopThread();</div><div class="line">  LOG_INFO &lt;&lt; <span class="string">"TcpServer::removeConnectionInLoop ["</span> &lt;&lt; name_</div><div class="line">           &lt;&lt; <span class="string">"] - connection "</span> &lt;&lt; conn-&gt;name();</div><div class="line">  size_t n = connections_.erase(conn-&gt;name());</div><div class="line">  (void)n;</div><div class="line">  assert(n == <span class="number">1</span>);</div><div class="line">  EventLoop* ioLoop = conn-&gt;getLoop();</div><div class="line">  ioLoop-&gt;queueInLoop(</div><div class="line">      std::bind(&amp;TcpConnection::connectDestroyed, conn));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">TcpServer:</span><span class="symbol">:~TcpServer</span>()</div><div class="line">&#123;</div><div class="line">  loop<span class="number">_</span>-&gt;assertInLoopThread();</div><div class="line">  LOG_TRACE &lt;&lt; <span class="string">"TcpServer::~TcpServer ["</span> &lt;&lt; name<span class="number">_</span> &lt;&lt; <span class="string">"] destructing"</span>;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="symbol">ConnectionMap:</span><span class="symbol">:iterator</span> it(connections<span class="number">_</span>.<span class="keyword">begin</span>());</div><div class="line">      it != connections<span class="number">_</span>.<span class="keyword">end</span>(); ++it)</div><div class="line">  &#123;</div><div class="line">    TcpConnectionPtr conn = it-&gt;second;</div><div class="line">    it-&gt;second.reset();</div><div class="line">    conn-&gt;getLoop()-&gt;runInLoop(</div><div class="line">      <span class="symbol">std:</span><span class="symbol">:bind</span>(&amp;<span class="symbol">TcpConnection:</span><span class="symbol">:connectDestroyed</span>, conn));</div><div class="line">    conn.reset();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> muduo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> muduo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[muduo TcpConnection解析]]></title>
      <url>/2017/06/24/muduo-TcpConnection%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="TcpConnection"><a href="#TcpConnection" class="headerlink" title="TcpConnection"></a>TcpConnection</h1><p>TcpConnection实现了对连接的抽象，连接建立，连接断开，发送数据，接收数据的操作也都封装在其中，其中的难点是对连接关闭的处理。</p>
<h1 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h1><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">TcpConnection::TcpConnection(EventLoop* <span class="keyword">loop</span>,</div><div class="line">                             <span class="keyword">const</span> string&amp; nameArg,</div><div class="line">                             int sockfd,</div><div class="line">                             <span class="keyword">const</span> InetAddress&amp; localAddr,</div><div class="line">                             <span class="keyword">const</span> InetAddress&amp; peerAddr)</div><div class="line">  : loop_(CHECK_NOTNULL(<span class="keyword">loop</span>)),</div><div class="line">    name_(nameArg),</div><div class="line">    state_(kConnecting),</div><div class="line">    reading_(<span class="literal">true</span>),</div><div class="line">    socket_(new Socket(sockfd)),</div><div class="line">    channel_(new Channel(<span class="keyword">loop</span>, sockfd)),</div><div class="line">    localAddr_(localAddr),</div><div class="line">    peerAddr_(peerAddr),</div><div class="line">    highWaterMark_(<span class="number">64</span>*<span class="number">1024</span>*<span class="number">1024</span>)</div><div class="line">&#123;</div><div class="line">  channel_-&gt;setReadCallback(</div><div class="line">      std::bind(&amp;TcpConnection::handleRead, this, _1));</div><div class="line">  channel_-&gt;setWriteCallback(</div><div class="line">      std::bind(&amp;TcpConnection::handleWrite, this));</div><div class="line">  channel_-&gt;setCloseCallback(</div><div class="line">      std::bind(&amp;TcpConnection::handleClose, this));</div><div class="line">  channel_-&gt;setErrorCallback(</div><div class="line">      std::bind(&amp;TcpConnection::handleError, this));</div><div class="line">  LOG_DEBUG &lt;&lt; <span class="string">"TcpConnection::ctor["</span> &lt;&lt;  name_ &lt;&lt; <span class="string">"] at "</span> &lt;&lt; this</div><div class="line">            &lt;&lt; <span class="string">" fd="</span> &lt;&lt; sockfd;</div><div class="line">  socket_-&gt;setKeepAlive(<span class="literal">true</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从代码中可知，TcpConnection也是基于Channel实现的。在构造函数中记录了loop句柄，使用Socket对象管理sockfd。对于io事件，读事件绑定的回调函数是handleRead函数，写事件绑定的回调函数是handleWrite, close事件绑定的回调函数是handleClose, error事件绑定的回调函数是handleError。同时，在构造函数的末尾开启了socket的keepalive选项。在构造函数之中设置了连接的当前状态是kConnecting，表示正在连接。</p>
<p>连接完成之后，可以通过调用函数connectEstablished来设定当前状态为已经连接并且调用连接所对应的回调函数。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">void</span> <span class="selector-tag">TcpConnection</span><span class="selector-pseudo">::connectEstablished()</span></div><div class="line">&#123;</div><div class="line">  <span class="selector-tag">loop_-</span>&gt;<span class="selector-tag">assertInLoopThread</span>();</div><div class="line">  <span class="selector-tag">assert</span>(state_ == kConnecting);</div><div class="line">  <span class="selector-tag">setState</span>(kConnected);</div><div class="line">  <span class="selector-tag">channel_-</span>&gt;<span class="selector-tag">tie</span>(shared_from_this());</div><div class="line">  <span class="selector-tag">channel_-</span>&gt;<span class="selector-tag">enableReading</span>();</div><div class="line">  <span class="comment">// call connection callback function to notify TcpConnectionPtr user</span></div><div class="line">  <span class="selector-tag">connectionCallback_</span>(shared_from_this());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了保证Channel在执行TcpConnection中相关io事件的回调函数的过程中，不会因为TcpConnection对象在相关回调调用过程中被析构而造成为channel设定的回调函数失效，这里使用了Channel内置的tie方法记录TcpConnection的weak_ptr，调用回调期间将weak_ptr提升为shared_ptr来保证上述情况不会发生。因为有这种用法，TcpConnection对象必须使用shared_ptr进行管理。</p>
<h1 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h1><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">void TcpConnection::handleRead(Timestamp receiveTime)</div><div class="line">&#123;</div><div class="line">  loop_-&gt;assertInLoopThread()<span class="comment">;</span></div><div class="line">  int savedErrno = <span class="number">0</span><span class="comment">;</span></div><div class="line">  ssize_t n = inputBuffer_.readFd(channel_-&gt;fd(), &amp;savedErrno)<span class="comment">;</span></div><div class="line">  if (n &gt; <span class="number">0</span>)</div><div class="line">  &#123;</div><div class="line">    messageCallback_(<span class="keyword">shared_from_this(), </span>&amp;inputBuffer_, receiveTime)<span class="comment">;</span></div><div class="line">  &#125;</div><div class="line">  else if (n == <span class="number">0</span>)</div><div class="line">  &#123;</div><div class="line">    handleClose()<span class="comment">;</span></div><div class="line">  &#125;</div><div class="line">  else</div><div class="line">  &#123;</div><div class="line">    errno = savedErrno<span class="comment">;</span></div><div class="line">    LOG_SYSERR &lt;&lt; <span class="string">"TcpConnection::handleRead"</span><span class="comment">;</span></div><div class="line">    handleError()<span class="comment">;</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当有可读事件发生时，调用handleRead函数。若read返回0，代表对方关闭了连接，调用handleClose函数，若read返回值大于0，使用当前时间，inputBuffer以及本对象的shared_ptr调用message回调。</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> TcpConnection::handleClose()</div><div class="line">&#123;</div><div class="line">  loop<span class="number">_</span>-&gt;assertInLoopThread();</div><div class="line">  LOG<span class="number">_T</span>RACE &lt;&lt; <span class="string">"fd = "</span> &lt;&lt; channel<span class="number">_</span>-&gt;fd() &lt;&lt; <span class="string">" state = "</span> &lt;&lt; stateToString();</div><div class="line">  <span class="keyword">assert</span>(state<span class="number">_</span> == kConnected || state<span class="number">_</span> == kDisconnecting);</div><div class="line">  <span class="comment">// we don't close fd, leave it to dtor, so we can find leaks easily.</span></div><div class="line">  setState(kDisconnected);</div><div class="line">  channel<span class="number">_</span>-&gt;disableAll();</div><div class="line"></div><div class="line">  TcpConnectionPtr guardThis(<span class="keyword">shared</span><span class="number">_f</span>rom<span class="number">_</span><span class="keyword">this</span>());</div><div class="line">  connectionCallback<span class="number">_</span>(guardThis);</div><div class="line">  <span class="comment">// must be the last line</span></div><div class="line">  closeCallback<span class="number">_</span>(guardThis);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>handleClose之中将当前状态设置为DisConnected, channel不再关注任何io事件，调用connection以及close回调通知TcpConnection对象的所有者，连接已经关闭了。</p>
<p>需要留意的是，在调用close回调的时候，可能TcpConnection的所有者就直接将TcpConnection <strong>丢弃</strong>，因而这里做了guard处理。</p>
<h1 id="写入数据"><a href="#写入数据" class="headerlink" title="写入数据"></a>写入数据</h1><p><strong>我们一定要保证所有的io操作都需要在io线程之中完成，这样才能实现线程安全。</strong>数据的发送主要分为两种情况，一种是当前没有数据要发送，那么首先在io线程中尝试发送，将剩余没有发送的数据存入outputBuffer，关注可写事件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> TcpConnection::sendInLoop(<span class="keyword">const</span> <span class="keyword">void</span>* data, <span class="keyword">size_t</span> len)</div><div class="line">&#123;</div><div class="line">  loop_-&gt;assertInLoopThread();</div><div class="line">  <span class="keyword">ssize_t</span> nwrote = <span class="number">0</span>;</div><div class="line">  <span class="keyword">size_t</span> remaining = len;</div><div class="line">  <span class="keyword">bool</span> faultError = <span class="literal">false</span>;</div><div class="line">  <span class="keyword">if</span> (state_ == kDisconnected)</div><div class="line">  &#123;</div><div class="line">    LOG_WARN &lt;&lt; <span class="string">"disconnected, give up writing"</span>;</div><div class="line">    <span class="keyword">return</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// if no thing in output queue, try writing directly</span></div><div class="line">  <span class="keyword">if</span> (!channel_-&gt;isWriting() &amp;&amp; outputBuffer_.readableBytes() == <span class="number">0</span>)</div><div class="line">  &#123;</div><div class="line">    nwrote = sockets::write(channel_-&gt;fd(), data, len);</div><div class="line">    <span class="keyword">if</span> (nwrote &gt;= <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">      remaining = len - nwrote;</div><div class="line">      <span class="keyword">if</span> (remaining == <span class="number">0</span> &amp;&amp; writeCompleteCallback_)</div><div class="line">      &#123;</div><div class="line">        loop_-&gt;queueInLoop(<span class="built_in">std</span>::bind(writeCompleteCallback_, shared_from_this()));</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="comment">// nwrote &lt; 0</span></div><div class="line">    &#123;</div><div class="line">      nwrote = <span class="number">0</span>;</div><div class="line">      <span class="keyword">if</span> (errno != EWOULDBLOCK)</div><div class="line">      &#123;</div><div class="line">        LOG_SYSERR &lt;&lt; <span class="string">"TcpConnection::sendInLoop"</span>;</div><div class="line">        <span class="keyword">if</span> (errno == EPIPE || errno == ECONNRESET) <span class="comment">// <span class="doctag">FIXME:</span> any others?</span></div><div class="line">        &#123;</div><div class="line">          faultError = <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  assert(remaining &lt;= len);</div><div class="line">  <span class="keyword">if</span> (!faultError &amp;&amp; remaining &gt; <span class="number">0</span>)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">size_t</span> oldLen = outputBuffer_.readableBytes();</div><div class="line">    <span class="keyword">if</span> (oldLen + remaining &gt;= highWaterMark_</div><div class="line">        &amp;&amp; oldLen &lt; highWaterMark_</div><div class="line">        &amp;&amp; highWaterMarkCallback_)</div><div class="line">    &#123;</div><div class="line">      loop_-&gt;queueInLoop(<span class="built_in">std</span>::bind(highWaterMarkCallback_, shared_from_this(), oldLen + remaining));</div><div class="line">    &#125;</div><div class="line">    outputBuffer_.append(<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(data)+nwrote, remaining);</div><div class="line">    <span class="keyword">if</span> (!channel_-&gt;isWriting())</div><div class="line">    &#123;</div><div class="line">      channel_-&gt;enableWriting();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>请注意，这里有对高水位回调函数的调用，高水位回调函数在outputBuffer的size大于HighWaterMark_的时候会被调用。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">void TcpConnection::handleWrite()</div><div class="line">&#123;</div><div class="line">  loop_-&gt;assertInLoopThread();</div><div class="line">  <span class="keyword">if</span> (channel_-&gt;isWriting())</div><div class="line">  &#123;</div><div class="line">    ssize_t n = sockets::write(channel_-&gt;fd(),</div><div class="line">                               outputBuffer_.peek(),</div><div class="line">                               outputBuffer_.readableBytes());</div><div class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">      outputBuffer_.retrieve(n);</div><div class="line">      <span class="keyword">if</span> (outputBuffer_.readableBytes() == <span class="number">0</span>)</div><div class="line">      &#123;</div><div class="line">        channel_-&gt;disableWriting();</div><div class="line">        <span class="keyword">if</span> (writeCompleteCallback_)</div><div class="line">        &#123;</div><div class="line">          loop_-&gt;queueInLoop(std::bind(writeCompleteCallback_, shared_from_this()));</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (state_ == kDisconnecting)</div><div class="line">        &#123;</div><div class="line">          shutdownInLoop();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">      LOG_SYSERR &lt;&lt; <span class="string">"TcpConnection::handleWrite"</span>;</div><div class="line">      <span class="comment">// if (state_ == kDisconnecting)</span></div><div class="line">      <span class="comment">// &#123;</span></div><div class="line">      <span class="comment">//   shutdownInLoop();</span></div><div class="line">      <span class="comment">// &#125;</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">  &#123;</div><div class="line">    LOG_TRACE &lt;&lt; <span class="string">"Connection fd = "</span> &lt;&lt; channel_-&gt;fd()</div><div class="line">              &lt;&lt; <span class="string">" is down, no more writing"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在handleWrite中继续发送剩余的数据，当发送完毕之后，会调用WriteComplete回调函数，通知TcpConnection所有者所有数据都已发送完毕。发送完所有数据会不再关注可写事件，否则会造成busy loop。</p>
<h1 id="连接关闭"><a href="#连接关闭" class="headerlink" title="连接关闭"></a>连接关闭</h1><p>关闭连接不可直接close对应的sockfd，否则积压在链路中未被对方应用程序接收的数据可能丢失。对此muduo的处理是首先shutdown write。关闭写之后，对方read就会返回0，此时对方就会关闭连接，这样本地sockfd就会read返回0，此时调用handleClose完成最终的连接关闭操作。这种主动的连接关闭策略是一种比较文雅的关闭方式，能够保证链路中的数据能够被对方完整的接收到。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void TcpConnection::shutdownInLoop()</div><div class="line">&#123;</div><div class="line">  <span class="function"><span class="title">loop_</span>-&gt;</span>assertInLoopThread();</div><div class="line">  <span class="function"><span class="title">if</span> (!channel_-&gt;</span>isWriting())</div><div class="line">  &#123;</div><div class="line">    <span class="comment">// we are not writing</span></div><div class="line">    <span class="function"><span class="title">socket_</span>-&gt;</span>shutdownWrite();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对应文雅的连接关闭方式，也有比较粗暴的连接关闭手段，那就是直接forceClose。forceClose的操作和对方关闭连接导致本地连接read返回0的操作其实是一致的。</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void TcpConnection::forceCloseInLoop()</div><div class="line">&#123;</div><div class="line">  loop_-&gt;assertInLoopThread();</div><div class="line">  <span class="keyword">if</span> (state_ == kConnected |<span class="type">| state_</span> == kDisconnecting)</div><div class="line">  &#123;</div><div class="line">    // <span class="built_in">as</span> <span class="keyword">if</span> we received <span class="number">0</span> byte <span class="built_in">in</span> handleRead();</div><div class="line">    handleClose();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>TcpConnection对象的主要使用者是TcpServer和TcpClient，当TcpServer对象被析构的时候，其所拥有的所有连接对象也应该被析构。但是没有那么简单，我们需要保证TcpConnection对象在析构的时候，其对应的Channel也从Poller之中移除了。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">void</span> <span class="selector-tag">TcpConnection</span><span class="selector-pseudo">::connectDestroyed()</span></div><div class="line">&#123;</div><div class="line">  <span class="selector-tag">loop_-</span>&gt;<span class="selector-tag">assertInLoopThread</span>();</div><div class="line">  <span class="selector-tag">if</span> (state_ == kConnected)</div><div class="line">  &#123;</div><div class="line">    <span class="selector-tag">setState</span>(kDisconnected);</div><div class="line">    <span class="selector-tag">channel_-</span>&gt;<span class="selector-tag">disableAll</span>();</div><div class="line"></div><div class="line">    <span class="selector-tag">connectionCallback_</span>(shared_from_this());</div><div class="line">  &#125;</div><div class="line">  <span class="selector-tag">channel_-</span>&gt;<span class="selector-tag">remove</span>();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因而TcpServer在析构的时候，会对他所拥有的所有TcpConnection逐一调用connectDestroyed，保证所有的channel都被正确移除了。</p>
<p>当然，在TcpServer移除连接的时候，也会做上述处理。</p>
]]></content>
      
        <categories>
            
            <category> muduo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> muduo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[muduo TcpClient解析]]></title>
      <url>/2017/06/24/muduo-TcpClient%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>TcpClient是muduo网络库中提供的用于创建tcp连接的类。 TcpClient的主要操作主要是借助Connector来实现的。</p>
<h1 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h1><p>创建新连接操作：</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">void TcpClient::newConnection(<span class="keyword">int</span> sockfd)</div><div class="line">&#123;</div><div class="line">  loop_-&gt;assertInLoopThread();</div><div class="line">  InetAddress peerAddr(sockets::getPeerAddr(sockfd));</div><div class="line">  <span class="keyword">char</span> buf[<span class="number">32</span>];</div><div class="line">  snprintf(buf, sizeof buf, <span class="string">":%s#%d"</span>, peerAddr.toIpPort().c_str(), nextConnId_);</div><div class="line">  ++nextConnId_;</div><div class="line">  string connName = name_ + buf;</div><div class="line"></div><div class="line">  InetAddress localAddr(sockets::getLocalAddr(sockfd));</div><div class="line">  <span class="comment">// FIXME poll with zero timeout to double confirm the new connection</span></div><div class="line">  <span class="comment">// FIXME use make_shared if necessary</span></div><div class="line">  TcpConnectionPtr conn(<span class="keyword">new</span> TcpConnection(loop_,</div><div class="line">                                          connName,</div><div class="line">                                          sockfd,</div><div class="line">                                          localAddr,</div><div class="line">                                          peerAddr));</div><div class="line"></div><div class="line">  conn-&gt;setConnectionCallback(connectionCallback_);</div><div class="line">  conn-&gt;setMessageCallback(messageCallback_);</div><div class="line">  conn-&gt;setWriteCompleteCallback(writeCompleteCallback_);</div><div class="line">  conn-&gt;setCloseCallback(</div><div class="line">      std::bind(&amp;TcpClient::removeConnection, this, _1)); <span class="comment">// <span class="doctag">FIXME:</span> unsafe</span></div><div class="line">  &#123;</div><div class="line">    MutexLockGuard lock(mutex_);</div><div class="line">    connection_ = conn;</div><div class="line">  &#125;</div><div class="line">  conn-&gt;connectEstablished();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>连接建立成功之后，会创建TcpConnectionPtr，并且做好记录。在close回调之中，TcpClient首先移除了连接，然后调用了connectDestroyed方法来将连接对应的channel从poller之中移除。若设定为需要重试，那么removeConnection还会重启Connector，重新进行连接。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">void TcpClient::removeConnection(<span class="keyword">const</span> TcpConnectionPtr&amp; conn)</div><div class="line">&#123;</div><div class="line">  loop_-&gt;assertInLoopThread();</div><div class="line">  assert(loop_ == conn-&gt;getLoop());</div><div class="line"></div><div class="line">  &#123;</div><div class="line">    MutexLockGuard lock(mutex_);</div><div class="line">    assert(connection_ == conn);</div><div class="line">    connection_.reset();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  loop_-&gt;queueInLoop(std::bind(&amp;TcpConnection::connectDestroyed, conn));</div><div class="line">  <span class="keyword">if</span> (retry_ &amp;&amp; connect_)</div><div class="line">  &#123;</div><div class="line">    LOG_INFO &lt;&lt; <span class="string">"TcpClient::connect["</span> &lt;&lt; name_ &lt;&lt; <span class="string">"] - Reconnecting to "</span></div><div class="line">             &lt;&lt; connector_-&gt;serverAddress().toIpPort();</div><div class="line">    connector_-&gt;restart();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>若要关闭连接，则首先判断TcpClient的TcpConnectionPtr是否有效，有效就关闭连接，并且设置connect_为false，TcpClient不再进行重试。因为可能会涉及到跨线程调用，所以在修改TcpConnectionPtr的时候会使用锁进行保护，确保线程安全。</p>
<h1 id="TcpClient的析构函数"><a href="#TcpClient的析构函数" class="headerlink" title="TcpClient的析构函数"></a>TcpClient的析构函数</h1><p>首先列出一下TcpClient对象的析构函数的代码：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">TcpClient::~TcpClient()</div><div class="line">&#123;</div><div class="line">  LOG_INFO &lt;&lt; <span class="string">"TcpClient::~TcpClient["</span> &lt;&lt; name_</div><div class="line">           &lt;&lt; <span class="string">"] - connector "</span> &lt;&lt; get_pointer(connector_);</div><div class="line">  TcpConnectionPtr conn;</div><div class="line">  <span class="built_in">bool</span> unique = <span class="literal">false</span>;</div><div class="line">  &#123;</div><div class="line">    MutexLockGuard lock(mutex_);</div><div class="line">    unique = connection_.unique();</div><div class="line">    conn = connection_;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (conn)</div><div class="line">  &#123;</div><div class="line">    assert(loop_ == conn-&gt;getLoop());</div><div class="line">    <span class="comment">// <span class="doctag">FIXME:</span> not 100% safe, if we are in different thread</span></div><div class="line">    CloseCallback cb = std::bind(&amp;detail::removeConnection, loop_, _1);</div><div class="line">    loop_-&gt;runInLoop(</div><div class="line">        std::bind(&amp;TcpConnection::setCloseCallback, conn, cb));</div><div class="line">    <span class="keyword">if</span> (unique)</div><div class="line">    &#123;</div><div class="line">      conn-&gt;forceClose();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">  &#123;</div><div class="line">    connector_-&gt;stop();</div><div class="line">    <span class="comment">// <span class="doctag">FIXME:</span> HACK</span></div><div class="line">    loop_-&gt;runAfter(<span class="number">1</span>, std::bind(&amp;detail::removeConnector, connector_));</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可见TcpClient对象的析构函数实现比较复杂，问题的核心在于TcpConnection中的close回调调用的是TcpClient的removeConnection方法，当TcpClient对象析构之后，这一回调也就失效了。所以在析构函数中要将TcpConnection的closeCallback调整为TcpConnection中的connectDestroyed。若用户程序没有保留TcpConnectionPtr，那么就可以简单粗暴的关闭连接。否则，不能关闭连接，以保证用户程序能够继续使用。</p>
]]></content>
      
        <categories>
            
            <category> muduo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> muduo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb杂项]]></title>
      <url>/2017/06/24/leveldb%E6%9D%82%E9%A1%B9/</url>
      <content type="html"><![CDATA[<h1 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h1><p>在leveldb内部使用中，使用了内置的类型Slice用来表示字符串。Slice可以和<code>const char*</code>, <code>string</code>之间相互转换，是一种比较轻量级的字符串表示方式。Slice类似muduo之中的StringPiece数据类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Created by zy on 17-5-22.</span></div><div class="line"><span class="comment">//</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> leveldb &#123;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Slice</span> &#123;</span></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="comment">// Create an empty slice.</span></div><div class="line">  Slice() : data_(<span class="string">""</span>), size_(<span class="number">0</span>) &#123; &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Create a slice that refers to d[0,n-1].</span></div><div class="line">  Slice(<span class="keyword">const</span> <span class="keyword">char</span>* d, <span class="keyword">size_t</span> n) : data_(d), size_(n) &#123; &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Create a slice that refers to the contents of "s"</span></div><div class="line">  Slice(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; s) : data_(s.data()), size_(s.size()) &#123; &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Create a slice that refers to s[0,strlen(s)-1]</span></div><div class="line">  Slice(<span class="keyword">const</span> <span class="keyword">char</span>* s) : data_(s), size_(<span class="built_in">strlen</span>(s)) &#123; &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Return a pointer to the beginning of the referenced data</span></div><div class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">data</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data_; &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Return the length (in bytes) of the referenced data</span></div><div class="line">  <span class="keyword">size_t</span> size() <span class="keyword">const</span> &#123; <span class="keyword">return</span> size_; &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Return true iff the length of the referenced data is zero</span></div><div class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_ == <span class="number">0</span>; &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Return the ith byte in the referenced data.</span></div><div class="line">  <span class="comment">// REQUIRES: n &lt; size()</span></div><div class="line">  <span class="keyword">char</span> <span class="keyword">operator</span>[](<span class="keyword">size_t</span> n) <span class="keyword">const</span> &#123;</div><div class="line">    assert(n &lt; size());</div><div class="line">    <span class="keyword">return</span> data_[n];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Change this slice to refer to an empty array</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123; data_ = <span class="string">""</span>; size_ = <span class="number">0</span>; &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Drop the first "n" bytes from this slice.</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">remove_prefix</span><span class="params">(<span class="keyword">size_t</span> n)</span> </span>&#123;</div><div class="line">    assert(n &lt;= size());</div><div class="line">    data_ += n;</div><div class="line">    size_ -= n;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Return a string that contains the copy of the referenced data.</span></div><div class="line">  <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">ToString</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">string</span>(data_, size_); &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Three-way comparison.  Returns value:</span></div><div class="line">  <span class="comment">//   &lt;  0 iff "*this" &lt;  "b",</span></div><div class="line">  <span class="comment">//   == 0 iff "*this" == "b",</span></div><div class="line">  <span class="comment">//   &gt;  0 iff "*this" &gt;  "b"</span></div><div class="line">  <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> Slice&amp; b)</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">// Return true iff "x" is a prefix of "*this"</span></div><div class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">starts_with</span><span class="params">(<span class="keyword">const</span> Slice&amp; x)</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> ((size_ &gt;= x.size_) &amp;&amp;</div><div class="line">        (<span class="built_in">memcmp</span>(data_, x.data_, x.size_) == <span class="number">0</span>));</div><div class="line">  &#125;</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* data_;</div><div class="line">  <span class="keyword">size_t</span> size_;</div><div class="line"></div><div class="line">  <span class="comment">// Intentionally copyable</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Slice&amp; x, <span class="keyword">const</span> Slice&amp; y) &#123;</div><div class="line">  <span class="keyword">return</span> ((x.size() == y.size()) &amp;&amp;</div><div class="line">      (<span class="built_in">memcmp</span>(x.data(), y.data(), x.size()) == <span class="number">0</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Slice&amp; x, <span class="keyword">const</span> Slice&amp; y) &#123;</div><div class="line">  <span class="keyword">return</span> !(x == y);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">inline</span> <span class="keyword">int</span> Slice::compare(<span class="keyword">const</span> Slice&amp; b) <span class="keyword">const</span> &#123;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> min_len = (size_ &lt; b.size_) ? size_ : b.size_;</div><div class="line">  <span class="keyword">int</span> r = <span class="built_in">memcmp</span>(data_, b.data_, min_len);</div><div class="line">  <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (size_ &lt; b.size_) r = <span class="number">-1</span>;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (size_ &gt; b.size_) r = +<span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> r;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;  <span class="comment">// namespace leveldb</span></div></pre></td></tr></table></figure>
<h1 id="Status"><a href="#Status" class="headerlink" title="Status"></a>Status</h1><p>在leveldb中，使用自定义类型Status来表示当前状态。Status内部数据成员如下所示：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// OK status has a NULL state_.  Otherwise, state_ is a new[]<span class="built_in"> array</span></div><div class="line">  // of the following form:</div><div class="line">  //    state_[0..3] == length of message</div><div class="line">  //    state_[4]    == code</div><div class="line">  //    state_[5..]  == message</div><div class="line"> <span class="built_in"> const </span>char* state_;</div></pre></td></tr></table></figure>
<p>可见这是一种非常精简的数据表示方式，使用<code>const char* state_</code>存储一些复合的数据，包括状态码，字符串长度，字符串。这种表示方式简单明了，可以借鉴。特别是如果当前状态为<code>kOk</code>，那么state_设定为NULL，这样充分节省了空间(因为状态除非出错，一般都为<code>kOk</code>)。</p>
<p>Status具体实现非常简单，以下仅贴出代码说明:</p>
<p>status.h</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"leveldb/slice.h"</span></span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> leveldb &#123;</div><div class="line"></div><div class="line">class Status &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="comment">// Create a success status.</span></div><div class="line">  Status() : state_(NULL) &#123; &#125;</div><div class="line">  ~Status() &#123; <span class="keyword">delete</span>[] state_; &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Copy the specified status.</span></div><div class="line">  Status(<span class="keyword">const</span> Status&amp; s);</div><div class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> Status&amp; s);</div><div class="line"></div><div class="line">  <span class="comment">// Return a success status.</span></div><div class="line">  <span class="keyword">static</span> Status OK() &#123; <span class="built_in">return</span> Status(); &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Return error status of an appropriate type.</span></div><div class="line">  <span class="keyword">static</span> Status NotFound(<span class="keyword">const</span> Slice&amp; msg, <span class="keyword">const</span> Slice&amp; msg2 = Slice()) &#123;</div><div class="line">    <span class="built_in">return</span> Status(kNotFound, msg, msg2);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">static</span> Status Corruption(<span class="keyword">const</span> Slice&amp; msg, <span class="keyword">const</span> Slice&amp; msg2 = Slice()) &#123;</div><div class="line">    <span class="built_in">return</span> Status(kCorruption, msg, msg2);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">static</span> Status NotSupported(<span class="keyword">const</span> Slice&amp; msg, <span class="keyword">const</span> Slice&amp; msg2 = Slice()) &#123;</div><div class="line">    <span class="built_in">return</span> Status(kNotSupported, msg, msg2);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">static</span> Status InvalidArgument(<span class="keyword">const</span> Slice&amp; msg, <span class="keyword">const</span> Slice&amp; msg2 = Slice()) &#123;</div><div class="line">    <span class="built_in">return</span> Status(kInvalidArgument, msg, msg2);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">static</span> Status IOError(<span class="keyword">const</span> Slice&amp; msg, <span class="keyword">const</span> Slice&amp; msg2 = Slice()) &#123;</div><div class="line">    <span class="built_in">return</span> Status(kIOError, msg, msg2);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Returns true iff the status indicates success.</span></div><div class="line">  <span class="keyword">bool</span> ok() <span class="keyword">const</span> &#123; <span class="built_in">return</span> (state_ == NULL); &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Returns true iff the status indicates a NotFound error.</span></div><div class="line">  <span class="keyword">bool</span> IsNotFound() <span class="keyword">const</span> &#123; <span class="built_in">return</span> code() == kNotFound; &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Returns true iff the status indicates a Corruption error.</span></div><div class="line">  <span class="keyword">bool</span> IsCorruption() <span class="keyword">const</span> &#123; <span class="built_in">return</span> code() == kCorruption; &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Returns true iff the status indicates an IOError.</span></div><div class="line">  <span class="keyword">bool</span> IsIOError() <span class="keyword">const</span> &#123; <span class="built_in">return</span> code() == kIOError; &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Returns true iff the status indicates a NotSupportedError.</span></div><div class="line">  <span class="keyword">bool</span> IsNotSupportedError() <span class="keyword">const</span> &#123; <span class="built_in">return</span> code() == kNotSupported; &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Returns true iff the status indicates an InvalidArgument.</span></div><div class="line">  <span class="keyword">bool</span> IsInvalidArgument() <span class="keyword">const</span> &#123; <span class="built_in">return</span> code() == kInvalidArgument; &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Return a string representation of this status suitable for printing.</span></div><div class="line">  <span class="comment">// Returns the string "OK" for success.</span></div><div class="line">  std::<span class="keyword">string</span> ToString() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="comment">// OK status has a NULL state_.  Otherwise, state_ is a new[] array</span></div><div class="line">  <span class="comment">// of the following form:</span></div><div class="line">  <span class="comment">//    state_[0..3] == length of message</span></div><div class="line">  <span class="comment">//    state_[4]    == code</span></div><div class="line">  <span class="comment">//    state_[5..]  == message</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* state_;</div><div class="line"></div><div class="line">  <span class="keyword">enum</span> Code &#123;</div><div class="line">    kOk = <span class="number">0</span>,</div><div class="line">    kNotFound = <span class="number">1</span>,</div><div class="line">    kCorruption = <span class="number">2</span>,</div><div class="line">    kNotSupported = <span class="number">3</span>,</div><div class="line">    kInvalidArgument = <span class="number">4</span>,</div><div class="line">    kIOError = <span class="number">5</span></div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  Code code() <span class="keyword">const</span> &#123;</div><div class="line">    <span class="built_in">return</span> (state_ == NULL) ? kOk : <span class="keyword">static_cast</span>&lt;Code&gt;(state_[<span class="number">4</span>]);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Status(Code code, <span class="keyword">const</span> Slice&amp; msg, <span class="keyword">const</span> Slice&amp; msg2);</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* CopyState(<span class="keyword">const</span> <span class="keyword">char</span>* s);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">inline</span> Status::Status(<span class="keyword">const</span> Status&amp; s) &#123;</div><div class="line">  state_ = (s.state_ == NULL) ? NULL : CopyState(s.state_);</div><div class="line">&#125;</div><div class="line"><span class="keyword">inline</span> <span class="keyword">void</span> Status::<span class="keyword">operator</span>=(<span class="keyword">const</span> Status&amp; s) &#123;</div><div class="line">  <span class="comment">// The following condition catches both aliasing (when this == &amp;s),</span></div><div class="line">  <span class="comment">// and the common case where both s and *this are ok.</span></div><div class="line">  <span class="built_in">if</span> (state_ != s.state_) &#123;</div><div class="line">    <span class="keyword">delete</span>[] state_;</div><div class="line">    state_ = (s.state_ == NULL) ? NULL : CopyState(s.state_);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;  <span class="comment">// namespace leveldb</span></div></pre></td></tr></table></figure>
<p>status.cc</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"port/port.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"leveldb/status.h"</span></span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> leveldb</div><div class="line">&#123;</div><div class="line"><span class="comment">// 4byte 1byte message......</span></div><div class="line"><span class="comment">// length code message contents</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">char</span> *Status::CopyState(<span class="keyword">const</span> <span class="keyword">char</span> *state)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">uint32_t</span> size;</div><div class="line">  <span class="built_in">memcmp</span>(&amp;size, state, <span class="keyword">sizeof</span>(size));</div><div class="line">  <span class="keyword">char</span> *result = <span class="keyword">new</span> <span class="keyword">char</span>[size + <span class="number">5</span>];</div><div class="line">  <span class="built_in">memcpy</span>(result, state, size + <span class="number">5</span>);</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status::Status(Code code, <span class="keyword">const</span> Slice &amp;msg, <span class="keyword">const</span> Slice &amp;msg2)</div><div class="line">&#123;</div><div class="line">  assert(code != kOk);</div><div class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> len1 = msg.size();</div><div class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> len2 = msg2.size();</div><div class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> size = len1 + (len2 ? (<span class="number">2</span> + len2) : <span class="number">0</span>);</div><div class="line">  <span class="keyword">char</span> *result = <span class="keyword">new</span> <span class="keyword">char</span>[size + <span class="number">5</span>];</div><div class="line">  <span class="built_in">memcpy</span>(result, &amp;size, <span class="keyword">sizeof</span>(size));</div><div class="line">  result[<span class="number">4</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(code);</div><div class="line">  <span class="built_in">memcpy</span>(result + <span class="number">5</span>, msg.data(), len1);</div><div class="line">  <span class="keyword">if</span> (len2)</div><div class="line">  &#123;</div><div class="line">    result[<span class="number">5</span> + len1] = <span class="string">':'</span>;</div><div class="line">    result[<span class="number">6</span> + len1] = <span class="string">' '</span>;</div><div class="line">    <span class="built_in">memcpy</span>(result + <span class="number">7</span> + len1, msg2.data(), len2);</div><div class="line">  &#125;</div><div class="line">  state_ = result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> Status::ToString() <span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> (state_ == <span class="literal">NULL</span>)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">return</span> <span class="string">"OK"</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">  &#123;</div><div class="line">    <span class="keyword">char</span> tmp[<span class="number">30</span>];</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *type;</div><div class="line">    <span class="keyword">switch</span> (code())</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">case</span> kOk:type = <span class="string">"OK"</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> kNotFound:type = <span class="string">"NotFound: "</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> kCorruption:type = <span class="string">"Corruption: "</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> kNotSupported:type = <span class="string">"Not implemented: "</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> kInvalidArgument:type = <span class="string">"Invalid argument: "</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> kIOError:type = <span class="string">"IO error: "</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        <span class="built_in">snprintf</span>(tmp, <span class="keyword">sizeof</span>(tmp), <span class="string">"Unknown code(%d): "</span>,</div><div class="line">                 <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(code()));</div><div class="line">        type = tmp;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">result</span><span class="params">(type)</span></span>;</div><div class="line">    <span class="keyword">uint32_t</span> length;</div><div class="line">    <span class="built_in">memcpy</span>(&amp;length, state_, <span class="keyword">sizeof</span>(length));</div><div class="line">    result.append(state_ + <span class="number">5</span>, length);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#125;   <span class="comment">//  namespace leveldb</span></div></pre></td></tr></table></figure>
<h1 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h1><p>在leveldb内部实现之中，hash采用的是murmur hash算法，这种hash实现能够最大化减小hash碰撞，值得学习。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">uint32_t</span> Hash(<span class="keyword">const</span> <span class="keyword">char</span>* data, <span class="keyword">size_t</span> n, <span class="keyword">uint32_t</span> seed) &#123;</div><div class="line">  <span class="comment">// Similar to murmur hash</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> m = <span class="number">0xc6a4a793</span>;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> r = <span class="number">24</span>;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* limit = data + n;</div><div class="line">  <span class="keyword">uint32_t</span> h = seed ^ (n * m);</div><div class="line"></div><div class="line">  <span class="comment">// Pick up four bytes at a time</span></div><div class="line">  <span class="keyword">while</span> (data + <span class="number">4</span> &lt;= limit) &#123;</div><div class="line">    <span class="keyword">uint32_t</span> w = DecodeFixed32(data);</div><div class="line">    data += <span class="number">4</span>;</div><div class="line">    h += w;</div><div class="line">    h *= m;</div><div class="line">    h ^= (h &gt;&gt; <span class="number">16</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Pick up remaining bytes</span></div><div class="line">  <span class="keyword">switch</span> (limit - data) &#123;</div><div class="line">    <span class="keyword">case</span> <span class="number">3</span>:</div><div class="line">      h += <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(data[<span class="number">2</span>]) &lt;&lt; <span class="number">16</span>;</div><div class="line">    <span class="keyword">case</span> <span class="number">2</span>:</div><div class="line">      h += <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(data[<span class="number">1</span>]) &lt;&lt; <span class="number">8</span>;</div><div class="line">    <span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">      h += <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>&gt;(data[<span class="number">0</span>]);</div><div class="line">      h *= m;</div><div class="line">      h ^= (h &gt;&gt; r);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> h;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，leveldb util相关的代码分析完毕，下面转入对table定义的分析。</p>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb env解读]]></title>
      <url>/2017/06/24/leveldb-env%E8%A7%A3%E8%AF%BB/</url>
      <content type="html"><![CDATA[<h1 id="创建Env对象"><a href="#创建Env对象" class="headerlink" title="创建Env对象"></a>创建Env对象</h1><p>在leveldb之中，创建默认的env对象使用的是<code>pthread_once</code>操作保证初始化操作只执行一次。此操作可以用来实现singleton。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InitDefaultEnv</span><span class="params">()</span> </span>&#123; default_env = <span class="keyword">new</span> PosixEnv; &#125;</div><div class="line">Env* Env::Default() &#123;</div><div class="line">  pthread_once(&amp;once, InitDefaultEnv);</div><div class="line">  <span class="keyword">return</span> default_env;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="简单的任务调度"><a href="#简单的任务调度" class="headerlink" title="简单的任务调度"></a>简单的任务调度</h1><p>在PosixEnv中，实现了一个简单的任务调度，实质上是一个基于多生产者，单消费者的任务调度，生产者与消费者之间通过阻塞队列完成任务的传递分发。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> PosixEnv::Schedule(<span class="keyword">void</span> (*<span class="function"><span class="keyword">function</span>)(<span class="params">void*</span>), <span class="title">void</span>* <span class="title">arg</span>) </span>&#123;</div><div class="line">  PthreadCall(<span class="string">"lock"</span>, pthread_mutex_lock(&amp;mu_));</div><div class="line"></div><div class="line">  <span class="comment">// Start background thread if necessary</span></div><div class="line">  <span class="keyword">if</span> (!started_bgthread_) &#123;</div><div class="line">    started_bgthread_ = <span class="literal">true</span>;</div><div class="line">    PthreadCall(</div><div class="line">        <span class="string">"create thread"</span>,</div><div class="line">        pthread_create(&amp;bgthread_, NULL,  &amp;PosixEnv::BGThreadWrapper, <span class="keyword">this</span>));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// If the queue is currently empty, the background thread may currently be</span></div><div class="line">  <span class="comment">// waiting.</span></div><div class="line">  <span class="keyword">if</span> (queue_.empty()) &#123;</div><div class="line">    PthreadCall(<span class="string">"signal"</span>, pthread_cond_signal(&amp;bgsignal_));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Add to priority queue</span></div><div class="line">  queue_.push_back(BGItem());</div><div class="line">  queue_.back().function = <span class="function"><span class="keyword">function</span>;</span></div><div class="line">  <span class="title">queue_</span>.<span class="title">back</span>(<span class="params"></span>).<span class="title">arg</span> = <span class="title">arg</span>;</div><div class="line"></div><div class="line">  <span class="title">PthreadCall</span>(<span class="params"><span class="string">"unlock"</span>, pthread_mutex_unlock(&amp;mu_</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在schedule之中，如果没有创建后台线程，会创建一个后台线程用于处理任务。后台线程会执行BGThread函数，在此函数之内循环从阻塞队列中取出任务，执行任务对应的函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> PosixEnv::BGThread() &#123;</div><div class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">    <span class="comment">// Wait until there is an item that is ready to run</span></div><div class="line">    PthreadCall(<span class="string">"lock"</span>, pthread_mutex_lock(&amp;mu_));</div><div class="line">    <span class="keyword">while</span> (queue_.empty()) &#123;</div><div class="line">      PthreadCall(<span class="string">"wait"</span>, pthread_cond_wait(&amp;bgsignal_, &amp;mu_));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">void</span> (*<span class="function"><span class="keyword">function</span>)(<span class="params">void*</span>) = <span class="title">queue_</span>.<span class="title">front</span>(<span class="params"></span>).<span class="title">function</span>;</span></div><div class="line">    <span class="title">void</span>* <span class="title">arg</span> = <span class="title">queue_</span>.<span class="title">front</span>(<span class="params"></span>).<span class="title">arg</span>;</div><div class="line">    <span class="title">queue_</span>.<span class="title">pop_front</span>(<span class="params"></span>);</div><div class="line"></div><div class="line">    <span class="title">PthreadCall</span>(<span class="params"><span class="string">"unlock"</span>, pthread_mutex_unlock(&amp;mu_</span>));</div><div class="line">    (<span class="params">*function</span>)(<span class="params">arg</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="一些系统调用"><a href="#一些系统调用" class="headerlink" title="一些系统调用"></a>一些系统调用</h1><h2 id="查看文件是否存在"><a href="#查看文件是否存在" class="headerlink" title="查看文件是否存在"></a>查看文件是否存在</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">FileExists</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; fname)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> access(fname.c_str(), F_OK) == <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="获取文件大小"><a href="#获取文件大小" class="headerlink" title="获取文件大小"></a>获取文件大小</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">GetFileSize</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; fname, <span class="keyword">uint64_t</span>* size)</span> </span>&#123;</div><div class="line">   Status s;</div><div class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">sbuf</span>;</span></div><div class="line">   <span class="keyword">if</span> (stat(fname.c_str(), &amp;sbuf) != <span class="number">0</span>) &#123;</div><div class="line">     *size = <span class="number">0</span>;</div><div class="line">     s = IOError(fname, errno);</div><div class="line">   &#125; <span class="keyword">else</span> &#123;</div><div class="line">     *size = sbuf.st_size;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> s;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h2 id="重命名文件"><a href="#重命名文件" class="headerlink" title="重命名文件"></a>重命名文件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">RenameFile</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; src, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; target)</span> </span>&#123;</div><div class="line">   Status result;</div><div class="line">   <span class="keyword">if</span> (rename(src.c_str(), target.c_str()) != <span class="number">0</span>) &#123;</div><div class="line">     result = IOError(src, errno);</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> result;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h2 id="获取路径中的内容"><a href="#获取路径中的内容" class="headerlink" title="获取路径中的内容"></a>获取路径中的内容</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">GetChildren</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dir,</span></span></div><div class="line">                           <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;* result) &#123;</div><div class="line">  result-&gt;clear();</div><div class="line">  DIR* d = opendir(dir.c_str());</div><div class="line">  <span class="keyword">if</span> (d == <span class="literal">NULL</span>) &#123;</div><div class="line">    <span class="keyword">return</span> IOError(dir, errno);</div><div class="line">  &#125;</div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">entry</span>;</span></div><div class="line">  <span class="keyword">while</span> ((entry = readdir(d)) != <span class="literal">NULL</span>) &#123;</div><div class="line">    result-&gt;push_back(entry-&gt;d_name);</div><div class="line">  &#125;</div><div class="line">  closedir(d);</div><div class="line">  <span class="keyword">return</span> Status::OK();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="锁定文件"><a href="#锁定文件" class="headerlink" title="锁定文件"></a>锁定文件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">LockOrUnlock</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">bool</span> lock)</span> </span>&#123;</div><div class="line">  errno = <span class="number">0</span>;</div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">flock</span> <span class="title">f</span>;</span></div><div class="line">  <span class="built_in">memset</span>(&amp;f, <span class="number">0</span>, <span class="keyword">sizeof</span>(f));</div><div class="line">  f.l_type = (lock ? F_WRLCK : F_UNLCK);</div><div class="line">  f.l_whence = SEEK_SET;</div><div class="line">  f.l_start = <span class="number">0</span>;</div><div class="line">  f.l_len = <span class="number">0</span>;        <span class="comment">// Lock/unlock entire file</span></div><div class="line">  <span class="keyword">return</span> fcntl(fd, F_SETLK, &amp;f);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="sync-文件"><a href="#sync-文件" class="headerlink" title="sync 文件"></a>sync 文件</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">virtual</span> Status <span class="built_in">Sync</span>() &#123;</div><div class="line">   <span class="comment">// Ensure new files referred to by the manifest are in the filesystem.</span></div><div class="line">   Status s = SyncDirIfManifest();</div><div class="line">   <span class="keyword">if</span> (!s.ok()) &#123;</div><div class="line">     <span class="keyword">return</span> s;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">if</span> (fflush_unlocked(file_) != <span class="number">0</span> ||</div><div class="line">       fdatasync(fileno(file_)) != <span class="number">0</span>) &#123;</div><div class="line">     s = Status::IOError(filename_, strerror(errno));</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> s;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb coding解读]]></title>
      <url>/2017/06/24/leveldb-coding%E8%A7%A3%E8%AF%BB/</url>
      <content type="html"><![CDATA[<h1 id="leveldb-coding解读"><a href="#leveldb-coding解读" class="headerlink" title="leveldb coding解读"></a>leveldb coding解读</h1><p>这一节的重点主要围绕varint，varint是一个变长的int数表示方法，他利用每个byte的第一位来记录后面是否还有byte来组成这个int数。若byte的第一位为1，表示后面还有byte来组成这个数，否则说明此byte是组成int数的最后一个byte。如果用于存储比较小的数，使用varint比使用int更节省空间，在protobuf之中也使用了varint。</p>
<p><img src="http://pic002.cnblogs.com/images/2012/254151/2012050309195415.jpg" alt="varint示例图"></p>
<p>下面是EncodeVarint32的操作步骤：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">char</span>* <span class="title">EncodeVarint32</span><span class="params">(<span class="keyword">char</span>* dst, <span class="keyword">uint32_t</span> v)</span> </span>&#123;</div><div class="line">  <span class="comment">// Operate on characters as unsigneds</span></div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>* ptr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">char</span>*&gt;(dst);</div><div class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> B = <span class="number">128</span>;</div><div class="line">  <span class="keyword">if</span> (v &lt; (<span class="number">1</span>&lt;&lt;<span class="number">7</span>)) &#123;</div><div class="line">    *(ptr++) = v;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span>&lt;&lt;<span class="number">14</span>)) &#123;</div><div class="line">    *(ptr++) = v | B;</div><div class="line">    *(ptr++) = v&gt;&gt;<span class="number">7</span>;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span>&lt;&lt;<span class="number">21</span>)) &#123;</div><div class="line">    *(ptr++) = v | B;</div><div class="line">    *(ptr++) = (v&gt;&gt;<span class="number">7</span>) | B;</div><div class="line">    *(ptr++) = v&gt;&gt;<span class="number">14</span>;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v &lt; (<span class="number">1</span>&lt;&lt;<span class="number">28</span>)) &#123;</div><div class="line">    *(ptr++) = v | B;</div><div class="line">    *(ptr++) = (v&gt;&gt;<span class="number">7</span>) | B;</div><div class="line">    *(ptr++) = (v&gt;&gt;<span class="number">14</span>) | B;</div><div class="line">    *(ptr++) = v&gt;&gt;<span class="number">21</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    *(ptr++) = v | B;</div><div class="line">    *(ptr++) = (v&gt;&gt;<span class="number">7</span>) | B;</div><div class="line">    *(ptr++) = (v&gt;&gt;<span class="number">14</span>) | B;</div><div class="line">    *(ptr++) = (v&gt;&gt;<span class="number">21</span>) | B;</div><div class="line">    *(ptr++) = v&gt;&gt;<span class="number">28</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(ptr);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">PutVarint32</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* dst, <span class="keyword">uint32_t</span> v)</span> </span>&#123;</div><div class="line">  <span class="keyword">char</span> buf[<span class="number">5</span>];</div><div class="line">  <span class="keyword">char</span>* ptr = EncodeVarint32(buf, v);</div><div class="line">  dst-&gt;append(buf, ptr - buf);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>下面是DecodeVarint32的操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">GetVarint64Ptr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p, <span class="keyword">const</span> <span class="keyword">char</span>* limit, <span class="keyword">uint64_t</span>* value)</span> </span>&#123;</div><div class="line">  <span class="keyword">uint64_t</span> result = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> shift = <span class="number">0</span>; shift &lt;= <span class="number">63</span> &amp;&amp; p &lt; limit; shift += <span class="number">7</span>) &#123;</div><div class="line">    <span class="keyword">uint64_t</span> byte = *(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>*&gt;(p));</div><div class="line">    p++;</div><div class="line">    <span class="keyword">if</span> (byte &amp; <span class="number">128</span>) &#123;</div><div class="line">      <span class="comment">// More bytes are present</span></div><div class="line">      result |= ((byte &amp; <span class="number">127</span>) &lt;&lt; shift);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      result |= (byte &lt;&lt; shift);</div><div class="line">      *value = result;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(p);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>varint64的相关操作与此类似，省略。</p>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb cache解读]]></title>
      <url>/2017/06/24/leveldb-cache%E8%A7%A3%E8%AF%BB/</url>
      <content type="html"><![CDATA[<h1 id="leveldb-cache-解读"><a href="#leveldb-cache-解读" class="headerlink" title="leveldb cache 解读"></a>leveldb cache 解读</h1><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在leveldb之中，实现了一个基于hash table和双向循环链表的cache。每个cache的结构如下所示:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LRUHandle</span></span></div><div class="line">&#123;</div><div class="line">  <span class="comment">// pointer to value</span></div><div class="line">  <span class="keyword">void</span> *value;</div><div class="line">  <span class="comment">// destructor function</span></div><div class="line">  <span class="keyword">void</span> (*deleter)(<span class="keyword">const</span> Slice &amp;, <span class="keyword">void</span> *value);</div><div class="line">  LRUHandle *next_hash; <span class="comment">// point to next hash elem</span></div><div class="line">  LRUHandle *next;      <span class="comment">// linked list pointer </span></div><div class="line">  LRUHandle *prev;      <span class="comment">// linked list pointer </span></div><div class="line">  <span class="keyword">size_t</span> charge;</div><div class="line">  <span class="keyword">size_t</span> key_length;</div><div class="line">  <span class="keyword">bool</span> in_cache; <span class="comment">// whether entry is in the cache</span></div><div class="line">  <span class="keyword">uint32_t</span> refs; <span class="comment">// references, including cache reference, if present.</span></div><div class="line">  <span class="keyword">uint32_t</span> hash; <span class="comment">// Hash of key(); used for fast sharding and comparisons</span></div><div class="line">  <span class="keyword">char</span> key_data[<span class="number">1</span>]; <span class="comment">// beginning of key.</span></div><div class="line"></div><div class="line">  <span class="function">Slice <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span></span></div><div class="line">  &#123;</div><div class="line">    <span class="comment">// for cheapter lookups, we allow a temporary Handle object</span></div><div class="line">    <span class="comment">// to store a pointer to a key in "value".</span></div><div class="line">    <span class="keyword">if</span> (next == <span class="keyword">this</span>)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">return</span> *(<span class="keyword">reinterpret_cast</span>&lt;Slice *&gt;(value));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">      <span class="keyword">return</span> Slice(key_data, key_length);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h1 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h1><p>作者实现了一个hashTable，和stl一样，此hash table是基于开链hash实现，并且负载系数限制在1以内，如果负载因子超过此限制，就会扩充hash table的容量，并进行rehash处理。</p>
<p>hash table的查找操作如下所示: 其实就是找到对应hash的链表，依次遍历链表直到找到key完全一致的元素。如果找不到，会返回NULL。</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">// <span class="keyword">return</span> a pointer <span class="keyword">to</span> slot that points <span class="keyword">to</span> a cache entry that</div><div class="line">  // matches key/hash. <span class="keyword">If</span> there is no such cache entry, <span class="keyword">return</span></div><div class="line">  // a pointer <span class="keyword">to</span> the trailing slot <span class="keyword">in</span> the corresponding linked list.</div><div class="line">  LRUHandle **FindPointer(<span class="keyword">const</span> Slice &amp;key, uint32_t hash)</div><div class="line">  &#123;</div><div class="line">    LRUHandle **<span class="built_in">ptr</span> = &amp;list_[hash &amp; (length_ - <span class="number">1</span>)]<span class="comment">;</span></div><div class="line">    // 开链</div><div class="line">    <span class="keyword">while</span> ((*<span class="built_in">ptr</span> != <span class="literal">NULL</span>) &amp;&amp; ((*<span class="built_in">ptr</span>)-&gt;hash != hash || key != (*<span class="built_in">ptr</span>)-&gt;key()))</div><div class="line">    &#123;</div><div class="line">      <span class="built_in">ptr</span> = &amp;(*<span class="built_in">ptr</span>)-&gt;next_hash<span class="comment">;</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">ptr</span><span class="comment">;</span></div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>insert操作是找到对应hash值的链表，将其插入链表的头部。当然，需要检查负载系数，负载系数超过1需要进行resize。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">LRUHandle *Insert(LRUHandle *h)</div><div class="line">&#123;</div><div class="line">    LRUHandle **ptr = FindPointer(h-&gt;key(), h-&gt;hash);</div><div class="line">    LRUHandle *old = *ptr;</div><div class="line">    h-&gt;next_hash = (old == <span class="keyword">NULL</span> ? <span class="keyword">NULL</span> : old-&gt;next_hash);</div><div class="line">    *ptr = h;</div><div class="line">    <span class="keyword">if</span> (old == <span class="keyword">NULL</span>)</div><div class="line">    &#123;</div><div class="line">      ++elems_;</div><div class="line">      <span class="keyword">if</span> (elems_ &gt; length_)</div><div class="line">      &#123;</div><div class="line">        <span class="comment">// Since each entry is fairly large, we aim for a small</span></div><div class="line">        <span class="comment">// average linked list length (&lt;= 1).</span></div><div class="line">        Resize();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> old;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Remove操作是将找到的元素从hash链表中删除，并且更新元素的数目。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">// remove <span class="keyword">from</span> hash table</div><div class="line"><span class="type">LRUHandle</span> *<span class="type">Remove</span>(<span class="keyword">const</span> <span class="type">Slice</span> &amp;key, uint32_t hash)</div><div class="line">&#123;</div><div class="line">  <span class="type">LRUHandle</span> **<span class="keyword">ptr</span> = <span class="type">FindPointer</span>(key, hash);</div><div class="line">  <span class="type">LRUHandle</span> *<span class="literal">result</span> = *<span class="keyword">ptr</span>;</div><div class="line">  <span class="keyword">if</span> (<span class="literal">result</span> != <span class="type">NULL</span>)</div><div class="line">  &#123;</div><div class="line">    *<span class="keyword">ptr</span> = <span class="literal">result</span>-&gt;next_hash;</div><div class="line">    --elems_;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">result</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Resize操作和vector一样，容量扩充的倍数为2。创建新的容量的hash table之后，要将原有的元素根据hash table的原则链接到正确的位置之上。</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">void Resize()</div><div class="line">&#123;</div><div class="line">    uint32_t <span class="keyword">new</span><span class="type">_length</span> = <span class="number">4</span>;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">new</span><span class="type">_length</span> &lt; elems_)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">new</span><span class="type">_length</span> *= <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">    LRUHandle **<span class="keyword">new</span><span class="type">_list</span> = <span class="keyword">new</span> <span class="type">LRUHandle</span> *[<span class="keyword">new</span><span class="type">_length</span>];</div><div class="line">    memset(<span class="keyword">new</span><span class="type">_list</span>, <span class="number">0</span>, sizeof(<span class="keyword">new</span><span class="type">_list</span>[<span class="number">0</span>]) * <span class="keyword">new</span><span class="type">_length</span>);</div><div class="line">    uint32_t count = <span class="number">0</span>;</div><div class="line">    <span class="comment">// rehash hash table</span></div><div class="line">    <span class="keyword">for</span> (uint32_t i = <span class="number">0</span>; i &lt; length_; i++)</div><div class="line">    &#123;</div><div class="line">      LRUHandle *h = list_[i];</div><div class="line">      <span class="keyword">while</span> (h != NULL)</div><div class="line">      &#123;</div><div class="line">        LRUHandle *next = h-&gt;next_hash;</div><div class="line">        uint32_t hash = h-&gt;hash;</div><div class="line">        LRUHandle **ptr = &amp;<span class="keyword">new</span><span class="type">_list</span>[hash &amp; (<span class="keyword">new</span><span class="type">_length</span> - <span class="number">1</span>)];</div><div class="line">        <span class="comment">// link new hash item to the header</span></div><div class="line">        h-&gt;next_hash = *ptr;</div><div class="line">        *ptr = h;</div><div class="line">        <span class="comment">// now to handle next hash item</span></div><div class="line">        h = next;</div><div class="line">        count++;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    assert(elems_ == count);</div><div class="line">    delete[] list_;</div><div class="line">    list_ = <span class="keyword">new</span><span class="type">_list</span>;</div><div class="line">    length_ = <span class="keyword">new</span><span class="type">_length</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="LRUCache"><a href="#LRUCache" class="headerlink" title="LRUCache"></a>LRUCache</h1><p>在LRUCache之中，使用hashTable存放key与对应cache块之间的对应关系。并且在此类中还有两个双向循环链表，其中<code>in_use_</code>链表存放用户正在使用的cache，这一部分数据不可以被销毁。<code>lru_</code>链表存放用户没有使用的cache，从<code>lru_-&gt;prev</code> 到<code>lru_-&gt;next</code>表示使用的先后关系，越在前面，表示越近被使用。<code>lru_</code>和<code>in_use_</code>是一个dummy node，简化了链表的实现，便于快速定位链表的头部和尾部。</p>
<p>Ref操作表示对cache的引用操作，会将其引用计数加1，如果当前cache块在<code>lru_</code>链表之中，会将其转移到<code>in_use_</code>链表之中，防止被LRU操作清除。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">void LRUCache::Ref(LRUHandle *e)</div><div class="line">&#123;</div><div class="line">  <span class="function"><span class="title">if</span> (e-&gt;</span><span class="function"><span class="title">refs</span> == 1 &amp;&amp; e-&gt;</span>in_cache) <span class="comment">// if on lru_ list, move to in_use_ list</span></div><div class="line">  &#123;</div><div class="line">    LRU_Remove(e);</div><div class="line">    <span class="comment">// now in use list</span></div><div class="line">    LRU_Append(&amp;in_use_, e);</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="title">e</span>-&gt;</span>refs++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而UnRef操作会减小cache的引用计数，若cache的引用计数降为1，表示cache从链表中删除了，会调用deleter函数之后，将其从内存释放。若用户将此块完全释放，会将其转移到<code>lru_</code>链表之中。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">void LRUCache::UnRef(LRUHandle *e)</div><div class="line">&#123;</div><div class="line">  <span class="function"><span class="title">assert</span>(e-&gt;</span>refs &gt; <span class="number">0</span>);</div><div class="line">  <span class="function"><span class="title">e</span>-&gt;</span>refs--;</div><div class="line">  <span class="function"><span class="title">if</span> (e-&gt;</span>refs == <span class="number">0</span>) <span class="comment">// Deallocate.</span></div><div class="line">  &#123;</div><div class="line">    <span class="function"><span class="title">assert</span>(!e-&gt;</span>in_cache);</div><div class="line">    (*<span class="function"><span class="title">e</span>-&gt;</span><span class="function"><span class="title">deleter</span>)(e-&gt;</span><span class="function"><span class="title">key</span>(), e-&gt;</span>value);</div><div class="line">    free(e);</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="title">else</span> <span class="keyword">if</span> (e-&gt;</span><span class="function"><span class="title">in_cache</span> &amp;&amp; e-&gt;</span>refs == <span class="number">1</span>) <span class="comment">// no longer in use; move to lru_ list</span></div><div class="line">  &#123;</div><div class="line">    LRU_Remove(e);</div><div class="line">    LRU_Append(&amp;lru_, e);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>LRUCache的插入操作会将其插入<code>lru_</code>链表的开头位置。若插入之后cache的容量超限，会将最近没有使用的块按照时间顺序依次清除，最先清除使用时间间隔最长的块。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">Cache::Handle *LRUCache::Insert(<span class="keyword">const</span> Slice &amp;key,</div><div class="line">                                <span class="keyword">uint32_t</span> hash,</div><div class="line">                                <span class="keyword">void</span> *value,</div><div class="line">                                <span class="keyword">size_t</span> charge,</div><div class="line">                                <span class="keyword">void</span> (*deleter)(<span class="keyword">const</span> Slice &amp;, <span class="keyword">void</span> *))</div><div class="line">&#123;</div><div class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</div><div class="line">  LRUHandle *e = <span class="keyword">reinterpret_cast</span>&lt;LRUHandle *&gt;(<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LRUHandle) - <span class="number">1</span> + key.size()));</div><div class="line">  e-&gt;value = value;</div><div class="line">  e-&gt;deleter = deleter;</div><div class="line">  e-&gt;charge = charge;</div><div class="line">  e-&gt;key_length = key.size();</div><div class="line">  e-&gt;hash = hash;</div><div class="line">  e-&gt;in_cache = <span class="literal">false</span>;</div><div class="line">  e-&gt;refs = <span class="number">1</span>;</div><div class="line">  <span class="built_in">memcpy</span>(e-&gt;key_data, key.data(), key.size());</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (capacity_ &gt; <span class="number">0</span>)</div><div class="line">  &#123;</div><div class="line">    e-&gt;refs++; <span class="comment">// for the cache's reference</span></div><div class="line">    e-&gt;in_cache = <span class="literal">true</span>;</div><div class="line">    <span class="comment">// append into use list</span></div><div class="line">    LRU_Append(&amp;in_use_, e);</div><div class="line">    usage_ += charge;</div><div class="line">    FinishErase(table_.Insert(e));</div><div class="line">  &#125; <span class="comment">// else don't cache</span></div><div class="line"></div><div class="line">  <span class="comment">// erase from cache list</span></div><div class="line">  <span class="keyword">while</span> (usage_ &gt; capacity_ &amp;&amp; lru_.next != &amp;lru_)</div><div class="line">  &#123;</div><div class="line">    LRUHandle *old = lru_.next;</div><div class="line">    assert(old-&gt;refs == <span class="number">1</span>);</div><div class="line">    <span class="keyword">bool</span> erased = FinishErase(table_.Remove(old-&gt;key(), old-&gt;hash));</div><div class="line">    <span class="keyword">if</span> (!erased) <span class="comment">// to avoid unused variable when compiled NDEBUG</span></div><div class="line">    &#123;</div><div class="line">      assert(erased);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;Cache::Handle *&gt;(e);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Erase操作则是删除对应key和hash值的cache，从链表之中剥离，并进行UnRef操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">void</span> LRUCache::Erase(<span class="keyword">const</span> Slice &amp;key, <span class="keyword">uint32_t</span> hash)</div><div class="line">&#123;</div><div class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</div><div class="line">  <span class="comment">// erase from hash table</span></div><div class="line">  FinishErase(table_.Remove(key, hash));</div><div class="line">&#125;</div><div class="line"><span class="comment">// if e != NULL, finish removing *e from the cache; it has already been removed</span></div><div class="line"><span class="comment">// from the hash table. return whether e != NULL. Requires mutex_ held.</span></div><div class="line"><span class="keyword">bool</span> LRUCache::FinishErase(LRUHandle *e)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> (e != <span class="literal">NULL</span>)</div><div class="line">  &#123;</div><div class="line">    assert(e-&gt;in_cache);</div><div class="line">    LRU_Remove(e);</div><div class="line">    e-&gt;in_cache = <span class="literal">false</span>;</div><div class="line">    usage_ -= e-&gt;charge;</div><div class="line">    UnRef(e);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> e != <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Prune操作是删除<code>lru_</code>链表之中的所有cache。</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">void <span class="type">LRUCache</span>::<span class="type">Prune</span><span class="literal">()</span></div><div class="line">&#123;</div><div class="line">  <span class="type">MutexLock</span> l(&amp;mutex_);</div><div class="line">  <span class="keyword">while</span> (lru_.next != &amp;lru_)</div><div class="line">  &#123;</div><div class="line">    <span class="type">LRUHandle</span> *e = lru_.next;</div><div class="line">    <span class="keyword">assert</span>(e-&gt;refs == <span class="number">1</span>);</div><div class="line">    <span class="built_in">bool</span> erased = <span class="type">FinishErase</span>(table_.<span class="type">Remove</span>(e-&gt;key<span class="literal">()</span>, e-&gt;hash));</div><div class="line">    <span class="keyword">if</span> (!erased)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">assert</span>(erased);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="ShardedLRUCache"><a href="#ShardedLRUCache" class="headerlink" title="ShardedLRUCache"></a>ShardedLRUCache</h1><p>最终，leveldb采用的是ShardedLRUCache, 它由16个LRUCache组成，根据hash值的头4位将任务划分给对应的LRUCache进行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function">Cache* <span class="title">NewLRUCache</span><span class="params">(<span class="keyword">size_t</span> capacity)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ShardedLRUCache(capacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其具体实现很简单，下面简单贴出代码:</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kNumShardBits = <span class="number">4</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kNumShards = <span class="number">1</span> &lt;&lt; kNumShardBits;</div><div class="line"></div><div class="line">class ShardedLRUCache : <span class="keyword">public</span> Cache</div><div class="line">&#123;</div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  LRUCache shard_[kNumShards];</div><div class="line">  port::Mutex id_mutex_;</div><div class="line">  uint64_t last_id_;</div><div class="line"></div><div class="line">  <span class="comment">// get hash value</span></div><div class="line">  <span class="keyword">static</span> <span class="keyword">inline</span> uint32_t HashSlice(<span class="keyword">const</span> Slice &amp;s)</div><div class="line">  &#123;</div><div class="line">    <span class="built_in">return</span> Hash(s.data(), s.<span class="built_in">size</span>(), <span class="number">0</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// in which bucket ? hash &gt;&gt; 28</span></div><div class="line">  <span class="keyword">static</span> uint32_t Shard(uint32_t hash)</div><div class="line">  &#123;</div><div class="line">    <span class="built_in">return</span> hash &gt;&gt; (<span class="number">32</span> - kNumShardBits);</div><div class="line">  &#125;</div><div class="line"></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">explicit</span> ShardedLRUCache(size_t capacity)</div><div class="line">      : last_id_(<span class="number">0</span>)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">const</span> size_t per_shard = (capacity + (kNumShards - <span class="number">1</span>)) / kNumShards;</div><div class="line">    <span class="built_in">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; kNumShards; s++)</div><div class="line">    &#123;</div><div class="line">      shard_[s].SetCapacity(per_shard);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> ~ShardedLRUCache() &#123;&#125;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> Handle *Insert(<span class="keyword">const</span> Slice &amp;key, <span class="keyword">void</span> *value, size_t charge, <span class="keyword">void</span>(*deleter)(<span class="keyword">const</span> Slice &amp;key, <span class="keyword">void</span> *value))</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">const</span> uint32_t hash = HashSlice(key);</div><div class="line">    <span class="built_in">return</span> shard_[Shard(hash)].Insert(key, hash, value, charge, deleter);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> Handle *Lookup(<span class="keyword">const</span> Slice &amp;key)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">const</span> uint32_t hash = HashSlice(key);</div><div class="line">    <span class="built_in">return</span> shard_[Shard(hash)].Lookup(key, hash);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keyword">void</span> Release(Handle *handle)</div><div class="line">  &#123;</div><div class="line">    LRUHandle *h = <span class="keyword">reinterpret_cast</span>&lt;LRUHandle *&gt;(handle);</div><div class="line">    shard_[Shard(h-&gt;hash)].Release(handle);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keyword">void</span> Erase(<span class="keyword">const</span> Slice&amp; key)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">const</span> uint32_t hash = HashSlice(key);</div><div class="line">    shard_[Shard(hash)].Erase(key, hash);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keyword">void</span> *Value(Handle *handle)</div><div class="line">  &#123;</div><div class="line">    <span class="built_in">return</span> <span class="keyword">reinterpret_cast</span>&lt;LRUHandle *&gt;(handle)-&gt;value;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> uint64_t NewId()</div><div class="line">  &#123;</div><div class="line">    MutexLock l(&amp;id_mutex_);</div><div class="line">    <span class="built_in">return</span> ++(last_id_);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keyword">void</span> Prune()</div><div class="line">  &#123;</div><div class="line">    <span class="built_in">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; kNumShards; s++)</div><div class="line">    &#123;</div><div class="line">      shard_[s].Prune();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> size_t TotalCharge() <span class="keyword">const</span></div><div class="line">  &#123;</div><div class="line">    size_t total = <span class="number">0</span>;</div><div class="line">    <span class="built_in">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt; kNumShards; s++)</div><div class="line">    &#123;</div><div class="line">      total += shard_[s].TotalCharge();</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">return</span> total;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb compaction分析]]></title>
      <url>/2017/06/24/leveldb-compaction%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在leveldb中，为了保证读操作能够访问更少的sstable文件，倾向于将sstable从低的level推向高的level。level为0的sstable之间可能key的范围有重叠，而其他level上的文件的key的范围没有重叠。level从低到高，其空间限制也由小到大，更高的level允许容纳更多的sstable文件。当某个level上的sstable文件空间超出限定值，或者在访问过程中遇到的某个key与两个以上level的文件范围发生重叠，且达到一定阈值，都会进行compaction操作。当然，compaction操作也允许手动启动，db在启动的时候也会主动触发compaction操作。</p>
<h1 id="触发Compaction"><a href="#触发Compaction" class="headerlink" title="触发Compaction"></a>触发Compaction</h1><p>调用<code>MaybeScheduleCompaction</code>会触发compaction操作，但是是否真正会进行compaction则要进行一些判断。</p>
<ol>
<li>当正在进行compaction操作时，不能同时执行compaction操作。</li>
<li>在正在关闭数据库时，不能执行compaction操作。</li>
<li>当没有immutable memtable且当前版本不需要进行compaction时，不会触发compaction操作。</li>
</ol>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">void DBImpl::MaybeScheduleCompaction() &#123;</div><div class="line">  mutex_.AssertHeld();</div><div class="line">  <span class="comment">// 避免两次调用schedule compaction操作</span></div><div class="line">  <span class="keyword">if</span> (bg_compaction_scheduled_) &#123;</div><div class="line">    <span class="comment">// Already scheduled</span></div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shutting_down_.Acquire_Load()) &#123; <span class="comment">/// 若满足此条件，表示db当前正在被删除</span></div><div class="line">    <span class="comment">// DB is being deleted; no more background compactions</span></div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bg_error_.ok()) &#123;</div><div class="line">    <span class="comment">// Already got an error; no more changes</span></div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (imm_ == <span class="keyword">NULL</span> &amp;&amp; <span class="comment">//  不需要进行compaction操作</span></div><div class="line">             manual_compaction_ == <span class="keyword">NULL</span> &amp;&amp;</div><div class="line">             !versions_-&gt;NeedsCompaction()) &#123;</div><div class="line">    <span class="comment">// No work to be done</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">/// 需要进行compaction操作</span></div><div class="line">    <span class="comment">/// 记录当前正在进行compaction操作</span></div><div class="line">    bg_compaction_scheduled_ = <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/// 在后台线程中执行BGWork函数</span></div><div class="line">    env_-&gt;Schedule(&amp;DBImpl::BGWork, this);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在进入BackGroundCall函数时，会再次判断当前数据库有没有关闭。没有关闭数据库，且没有出现后台错误，则会在后台执行compaction操作。结束Compaction操作之后，因为下一个level的文件大小可能超出限制，再次触发compaction操作，同时通知等待的线程Compaction操作已经完成。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> DBImpl::BackgroundCall() &#123;</div><div class="line">  <span class="function">MutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>;</div><div class="line">  <span class="comment">/// 断言正在进行compaction</span></div><div class="line">  assert(bg_compaction_scheduled_);</div><div class="line">  <span class="comment">/// 正在关闭，返回</span></div><div class="line">  <span class="keyword">if</span> (shutting_down_.Acquire_Load()) &#123;</div><div class="line">    <span class="comment">// No more background work when shutting down.</span></div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!bg_error_.ok()) &#123;</div><div class="line">    <span class="comment">// No more background work after a background error.</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">/// 执行后台的Compaction操作</span></div><div class="line">    BackgroundCompaction();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/// 结束Compaction</span></div><div class="line">  bg_compaction_scheduled_ = <span class="literal">false</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Previous compaction may have produced too many files in a level,</span></div><div class="line">  <span class="comment">// so reschedule another compaction if needed.</span></div><div class="line">  <span class="comment">///  再次尝试compaction</span></div><div class="line">  <span class="comment">/// 前一次compaction操作可能在同一个level上产生了过多的文件，超出了相应的size限制，</span></div><div class="line">  <span class="comment">/// 所以再次执行MaybeScheduleCompaction()以触发compaction</span></div><div class="line">  MaybeScheduleCompaction();</div><div class="line">  <span class="comment">/// 通知等待的线程(在析构的时候，析构操作所在的线程会等待compaction操作完成)</span></div><div class="line">  bg_cv_.SignalAll();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Compaction流程"><a href="#Compaction流程" class="headerlink" title="Compaction流程"></a>Compaction流程</h1><p>如果当前存在immutable memtable，将其dump称为level 0 sstable，返回。</p>
<p>如果存在外部触发的compaction操作，通过<code>manual_compaction</code>指定的level和范围选出Compaction。若指定的key的范围很大，而每次compaction操作输入的文件大小有限制，<code>manual_compaction</code>可能不会一次完成，所以有done来记录是否全部完成。<code>tmp_storage</code>保存上一次compact到的<code>end-key</code>，即下一次的start key。</p>
<p>否则，根据数据库的当前状态，选出Compaction。如果不是手动的compaction操作，并且此次compaction操作只需要将level-n上的输入文件简单地移动到level-n+1上，更新Version信息并写入到manifest文件。否则，继续执行compaction操作。</p>
<p>在compaction操作完成之后，会进行清理工作，复原输入文件的引用计数，同时删除当前版本控制所不需要的文件。如果是手动compaction操作，且compaction操作没有一次完成，会更新下一次compaction操作开始的key。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// 在此处执行compaction相关操作</span></div><div class="line">void DBImpl::BackgroundCompaction() &#123;</div><div class="line">  mutex_.AssertHeld();</div><div class="line"></div><div class="line">  <span class="comment">/// immutable memtable exists, dump to level-0 table</span></div><div class="line">  <span class="keyword">if</span> (imm_ != NULL) &#123;</div><div class="line">    CompactMemTable();</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Compaction* c;</div><div class="line">  <span class="comment">/// 是手动的compaction操作吗？</span></div><div class="line">  bool is_manual = (manual_compaction_ != NULL);</div><div class="line">  InternalKey manual_end;</div><div class="line">  <span class="keyword">if</span> (is_manual) &#123;</div><div class="line">    ManualCompaction* m = manual_compaction_;</div><div class="line">    <span class="comment">/// 根据manual_compaction_指定的level/start_key/end_key选出compaction</span></div><div class="line">    <span class="function"><span class="title">c</span> = versions_-&gt;</span>C<span class="function"><span class="title">ompactRange</span>(m-&gt;</span><span class="function"><span class="title">level</span>, m-&gt;</span><span class="function"><span class="title">begin</span>, m-&gt;</span>end);</div><div class="line">    <span class="function"><span class="title">m</span>-&gt;</span>done = (c == NULL);</div><div class="line">    <span class="keyword">if</span> (c != NULL) &#123;</div><div class="line">      <span class="comment">/// 输入的第一个level文件的最大值</span></div><div class="line">      <span class="function"><span class="title">manual_end</span> = c-&gt;</span><span class="function"><span class="title">input</span>(0, c-&gt;</span><span class="function"><span class="title">num_input_files</span>(0) - 1)-&gt;</span>largest;</div><div class="line">    &#125;</div><div class="line">    Log(options_.info_log,</div><div class="line">        <span class="string">"Manual compaction at level-%d from %s .. %s; will stop at %s\n"</span>,</div><div class="line">        <span class="function"><span class="title">m</span>-&gt;</span>level,</div><div class="line">        (<span class="function"><span class="title">m</span>-&gt;</span><span class="function"><span class="title">begin</span> ? m-&gt;</span><span class="function"><span class="title">begin</span>-&gt;</span>DebugString().c_str() : <span class="string">"(begin)"</span>),</div><div class="line">        (<span class="function"><span class="title">m</span>-&gt;</span><span class="function"><span class="title">end</span> ? m-&gt;</span><span class="function"><span class="title">end</span>-&gt;</span>DebugString().c_str() : <span class="string">"(end)"</span>),</div><div class="line">        (<span class="function"><span class="title">m</span>-&gt;</span>done ? <span class="string">"(end)"</span> : manual_end.DebugString().c_str()));</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">/// 根据db当前的状态，选取并进行compaction操作</span></div><div class="line">    <span class="function"><span class="title">c</span> = versions_-&gt;</span>PickCompaction();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Status status;</div><div class="line">  <span class="comment">/// 没有compaction任务</span></div><div class="line">  <span class="keyword">if</span> (c == NULL) &#123;</div><div class="line">    <span class="comment">// Nothing to do</span></div><div class="line">    <span class="comment">/// 不是manual compact并且只需要简单地将level上的文件移动到level+1层</span></div><div class="line">  &#125; <span class="function"><span class="title">else</span> <span class="keyword">if</span> (!is_manual &amp;&amp; c-&gt;</span>IsTrivialMove()) &#123;</div><div class="line">    <span class="comment">// Move file to next level</span></div><div class="line">    <span class="function"><span class="title">assert</span>(c-&gt;</span>num_input_files(<span class="number">0</span>) == <span class="number">1</span>);</div><div class="line">    F<span class="function"><span class="title">ileMetaData</span>* f = c-&gt;</span>input(<span class="number">0</span>, <span class="number">0</span>);</div><div class="line">    <span class="comment">/// 标记此文件删除</span></div><div class="line">    <span class="function"><span class="title">c</span>-&gt;</span><span class="function"><span class="title">edit</span>()-&gt;</span>D<span class="function"><span class="title">eleteFile</span>(c-&gt;</span><span class="function"><span class="title">level</span>(), f-&gt;</span>number);</div><div class="line">    <span class="comment">/// 将此文件添加到level + 1</span></div><div class="line">    <span class="function"><span class="title">c</span>-&gt;</span><span class="function"><span class="title">edit</span>()-&gt;</span>A<span class="function"><span class="title">ddFile</span>(c-&gt;</span><span class="function"><span class="title">level</span>() + 1, f-&gt;</span><span class="function"><span class="title">number</span>, f-&gt;</span>file_size,</div><div class="line">                       <span class="function"><span class="title">f</span>-&gt;</span><span class="function"><span class="title">smallest</span>, f-&gt;</span>largest);</div><div class="line">    <span class="comment">/// 更新manifest文件</span></div><div class="line">    <span class="function"><span class="title">status</span> = versions_-&gt;</span>L<span class="function"><span class="title">ogAndApply</span>(c-&gt;</span>edit(), &amp;mutex_);</div><div class="line">    <span class="keyword">if</span> (!status.ok()) &#123;</div><div class="line">      RecordBackgroundError(status);</div><div class="line">    &#125;</div><div class="line">    VersionSet::LevelSummaryStorage tmp;</div><div class="line">    Log(options_.info_log, <span class="string">"Moved #%lld to level-%d %lld bytes %s: %s\n"</span>,</div><div class="line">        <span class="function"><span class="title">static_cast</span>&lt;unsigned long long&gt;(f-&gt;</span>number),</div><div class="line">        <span class="function"><span class="title">c</span>-&gt;</span>level() + <span class="number">1</span>,</div><div class="line">        <span class="function"><span class="title">static_cast</span>&lt;unsigned long long&gt;(f-&gt;</span>file_size),</div><div class="line">        status.ToString().c_str(),</div><div class="line">        <span class="function"><span class="title">versions_</span>-&gt;</span>LevelSummary(&amp;tmp));</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    CompactionState* compact = new CompactionState(c);</div><div class="line">    <span class="comment">///!!! 进行compaction 操作</span></div><div class="line">    status = DoCompactionWork(compact);</div><div class="line">    <span class="keyword">if</span> (!status.ok()) &#123;</div><div class="line">      <span class="comment">/// 在后台记录错误，并完成通知</span></div><div class="line">      RecordBackgroundError(status);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/// 进行清理操作</span></div><div class="line">    CleanupCompaction(compact);</div><div class="line">    <span class="comment">/// release input version</span></div><div class="line">    <span class="function"><span class="title">c</span>-&gt;</span>ReleaseInputs();</div><div class="line">    <span class="comment">/// 删除无用的文件</span></div><div class="line">    DeleteObsoleteFiles();</div><div class="line">  &#125;</div><div class="line">  delete c;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (status.ok()) &#123;</div><div class="line">    <span class="comment">// Done</span></div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shutting_down_.Acquire_Load()) &#123;</div><div class="line">    <span class="comment">// Ignore compaction errors found during shutting down</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    Log(options_.info_log,</div><div class="line">        <span class="string">"Compaction error: %s"</span>, status.ToString().c_str());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (is_manual) &#123;</div><div class="line">    ManualCompaction* m = manual_compaction_;</div><div class="line">    <span class="keyword">if</span> (!status.ok()) &#123;</div><div class="line">      <span class="function"><span class="title">m</span>-&gt;</span>done = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="title">if</span> (!m-&gt;</span>done) &#123;</div><div class="line">      <span class="comment">// We only compacted part of the requested range.  Update *m</span></div><div class="line">      <span class="comment">// to the range that is left to be compacted.</span></div><div class="line">      <span class="function"><span class="title">m</span>-&gt;</span>tmp_storage = manual_end;</div><div class="line">      <span class="comment">/// 记录下一次compaction的开始位置</span></div><div class="line">      <span class="function"><span class="title">m</span>-&gt;</span><span class="function"><span class="title">begin</span> = &amp;m-&gt;</span>tmp_storage;</div><div class="line">    &#125;</div><div class="line">    manual_compaction_ = NULL;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="DoCompactionWork"><a href="#DoCompactionWork" class="headerlink" title="DoCompactionWork"></a>DoCompactionWork</h1><p>实际的compaction过程就是对多个已经排序的sstable做一次merge排序，丢弃已经删除的key，或者重复且当前版本控制所不需要的key。</p>
<p>将选出的Compaction中输入的sstable的Iterator组合成为一个单一的Iterator。使用迭代器遍历访问数据库中的每一个值。在循环之中，检查并且优先compact存在的immutable memtable。如果当前key与grandparent层重叠的文件超过阈值，结束输出此sstable文件。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (has_imm_.NoBarrier_Load() != <span class="keyword">NULL</span>) &#123;</div><div class="line">  <span class="keyword">const</span> uint64_t imm_start = env_-&gt;NowMicros();</div><div class="line">  mutex_.Lock();</div><div class="line">  <span class="comment">/// 检查并优先compact存在的immutable memtable</span></div><div class="line">  <span class="keyword">if</span> (imm_ != <span class="keyword">NULL</span>) &#123;</div><div class="line">    <span class="comment">/// 执行对memtable的compaction的操作</span></div><div class="line">    CompactMemTable();</div><div class="line">    bg_cv_.SignalAll();  <span class="comment">// Wakeup MakeRoomForWrite() if necessary</span></div><div class="line">  &#125;</div><div class="line">  mutex_.Unlock();</div><div class="line">  imm_micros += (env_-&gt;NowMicros() - imm_start);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/// 如果当前与grandparent层产生overlap的size超过阈值，立即结束当前写入的sstable</span></div><div class="line">Slice key = input-&gt;key();</div><div class="line"><span class="keyword">if</span> (compact-&gt;compaction-&gt;ShouldStopBefore(key) &amp;&amp;</div><div class="line">    compact-&gt;builder != <span class="keyword">NULL</span>) &#123;</div><div class="line">  <span class="comment">/// 停止输出compaction文件</span></div><div class="line">  status = FinishCompactionOutputFile(compact, input);</div><div class="line">  <span class="keyword">if</span> (!status.ok()) &#123;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当前遍历到的key不是第一次出现，且前一个相同key的sequence number小于等于<code>smallest_snapshot</code>，说明当前版本控制不再需要这个重复的key，将其删除。当key的类型是删除，且其sequence小于等于<code>smallest_snapshot</code>，并且更高level的文件之中没有这个key，也将其删除。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// 若sequence number 小于 snapshot list中最小的那个sequence number</span></div><div class="line"><span class="comment">/// 第一次出现的key，其last_sequence_for_key被赋值为kMaxSequenceNumber，不会触发删除</span></div><div class="line"><span class="keyword">if</span> (last_sequence_for_key &lt;= compact-&gt;smallest_snapshot) &#123;</div><div class="line">  <span class="comment">// Hidden by an newer entry for same user key</span></div><div class="line">  <span class="built_in">drop</span> = <span class="literal">true</span>;    <span class="comment">// (A)</span></div><div class="line">&#125;</div><div class="line">  <span class="comment">/// key的类型为删除，且其sequence &lt;= compact-&gt;smallest_snapshot，</span></div><div class="line">  <span class="comment">/// 且在更高level没有这个key，那么也可以将其删除</span></div><div class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ikey.<span class="keyword">type</span> == kTypeDeletion &amp;&amp;</div><div class="line">           ikey.sequence &lt;= compact-&gt;smallest_snapshot &amp;&amp;</div><div class="line">           compact-&gt;compaction-&gt;IsBaseLevelForKey(ikey.user_key)) &#123;</div><div class="line">  <span class="comment">// For this user key:</span></div><div class="line">  <span class="comment">// (1) there is no data in higher levels</span></div><div class="line">  <span class="comment">// (2) data in lower levels will have larger sequence numbers</span></div><div class="line">  <span class="comment">// (3) data in layers that are being compacted here and have</span></div><div class="line">  <span class="comment">//     smaller sequence numbers will be dropped in the next</span></div><div class="line">  <span class="comment">//     few iterations of this loop (by rule (A) above).</span></div><div class="line">  <span class="comment">// Therefore this deletion marker is obsolete and can be dropped.</span></div><div class="line">  <span class="built_in">drop</span> = <span class="literal">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果需要建立新的sstable，会生成新的sstable，将不丢弃的key写入。如果当前sstable的大小达到阈值，也会结束输出。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Open output file if necessary</span></div><div class="line"><span class="function"><span class="title">if</span> (compact-&gt;</span>builder == NULL) &#123;</div><div class="line">  <span class="comment">/// 生成新的sstable</span></div><div class="line">  status = OpenCompactionOutputFile(compact);</div><div class="line">  <span class="keyword">if</span> (!status.ok()) &#123;</div><div class="line">    break;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/// 记录最小值</span></div><div class="line"><span class="function"><span class="title">if</span> (compact-&gt;</span><span class="function"><span class="title">builder</span>-&gt;</span>NumEntries() == <span class="number">0</span>) &#123;</div><div class="line">  <span class="function"><span class="title">compact</span>-&gt;</span><span class="function"><span class="title">current_output</span>()-&gt;</span>smallest.DecodeFrom(key);</div><div class="line">&#125;</div><div class="line"><span class="comment">/// 记录最大值</span></div><div class="line"><span class="function"><span class="title">compact</span>-&gt;</span><span class="function"><span class="title">current_output</span>()-&gt;</span>largest.DecodeFrom(key);</div><div class="line"><span class="comment">/// 将不丢弃的key的数据写入sstable</span></div><div class="line"><span class="function"><span class="title">compact</span>-&gt;</span><span class="function"><span class="title">builder</span>-&gt;</span>A<span class="function"><span class="title">dd</span>(key, input-&gt;</span>value());</div><div class="line"></div><div class="line"><span class="comment">// Close output file if it is big enough</span></div><div class="line"><span class="comment">/// 如果当前输出的sstable 的大小达到阈值(默认2MB)，结束此sstable文件</span></div><div class="line"><span class="function"><span class="title">if</span> (compact-&gt;</span><span class="function"><span class="title">builder</span>-&gt;</span>FileSize() &gt;=</div><div class="line">    <span class="function"><span class="title">compact</span>-&gt;</span><span class="function"><span class="title">compaction</span>-&gt;</span>MaxOutputFileSize()) &#123;</div><div class="line">  status = FinishCompactionOutputFile(compact, input);</div><div class="line">  <span class="keyword">if</span> (!status.ok()) &#123;</div><div class="line">    break;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在compaction操作生成所有合并之后的sstable文件之后，会记录相关的统计信息，同时安装新生成的文件到当前版本。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// 更新compaction操作统计信息</span></div><div class="line">CompactionStats stats;</div><div class="line"><span class="function"><span class="title">stats</span>.micros = env_-&gt;</span>NowMicros() - start_micros - imm_micros;</div><div class="line"><span class="keyword">for</span> (int which = <span class="number">0</span>; which &lt; <span class="number">2</span>; which++) &#123;</div><div class="line">  <span class="function"><span class="title">for</span> (int i = 0; i &lt; compact-&gt;</span><span class="function"><span class="title">compaction</span>-&gt;</span>num_input_files(which); i++) &#123;</div><div class="line">    <span class="function"><span class="title">stats</span>.bytes_read += compact-&gt;</span><span class="function"><span class="title">compaction</span>-&gt;</span><span class="function"><span class="title">input</span>(which, i)-&gt;</span>file_size;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="title">for</span> (size_t i = 0; i &lt; compact-&gt;</span>outputs.size(); i++) &#123;</div><div class="line">  <span class="function"><span class="title">stats</span>.bytes_written += compact-&gt;</span>outputs[i].file_size;</div><div class="line">&#125;</div><div class="line"></div><div class="line">mutex_.Lock();</div><div class="line"><span class="function"><span class="title">stats_</span>[compact-&gt;</span><span class="function"><span class="title">compaction</span>-&gt;</span>level() + <span class="number">1</span>].Add(stats);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (status.ok()) &#123;</div><div class="line">  <span class="comment">/// 安装compaction之后产生的新文件</span></div><div class="line">  status = InstallCompactionResults(compact);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="db阅读顺序"><a href="#db阅读顺序" class="headerlink" title="db阅读顺序"></a>db阅读顺序</h1><p>至此，leveldb的源码阅读完毕，我对google编程规范有了更加清晰的认知，熟悉了leveldb的核心思想，特别是对于compaction的处理，以及各种类型的Iterator如何组合起来对外服务。leveldb之中良好定义的抽象接口，接口与实现分离的思想也让我感触良多。</p>
<p>在leveldb之中，db路径下的代码是重中之重，也是最难以理解的，以下是我的阅读顺序。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fgwjst1ilnj306q0tjmxl.jpg" alt=""></p>
<p>我已经将包含注释的源代码上传到我的<a href="https://github.com/zhoudayang/leveldb" target="_blank" rel="external">github</a>。</p>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb Open和Write流程]]></title>
      <url>/2017/06/24/leveldb-Open%E5%92%8CWrite%E6%B5%81%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h1 id="Open"><a href="#Open" class="headerlink" title="Open"></a>Open</h1><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>在leveldb中，DB接口的实现在DBImpl对象中。打开数据库的时候，首先创建DBImpl对象，在这里会初始化各成员，对输入的option选项进行规范化，创建缓存sstable对象的<code>table_cache_</code>，同时创建VersionSet对象用于管理数据库版本。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">DBImpl::DBImpl(<span class="keyword">const</span> Options&amp; raw_options, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname)</div><div class="line">    : env_(raw_options.env),</div><div class="line">      internal_comparator_(raw_options.comparator),</div><div class="line">      internal_filter_policy_(raw_options.filter_policy),</div><div class="line">      options_(SanitizeOptions(dbname, &amp;internal_comparator_,</div><div class="line">                               &amp;internal_filter_policy_, raw_options)),</div><div class="line">      <span class="comment">/// 是否拥有info_log</span></div><div class="line">      owns_info_log_(options_.info_log != raw_options.info_log),</div><div class="line">      <span class="comment">/// 是否拥有cache</span></div><div class="line">      owns_cache_(options_.block_cache != raw_options.block_cache),</div><div class="line">      dbname_(dbname),</div><div class="line">      db_lock_(<span class="literal">NULL</span>),</div><div class="line">      shutting_down_(<span class="literal">NULL</span>),</div><div class="line">      bg_cv_(&amp;mutex_), <span class="comment">// background condition variable</span></div><div class="line">      mem_(<span class="literal">NULL</span>), <span class="comment">// memtable</span></div><div class="line">      imm_(<span class="literal">NULL</span>), <span class="comment">// immutable memtable</span></div><div class="line">      logfile_(<span class="literal">NULL</span>), <span class="comment">// log file descriptor</span></div><div class="line">      logfile_number_(<span class="number">0</span>), <span class="comment">// log file number</span></div><div class="line">      log_(<span class="literal">NULL</span>), <span class="comment">// logger</span></div><div class="line">      seed_(<span class="number">0</span>),</div><div class="line">      tmp_batch_(<span class="keyword">new</span> WriteBatch), <span class="comment">// temp batch</span></div><div class="line">      bg_compaction_scheduled_(<span class="literal">false</span>), <span class="comment">// 当前是否正有后台compaction正在运行</span></div><div class="line">      manual_compaction_(<span class="literal">NULL</span>) &#123; <span class="comment">// 指代手动compaction操作</span></div><div class="line">  has_imm_.Release_Store(<span class="literal">NULL</span>); <span class="comment">// no immutable memtable</span></div><div class="line"></div><div class="line">  <span class="comment">// Reserve ten files or so for other uses and give the rest to TableCache.</span></div><div class="line">  <span class="comment">/// 990</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">int</span> table_cache_size = options_.max_open_files - kNumNonTableCacheFiles;</div><div class="line">  <span class="comment">/// sstable handle cache</span></div><div class="line">  table_cache_ = <span class="keyword">new</span> TableCache(dbname_, &amp;options_, table_cache_size);</div><div class="line"></div><div class="line">  <span class="comment">// create version set object</span></div><div class="line">  versions_ = <span class="keyword">new</span> VersionSet(dbname_, &amp;options_, table_cache_,</div><div class="line">                             &amp;internal_comparator_);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来进入Recover函数，首先尝试对LOCK文件进行上锁，确保只有一个leveldb实例正在数据库路径上运行。若CURRENT文件并不存在，则表明数据库未初始化，根据设置，若启用了<code>create_if_missing</code>选项，则会进行初始化操作。紧接着从manifest文件之中得到之前数据库实例最新的版本信息。根据版本信息，就可以检查数据库路径下是否存在文件缺失。若无缺失，则从log文件之中恢复memtable内保存的数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div></pre></td><td class="code"><pre><div class="line">Status DBImpl::Recover(VersionEdit* edit, <span class="keyword">bool</span> *save_manifest) &#123;</div><div class="line">  mutex_.AssertHeld();</div><div class="line"></div><div class="line">  <span class="comment">// Ignore error from CreateDir since the creation of the DB is</span></div><div class="line">  <span class="comment">// committed only when the descriptor is created, and this directory</span></div><div class="line">  <span class="comment">// may already exist from a previous failed creation attempt.</span></div><div class="line">  <span class="comment">/// 创建路径，名称为dbname_</span></div><div class="line">  env_-&gt;CreateDir(dbname_);</div><div class="line">  assert(db_lock_ == <span class="literal">NULL</span>);</div><div class="line">  <span class="comment">/// 持有文件锁, 表明当前数据库正在工作中</span></div><div class="line">  Status s = env_-&gt;LockFile(LockFileName(dbname_), &amp;db_lock_);</div><div class="line">  <span class="keyword">if</span> (!s.ok()) &#123;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/// current文件不存在</span></div><div class="line">  <span class="keyword">if</span> (!env_-&gt;FileExists(CurrentFileName(dbname_))) &#123;</div><div class="line">    <span class="comment">/// 当缺失时创建</span></div><div class="line">    <span class="keyword">if</span> (options_.create_if_missing) &#123;</div><div class="line">      <span class="comment">/// 初始化数据库</span></div><div class="line">      s = NewDB();</div><div class="line">      <span class="keyword">if</span> (!s.ok()) &#123;</div><div class="line">        <span class="keyword">return</span> s;</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">/// 数据库不存在</span></div><div class="line">      <span class="keyword">return</span> Status::InvalidArgument(</div><div class="line">          dbname_, <span class="string">"does not exist (create_if_missing is false)"</span>);</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">/// 数据库已经存在</span></div><div class="line">    <span class="keyword">if</span> (options_.error_if_exists) &#123;</div><div class="line">      <span class="keyword">return</span> Status::InvalidArgument(</div><div class="line">          dbname_, <span class="string">"exists (error_if_exists is true)"</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 从manifest文件之中恢复Version设置</span></div><div class="line">  s = versions_-&gt;Recover(save_manifest);</div><div class="line">  <span class="keyword">if</span> (!s.ok()) &#123;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">  &#125;</div><div class="line">  <span class="function">SequenceNumber <span class="title">max_sequence</span><span class="params">(<span class="number">0</span>)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">// Recover from all newer log files than the ones named in the</span></div><div class="line">  <span class="comment">// descriptor (new log files may have been added by the previous</span></div><div class="line">  <span class="comment">// incarnation without registering them in the descriptor).</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="comment">// Note that PrevLogNumber() is no longer used, but we pay</span></div><div class="line">  <span class="comment">// attention to it in case we are recovering a database</span></div><div class="line">  <span class="comment">// produced by an older version of leveldb.</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> min_log = versions_-&gt;LogNumber();</div><div class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> prev_log = versions_-&gt;PrevLogNumber();</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; filenames;</div><div class="line">  <span class="comment">/// 获取数据库路径下的所有文件</span></div><div class="line">  s = env_-&gt;GetChildren(dbname_, &amp;filenames);</div><div class="line">  <span class="keyword">if</span> (!s.ok()) &#123;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">uint64_t</span>&gt; expected;</div><div class="line">  <span class="comment">/// 得到当前所有文件对应的numbers</span></div><div class="line">  versions_-&gt;AddLiveFiles(&amp;expected);</div><div class="line">  <span class="keyword">uint64_t</span> number;</div><div class="line">  FileType type;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint64_t</span>&gt; logs;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; filenames.size(); i++) &#123;</div><div class="line">    <span class="keyword">if</span> (ParseFileName(filenames[i], &amp;number, &amp;type)) &#123;</div><div class="line">      expected.erase(number);</div><div class="line">      <span class="keyword">if</span> (type == kLogFile &amp;&amp; ((number &gt;= min_log) || (number == prev_log)))</div><div class="line">        <span class="comment">/// 记录log文件对应的number</span></div><div class="line">        logs.push_back(number);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">/// 缺失了文件, 崩溃</span></div><div class="line">  <span class="keyword">if</span> (!expected.empty()) &#123;</div><div class="line">    <span class="keyword">char</span> buf[<span class="number">50</span>];</div><div class="line">    <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"%d missing files; e.g."</span>,</div><div class="line">             <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(expected.size()));</div><div class="line">    <span class="keyword">return</span> Status::Corruption(buf, TableFileName(dbname_, *(expected.begin())));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Recover in the order in which the logs were generated</span></div><div class="line">  <span class="built_in">std</span>::sort(logs.begin(), logs.end());</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; logs.size(); i++) &#123;</div><div class="line">    <span class="comment">/// 从log文件之中恢复          是最后一个log文件吗？</span></div><div class="line">    s = RecoverLogFile(logs[i], (i == logs.size() - <span class="number">1</span>), save_manifest, edit,</div><div class="line">                       &amp;max_sequence);</div><div class="line">    <span class="keyword">if</span> (!s.ok()) &#123;</div><div class="line">      <span class="keyword">return</span> s;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// The previous incarnation may not have written any MANIFEST</span></div><div class="line">    <span class="comment">// records after allocating this log number.  So we manually</span></div><div class="line">    <span class="comment">// update the file number allocation counter in VersionSet.</span></div><div class="line">    <span class="comment">/// 标识此log文件编号已经使用</span></div><div class="line">    versions_-&gt;MarkFileNumberUsed(logs[i]);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/// 设置最大的序列号</span></div><div class="line">  <span class="keyword">if</span> (versions_-&gt;LastSequence() &lt; max_sequence) &#123;</div><div class="line">    versions_-&gt;SetLastSequence(max_sequence);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> Status::OK();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>恢复完成之后，若memtable为NULL，创建并且为其设置log。写入到memtable的数据都会追加到log文件之中以记录。然后更新版本信息，写入到manifest文件。最后尝试删除无用的文件，同时触发compaction操作。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">Status DB::Open(<span class="keyword">const</span> Options&amp; options, <span class="keyword">const</span> std::string&amp; dbname,</div><div class="line">                DB** dbptr) &#123;</div><div class="line">  *dbptr = NULL;</div><div class="line">  <span class="comment">// 创建DBImpl对象</span></div><div class="line">  DBImpl* <span class="keyword">impl</span> = new DBImpl(options, dbname);</div><div class="line">  <span class="keyword">impl</span>-&gt;mutex_.Lock();</div><div class="line">  VersionEdit edit;</div><div class="line">  <span class="comment">// Recover handles create_if_missing, error_if_exists</span></div><div class="line">  <span class="built_in">bool</span> save_manifest = <span class="literal">false</span>;</div><div class="line">  <span class="comment">/// 尝试读取record, 从log文件之中恢复</span></div><div class="line">  Status s = <span class="keyword">impl</span>-&gt;Recover(&amp;edit, &amp;save_manifest);</div><div class="line">  <span class="keyword">if</span> (s.ok() &amp;&amp; <span class="keyword">impl</span>-&gt;mem_ == NULL) &#123;</div><div class="line">    <span class="comment">// Create new log and a corresponding memtable.</span></div><div class="line">    uint64_t new_log_number = <span class="keyword">impl</span>-&gt;versions_-&gt;NewFileNumber();</div><div class="line">    WritableFile* lfile;</div><div class="line">    s = options.env-&gt;NewWritableFile(LogFileName(dbname, new_log_number),</div><div class="line">                                     &amp;lfile);</div><div class="line">    <span class="keyword">if</span> (s.ok()) &#123;</div><div class="line">      edit.SetLogNumber(new_log_number);</div><div class="line">      <span class="comment">/// set logfile_</span></div><div class="line">      <span class="keyword">impl</span>-&gt;logfile_ = lfile;</div><div class="line">      <span class="comment">/// set logfile_number_</span></div><div class="line">      <span class="keyword">impl</span>-&gt;logfile_number_ = new_log_number;</div><div class="line">      <span class="comment">/// set log_</span></div><div class="line">      <span class="keyword">impl</span>-&gt;log_ = new log::Writer(lfile);</div><div class="line">      <span class="comment">/// set memtable</span></div><div class="line">      <span class="keyword">impl</span>-&gt;mem_ = new MemTable(<span class="keyword">impl</span>-&gt;internal_comparator_);</div><div class="line">      <span class="comment">/// 增加引用计数</span></div><div class="line">      <span class="keyword">impl</span>-&gt;mem_-&gt;Ref();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">/// save_manifest记录了当前是否需要进行compaction操作</span></div><div class="line">  <span class="keyword">if</span> (s.ok() &amp;&amp; save_manifest) &#123;</div><div class="line">    edit.SetPrevLogNumber(<span class="number">0</span>);  <span class="comment">// No older logs needed after recovery.</span></div><div class="line">    edit.SetLogNumber(<span class="keyword">impl</span>-&gt;logfile_number_);</div><div class="line">    <span class="comment">// 将edit应用到当前version，并且保存到manifest文件</span></div><div class="line">    s = <span class="keyword">impl</span>-&gt;versions_-&gt;LogAndApply(&amp;edit, &amp;<span class="keyword">impl</span>-&gt;mutex_);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (s.ok()) &#123;</div><div class="line">    <span class="comment">/// 删除无用文件</span></div><div class="line">    <span class="keyword">impl</span>-&gt;DeleteObsoleteFiles();</div><div class="line">    <span class="comment">// 触发compaction操作</span></div><div class="line">    <span class="keyword">impl</span>-&gt;MaybeScheduleCompaction();</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">impl</span>-&gt;mutex_.Unlock();</div><div class="line">  <span class="keyword">if</span> (s.ok()) &#123;</div><div class="line">    assert(<span class="keyword">impl</span>-&gt;mem_ != NULL);</div><div class="line">    *dbptr = <span class="keyword">impl</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    delete <span class="keyword">impl</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> s;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="RecoverLogFile"><a href="#RecoverLogFile" class="headerlink" title="RecoverLogFile"></a>RecoverLogFile</h2><p>从log文件中恢复时，会从log文件之中遍历读取WriteBatch数据，将其中记载的操作作用在memtable上面。若memtable的大小超出设定值，则将memtable dump成为level-0 table。在遍历log文件的过程之中，会根据当前log文件设置<code>log_</code>和<code>logfile_number_</code>。只有当设定允许重用log文件，且不存在从memtable dump到sstable，才会允许复用log文件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Status DBImpl::RecoverLogFile(<span class="keyword">uint64_t</span> log_number, <span class="keyword">bool</span> last_log,</div><div class="line">                              <span class="keyword">bool</span>* save_manifest, VersionEdit* edit,</div><div class="line">                              SequenceNumber* max_sequence) &#123;</div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LogReporter</span> :</span> <span class="keyword">public</span> <span class="built_in">log</span>::Reader::Reporter &#123;</div><div class="line">    Env* env;</div><div class="line">    Logger* info_log;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* fname;</div><div class="line">    Status* status;  <span class="comment">// NULL if options_.paranoid_checks==false</span></div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Corruption</span><span class="params">(<span class="keyword">size_t</span> bytes, <span class="keyword">const</span> Status&amp; s)</span> </span>&#123;</div><div class="line">      Log(info_log, <span class="string">"%s%s: dropping %d bytes; %s"</span>,</div><div class="line">          (<span class="keyword">this</span>-&gt;status == <span class="literal">NULL</span> ? <span class="string">"(ignoring error) "</span> : <span class="string">""</span>),</div><div class="line">          fname, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(bytes), s.ToString().c_str());</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;status != <span class="literal">NULL</span> &amp;&amp; <span class="keyword">this</span>-&gt;status-&gt;ok()) *<span class="keyword">this</span>-&gt;status = s;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  mutex_.AssertHeld();</div><div class="line"></div><div class="line">  <span class="comment">// Open the log file</span></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> fname = LogFileName(dbname_, log_number);</div><div class="line">  SequentialFile* file;</div><div class="line">  Status status = env_-&gt;NewSequentialFile(fname, &amp;file);</div><div class="line">  <span class="keyword">if</span> (!status.ok()) &#123;</div><div class="line">    <span class="comment">/// 输出此错误，忽略并返回</span></div><div class="line">    MaybeIgnoreError(&amp;status);</div><div class="line">    <span class="keyword">return</span> status;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Create the log reader.</span></div><div class="line">  LogReporter reporter;</div><div class="line">  reporter.env = env_;</div><div class="line">  reporter.info_log = options_.info_log;</div><div class="line">  reporter.fname = fname.c_str();</div><div class="line">  reporter.status = (options_.paranoid_checks ? &amp;status : <span class="literal">NULL</span>);</div><div class="line">  <span class="comment">// We intentionally make log::Reader do checksumming even if</span></div><div class="line">  <span class="comment">// paranoid_checks==false so that corruptions cause entire commits</span></div><div class="line">  <span class="comment">// to be skipped instead of propagating bad information (like overly</span></div><div class="line">  <span class="comment">// large sequence numbers).</span></div><div class="line">  <span class="built_in">log</span>::<span class="function">Reader <span class="title">reader</span><span class="params">(file, &amp;reporter, <span class="literal">true</span><span class="comment">/*checksum*/</span>,</span></span></div><div class="line">                     <span class="number">0</span><span class="comment">/*initial_offset*/</span>);</div><div class="line">  Log(options_.info_log, <span class="string">"Recovering log #%llu"</span>,</div><div class="line">      (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) log_number);</div><div class="line"></div><div class="line">  <span class="comment">// Read all the records and add to a memtable</span></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> scratch;</div><div class="line">  Slice record;</div><div class="line">  WriteBatch batch;</div><div class="line">  <span class="keyword">int</span> compactions = <span class="number">0</span>; <span class="comment">// compaction执行的次数</span></div><div class="line">  MemTable* mem = <span class="literal">NULL</span>;</div><div class="line">  <span class="keyword">while</span> (reader.ReadRecord(&amp;record, &amp;scratch) &amp;&amp;</div><div class="line">         status.ok()) &#123;</div><div class="line">    <span class="comment">// log record太短了，连一个WriteBatch的头部长度都不够</span></div><div class="line">    <span class="keyword">if</span> (record.size() &lt; <span class="number">12</span>) &#123;</div><div class="line">      reporter.Corruption(</div><div class="line">          record.size(), Status::Corruption(<span class="string">"log record too small"</span>));</div><div class="line">      <span class="keyword">continue</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/// log实际上存储的就是WriteBatch</span></div><div class="line">    WriteBatchInternal::SetContents(&amp;batch, record);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (mem == <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="comment">// create memtable</span></div><div class="line">      mem = <span class="keyword">new</span> MemTable(internal_comparator_);</div><div class="line">      mem-&gt;Ref();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/// 向memtable之中插入记录</span></div><div class="line">    status = WriteBatchInternal::InsertInto(&amp;batch, mem);</div><div class="line">    MaybeIgnoreError(&amp;status);</div><div class="line">    <span class="keyword">if</span> (!status.ok()) &#123;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">const</span> SequenceNumber last_seq =</div><div class="line">        WriteBatchInternal::Sequence(&amp;batch) +</div><div class="line">        WriteBatchInternal::Count(&amp;batch) - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (last_seq &gt; *max_sequence) &#123;</div><div class="line">      <span class="comment">///更新max_sequence</span></div><div class="line">      *max_sequence = last_seq;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/// memtable的内存使用量超出4MB</span></div><div class="line">    <span class="keyword">if</span> (mem-&gt;ApproximateMemoryUsage() &gt; options_.write_buffer_size) &#123;</div><div class="line">      compactions++;</div><div class="line">      *save_manifest = <span class="literal">true</span>;</div><div class="line">      <span class="comment">/// 将memtable dump成为level0 table</span></div><div class="line">      status = WriteLevel0Table(mem, edit, <span class="literal">NULL</span>);</div><div class="line">      <span class="comment">/// 清空memtable</span></div><div class="line">      mem-&gt;Unref();</div><div class="line">      mem = <span class="literal">NULL</span>;</div><div class="line">      <span class="keyword">if</span> (!status.ok()) &#123;</div><div class="line">        <span class="comment">// Reflect errors immediately so that conditions like full</span></div><div class="line">        <span class="comment">// file-systems cause the DB::Open() to fail.</span></div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">delete</span> file;</div><div class="line"></div><div class="line">  <span class="comment">// See if we should keep reusing the last log file.</span></div><div class="line">  <span class="keyword">if</span> (status.ok() &amp;&amp; options_.reuse_logs &amp;&amp; last_log &amp;&amp; compactions == <span class="number">0</span>) &#123;</div><div class="line">    assert(logfile_ == <span class="literal">NULL</span>);</div><div class="line">    assert(log_ == <span class="literal">NULL</span>);</div><div class="line">    assert(mem_ == <span class="literal">NULL</span>);</div><div class="line">    <span class="keyword">uint64_t</span> lfile_size;</div><div class="line">    <span class="keyword">if</span> (env_-&gt;GetFileSize(fname, &amp;lfile_size).ok() &amp;&amp;</div><div class="line">        env_-&gt;NewAppendableFile(fname, &amp;logfile_).ok()) &#123;</div><div class="line">      Log(options_.info_log, <span class="string">"Reusing old log %s \n"</span>, fname.c_str());</div><div class="line">      log_ = <span class="keyword">new</span> <span class="built_in">log</span>::Writer(logfile_, lfile_size);</div><div class="line">      logfile_number_ = log_number;</div><div class="line">      <span class="keyword">if</span> (mem != <span class="literal">NULL</span>) &#123;</div><div class="line">        mem_ = mem;</div><div class="line">        mem = <span class="literal">NULL</span>;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">/// 创建memtable</span></div><div class="line">        <span class="comment">// mem can be NULL if lognum exists but was empty.</span></div><div class="line">        mem_ = <span class="keyword">new</span> MemTable(internal_comparator_);</div><div class="line">        mem_-&gt;Ref();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (mem != <span class="literal">NULL</span>) &#123;</div><div class="line">    <span class="comment">// mem did not get reused; compact it.</span></div><div class="line">    <span class="keyword">if</span> (status.ok()) &#123;</div><div class="line">      <span class="comment">/// 需要保存manifest文件</span></div><div class="line">      *save_manifest = <span class="literal">true</span>;</div><div class="line">      <span class="comment">/// 将memtable dump成为level0 table</span></div><div class="line">      status = WriteLevel0Table(mem, edit, <span class="literal">NULL</span>);</div><div class="line">    &#125;</div><div class="line">    mem-&gt;Unref();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> status;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="Write"><a href="#Write" class="headerlink" title="Write"></a>Write</h1><p>在leveldb之中，Put和Delete操作都会将操作记录在WriteBatch之中，转换为Write操作。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Convenience methods</span></div><div class="line">Status DBImpl::Put(<span class="keyword">const</span> WriteOptions&amp; o, <span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; val) &#123;</div><div class="line">  <span class="keyword">return</span> DB::Put(o, key, val);</div><div class="line">&#125;</div><div class="line"></div><div class="line">Status DBImpl::Delete(<span class="keyword">const</span> WriteOptions&amp; options, <span class="keyword">const</span> Slice&amp; key) &#123;</div><div class="line">  <span class="keyword">return</span> DB::Delete(options, key);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可能会有多个线程同时进行Write操作。leveldb会将WriteBatch操作加入队列之中，只有队列头部所在的线程来负责插入。leveldb中的写操作不是瓶颈，但是可能出现过量的写影响度的效率，所以采取一些措施来限制写。</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">Status DBImpl::MakeRoomForWrite(<span class="keyword">bool</span> force) &#123;</div><div class="line">  mutex_.AssertHeld();</div><div class="line">  assert(!writers_.<span class="keyword">empty</span>());</div><div class="line">  <span class="keyword">bool</span> allow_delay = !force;</div><div class="line">  Status s;</div><div class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (!bg_error_.ok()) &#123;</div><div class="line">      <span class="comment">// Yield previous error</span></div><div class="line">      s = bg_error_;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">///如果当前level-0中文件的数目达到kL0_SlowdownWritesTrigger阈值，则sleep进行delay。此delay只进行一次。</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (</div><div class="line">        allow_delay &amp;&amp;</div><div class="line">        versions_-&gt;NumLevelFiles(<span class="number">0</span>) &gt;= config::kL0_SlowdownWritesTrigger) &#123;</div><div class="line">      <span class="comment">// We are getting close to hitting a hard limit on the number of</span></div><div class="line">      <span class="comment">// L0 files.  Rather than delaying a single write by several</span></div><div class="line">      <span class="comment">// seconds when we hit the hard limit, start delaying each</span></div><div class="line">      <span class="comment">// individual write by 1ms to reduce latency variance.  Also,</span></div><div class="line">      <span class="comment">// this delay hands over some CPU to the compaction thread in</span></div><div class="line">      <span class="comment">// case it is sharing the same core as the writer.</span></div><div class="line">      mutex_.Unlock();</div><div class="line">      env_-&gt;SleepForMicroseconds(<span class="number">1000</span>);</div><div class="line">      allow_delay = <span class="keyword">false</span>;  <span class="comment">// Do not delay a single write more than once</span></div><div class="line">      mutex_.Lock();</div><div class="line">    &#125;</div><div class="line">      <span class="comment">/// 若当前memtable的size没有达到阈值write_buffer_size,则允许此次写</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!force &amp;&amp;</div><div class="line">               (mem_-&gt;ApproximateMemoryUsage() &lt;= options_.write_buffer_size)) &#123;</div><div class="line">      <span class="comment">// There is room in current memtable</span></div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/// 如果memtable已经达到阈值，并且immutable memtable仍然存在，等待compact dump完成</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (imm_ != <span class="keyword">NULL</span>) &#123;</div><div class="line">      <span class="comment">// We have filled up the current memtable, but the previous</span></div><div class="line">      <span class="comment">// one is still being compacted, so we wait.</span></div><div class="line">      Log(options_.info_log, <span class="string">"Current memtable full; waiting...\n"</span>);</div><div class="line">      bg_cv_.Wait();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/// 若level-0中文件数目达到kL0_StopWritesTrigger阈值，等待compact memtable完成</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (versions_-&gt;NumLevelFiles(<span class="number">0</span>) &gt;= config::kL0_StopWritesTrigger) &#123;</div><div class="line">      <span class="comment">// There are too many level-0 files.</span></div><div class="line">      Log(options_.info_log, <span class="string">"Too many L0 files; waiting...\n"</span>);</div><div class="line">      bg_cv_.Wait();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">/// 将当前memtable转为immutable memtable, 生成新的memtable和log file，主动触发compact，允许此次写</span></div><div class="line">      <span class="comment">// Attempt to switch to a new memtable and trigger compaction of old</span></div><div class="line">      assert(versions_-&gt;PrevLogNumber() == <span class="number">0</span>);</div><div class="line">      uint64_t new_log_number = versions_-&gt;NewFileNumber();</div><div class="line">      WritableFile* lfile = <span class="keyword">NULL</span>;</div><div class="line">      s = env_-&gt;NewWritableFile(LogFileName(dbname_, new_log_number), &amp;lfile);</div><div class="line">      <span class="keyword">if</span> (!s.ok()) &#123;</div><div class="line">        <span class="comment">// Avoid chewing through file number space in a tight loop.</span></div><div class="line">        versions_-&gt;ReuseFileNumber(new_log_number);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">      delete log_;</div><div class="line">      delete logfile_;</div><div class="line">      logfile_ = lfile;</div><div class="line">      logfile_number_ = new_log_number;</div><div class="line">      log_ = <span class="keyword">new</span> log::Writer(lfile);</div><div class="line">      imm_ = mem_;</div><div class="line">      has_imm_.Release_Store(imm_);</div><div class="line">      mem_ = <span class="keyword">new</span> MemTable(internal_comparator_);</div><div class="line">      mem_-&gt;Ref();</div><div class="line">      force = <span class="keyword">false</span>;   <span class="comment">// Do not force another compaction if have room</span></div><div class="line">      <span class="comment">/// 进行compact，将immutable memtable进行compact处理</span></div><div class="line">      MaybeScheduleCompaction();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> s;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>如果当前level-0的文件数目达到<code>kL0_SlowdownWritesTrigger</code>阈值，则sleep进行delay，此操作只进行一次。</li>
<li>如果当前memtable的空间没有达到阈值<code>write_buffer_size</code>，则允许此次写。</li>
<li>如果memtable大小达到阈值，且immutable memtable仍存在，则等待compaction操作完成。</li>
<li>如果level-0中的文件数目达到<code>kL0_StopWritesTrigger</code>阈值，则等待compaction完成。</li>
<li>上述条件均不满足，即memtable已经写满，且immutable memtable不存在，则将当前的memtable转为immutable memtable，生成新的memtable和log file，触发compaction操作。</li>
</ol>
<p>限制写入速度之后，将WriteBatch写入log文件，并将其中的操作应用在memtable之上，更新sequence number。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line">Status DBImpl::Write(<span class="keyword">const</span> WriteOptions&amp; options, WriteBatch* my_batch) &#123;</div><div class="line">  Writer w(&amp;mutex_);</div><div class="line">  w.batch = my_batch;</div><div class="line">  <span class="comment">/// 需要进行sync操作吗？</span></div><div class="line">  w.sync = options.sync;</div><div class="line">  w.done = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">  MutexLock l(&amp;mutex_);</div><div class="line">  <span class="comment">/// 将操作加入队列之中</span></div><div class="line">  writers_.push_back(&amp;w);</div><div class="line">  <span class="comment">/// 若不为队列中的第一项, 等待操作完成, 只有第一个插入才执行后续的操作</span></div><div class="line">  <span class="keyword">while</span> (!w.done &amp;&amp; &amp;w != writers_.front()) &#123;</div><div class="line">    w.cv.Wait();</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (w.done) &#123;</div><div class="line">    <span class="keyword">return</span> w.status;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/// 有新的数据被添加进写入队列，为了控制写入队列的大小，进行下述操作</span></div><div class="line">  <span class="comment">// May temporarily unlock and wait.</span></div><div class="line">  Status status = MakeRoomForWrite(my_batch == <span class="keyword">NULL</span>);</div><div class="line">  uint64_t last_sequence = versions_-&gt;LastSequence();</div><div class="line">  Writer* last_writer = &amp;w;</div><div class="line">  <span class="comment">/// NULL batch被用作compaction</span></div><div class="line">  <span class="keyword">if</span> (status.ok() &amp;&amp; my_batch != <span class="keyword">NULL</span>) &#123;  <span class="comment">// NULL batch is for compactions</span></div><div class="line">    WriteBatch* updates = BuildBatchGroup(&amp;last_writer);</div><div class="line">    <span class="comment">// 设置WriteBatch的SequenceNumber</span></div><div class="line">    WriteBatchInternal::SetSequence(updates, last_sequence + <span class="number">1</span>);</div><div class="line">    last_sequence += WriteBatchInternal::Count(updates);</div><div class="line"></div><div class="line">    <span class="comment">// Add to log and apply to memtable.  We can release the lock</span></div><div class="line">    <span class="comment">// during this phase since &amp;w is currently responsible for logging</span></div><div class="line">    <span class="comment">// and protects against concurrent loggers and concurrent writes</span></div><div class="line">    <span class="comment">// into mem_.</span></div><div class="line">    &#123;</div><div class="line">      mutex_.Unlock();</div><div class="line">      <span class="comment">///将writeBatch中的数据记录log</span></div><div class="line">      status = log_-&gt;AddRecord(WriteBatchInternal::Contents(updates));</div><div class="line">      bool sync_error = <span class="keyword">false</span>;</div><div class="line">      <span class="keyword">if</span> (status.ok() &amp;&amp; options.sync) &#123;</div><div class="line">        <span class="comment">/// 若设置了sync，则对log文件执行sync操作</span></div><div class="line">        status = logfile_-&gt;Sync();</div><div class="line">        <span class="keyword">if</span> (!status.ok()) &#123;</div><div class="line">          sync_error = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (status.ok()) &#123;</div><div class="line">        <span class="comment">/// 将更新写入memtable之中</span></div><div class="line">        status = WriteBatchInternal::InsertInto(updates, mem_);</div><div class="line">      &#125;</div><div class="line">      mutex_.Lock();</div><div class="line">      <span class="keyword">if</span> (sync_error) &#123;</div><div class="line">        <span class="comment">// The state of the log file is indeterminate: the log record we</span></div><div class="line">        <span class="comment">// just added may or may not show up when the DB is re-opened.</span></div><div class="line">        <span class="comment">// So we force the DB into a mode where all future writes fail.</span></div><div class="line">        <span class="comment">/// 记录后台错误</span></div><div class="line">        RecordBackgroundError(status);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/// 对tmp_batch_进行清空处理</span></div><div class="line">    <span class="keyword">if</span> (updates == tmp_batch_) tmp_batch_-&gt;Clear();</div><div class="line"></div><div class="line">    versions_-&gt;SetLastSequence(last_sequence);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    Writer* ready = writers_.front();</div><div class="line">    writers_.pop_front();</div><div class="line">    <span class="keyword">if</span> (ready != &amp;w) &#123;</div><div class="line">      ready-&gt;status = status;</div><div class="line">      ready-&gt;done = <span class="keyword">true</span>;</div><div class="line">      <span class="comment">/// 通知等待线程，已经完成</span></div><div class="line">      ready-&gt;cv.Signal();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/// 直到一组WriteBatch全部处理完毕</span></div><div class="line">    <span class="keyword">if</span> (ready == last_writer) <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Notify new head of write queue</span></div><div class="line">  <span class="keyword">if</span> (!writers_.<span class="keyword">empty</span>()) &#123;</div><div class="line">    <span class="comment">/// 通知当前处在队列头的线程，进行插入处理</span></div><div class="line">    writers_.front()-&gt;cv.Signal();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> status;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb VersionSet解析]]></title>
      <url>/2017/06/24/leveldb-VersionSet%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="VersionSet"><a href="#VersionSet" class="headerlink" title="VersionSet"></a>VersionSet</h1><p>VersionSet负责整个leveldb中各个版本的控制事务。VersionSet维护了一个双向的环形链表，某个Version不再使用时会从链表中删除，其中管理的文件的引用计数也会相应变化，驱动将无用的文件从数据库路径下删除。下图很好地展示了这一点：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fgwbd2p0fnj31kw0zs1kx.jpg" alt=""></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">VersionSet</span> &#123;</span></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="comment">/// constructor of VersionSet</span></div><div class="line">  VersionSet(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dbname,</div><div class="line">             <span class="keyword">const</span> Options* options,</div><div class="line">             TableCache* table_cache,</div><div class="line">             <span class="keyword">const</span> InternalKeyComparator*);</div><div class="line"></div><div class="line">  <span class="comment">/// destructor of VersionSet</span></div><div class="line">  ~VersionSet();</div><div class="line"></div><div class="line">  <span class="comment">// Apply *edit to the current version to form a new descriptor that</span></div><div class="line">  <span class="comment">// is both saved to persistent state and installed as the new</span></div><div class="line">  <span class="comment">// current version.  Will release *mu while actually writing to the file.</span></div><div class="line">  <span class="comment">// REQUIRES: *mu is held on entry.</span></div><div class="line">  <span class="comment">// REQUIRES: no other thread concurrently calls LogAndApply()</span></div><div class="line">  <span class="comment">/// 应用当前version，生成新的log文件，保存持久状态，并且安装作为当前的version，</span></div><div class="line">  <span class="comment">/// 在真正写入到文件之后会release *mu</span></div><div class="line">  <span class="function">Status <span class="title">LogAndApply</span><span class="params">(VersionEdit* edit, port::Mutex* mu)</span></span></div><div class="line">      <span class="title">EXCLUSIVE_LOCKS_REQUIRED</span><span class="params">(mu)</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Recover the last saved descriptor from persistent storage.</span></div><div class="line">  <span class="comment">/// 从存储中恢复最近保存的描述信息</span></div><div class="line">  <span class="function">Status <span class="title">Recover</span><span class="params">(<span class="keyword">bool</span> *save_manifest)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">// Return the current version.</span></div><div class="line">  <span class="comment">/// 返回当前的版本</span></div><div class="line">  <span class="function">Version* <span class="title">current</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> current_; &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Return the current manifest file number</span></div><div class="line">  <span class="comment">/// 返回当前manifest文件数目</span></div><div class="line">  <span class="keyword">uint64_t</span> ManifestFileNumber() <span class="keyword">const</span> &#123; <span class="keyword">return</span> manifest_file_number_; &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Allocate and return a new file number</span></div><div class="line">  <span class="comment">/// 分配并返回一个新的file number</span></div><div class="line">  <span class="keyword">uint64_t</span> NewFileNumber() &#123; <span class="keyword">return</span> next_file_number_++; &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Arrange to reuse "file_number" unless a newer file number has</span></div><div class="line">  <span class="comment">// already been allocated.</span></div><div class="line">  <span class="comment">// REQUIRES: "file_number" was returned by a call to NewFileNumber().</span></div><div class="line">  <span class="comment">/// 已经ReuseFileNumber, 故而next_file_number_可以减去1</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ReuseFileNumber</span><span class="params">(<span class="keyword">uint64_t</span> file_number)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (next_file_number_ == file_number + <span class="number">1</span>) &#123;</div><div class="line">      next_file_number_ = file_number;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Return the number of Table files at the specified level.</span></div><div class="line">  <span class="comment">/// 返回指定level的table文件的number</span></div><div class="line">  <span class="function"><span class="keyword">int</span> <span class="title">NumLevelFiles</span><span class="params">(<span class="keyword">int</span> level)</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">// Return the combined file size of all files at the specified level.</span></div><div class="line">  <span class="comment">/// 返回指定level的所有文件合并的文件的大小</span></div><div class="line">  <span class="keyword">int64_t</span> NumLevelBytes(<span class="keyword">int</span> level) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Return the last sequence number.</span></div><div class="line">  <span class="comment">/// 返回上一个sequence number</span></div><div class="line">  <span class="keyword">uint64_t</span> LastSequence() <span class="keyword">const</span> &#123; <span class="keyword">return</span> last_sequence_; &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Set the last sequence number to s.</span></div><div class="line">  <span class="comment">/// 设置 last sequence number</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetLastSequence</span><span class="params">(<span class="keyword">uint64_t</span> s)</span> </span>&#123;</div><div class="line">    assert(s &gt;= last_sequence_);</div><div class="line">    last_sequence_ = s;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Mark the specified file number as used.</span></div><div class="line">  <span class="comment">/// 标记number指定的文件已经使用, 并据此更新next_file_number_</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">MarkFileNumberUsed</span><span class="params">(<span class="keyword">uint64_t</span> number)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">// Return the current log file number.</span></div><div class="line">  <span class="comment">/// 返回当前log文件的number</span></div><div class="line">  <span class="keyword">uint64_t</span> LogNumber() <span class="keyword">const</span> &#123; <span class="keyword">return</span> log_number_; &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Return the log file number for the log file that is currently</span></div><div class="line">  <span class="comment">// being compacted, or zero if there is no such log file.</span></div><div class="line">  <span class="comment">/// 返回上一个log文件的number</span></div><div class="line">  <span class="keyword">uint64_t</span> PrevLogNumber() <span class="keyword">const</span> &#123; <span class="keyword">return</span> prev_log_number_; &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Pick level and inputs for a new compaction.</span></div><div class="line">  <span class="comment">// Returns NULL if there is no compaction to be done.</span></div><div class="line">  <span class="comment">// Otherwise returns a pointer to a heap-allocated object that</span></div><div class="line">  <span class="comment">// describes the compaction.  Caller should delete the result.</span></div><div class="line">  <span class="comment">/// 选取文件进行Compaction操作</span></div><div class="line">  <span class="function">Compaction* <span class="title">PickCompaction</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">// Return a compaction object for compacting the range [begin,end] in</span></div><div class="line">  <span class="comment">// the specified level.  Returns NULL if there is nothing in that</span></div><div class="line">  <span class="comment">// level that overlaps the specified range.  Caller should delete</span></div><div class="line">  <span class="comment">// the result.</span></div><div class="line">  <span class="comment">/// 选取指定level上指定范围的文件进行Compaction操作</span></div><div class="line">  <span class="function">Compaction* <span class="title">CompactRange</span><span class="params">(</span></span></div><div class="line">      <span class="keyword">int</span> level,</div><div class="line">      <span class="keyword">const</span> InternalKey* begin,</div><div class="line">      <span class="keyword">const</span> InternalKey* end);</div><div class="line"></div><div class="line">  <span class="comment">// Return the maximum overlapping data (in bytes) at next level for any</span></div><div class="line">  <span class="comment">// file at a level &gt;= 1.</span></div><div class="line">  <span class="comment">/// 返回某level和上级文件最大的overlapping的数据大小 (level &gt;= 1)</span></div><div class="line">  <span class="keyword">int64_t</span> MaxNextLevelOverlappingBytes();</div><div class="line"></div><div class="line">  <span class="comment">// Create an iterator that reads over the compaction inputs for "*c".</span></div><div class="line">  <span class="comment">// The caller should delete the iterator when no longer needed.</span></div><div class="line">  <span class="comment">/// 在给定的compaction对象上创建iterator, 这是对compaction涉及到的sstable合并之后形成的</span></div><div class="line">  <span class="comment">/// 统一的iterator</span></div><div class="line">  <span class="function">Iterator* <span class="title">MakeInputIterator</span><span class="params">(Compaction* c)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">// Returns true iff some level needs a compaction.</span></div><div class="line">  <span class="comment">/// 是否需要进行Compaction ?</span></div><div class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">NeedsCompaction</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">    Version* v = current_;</div><div class="line">    <span class="comment">/// 若当前版本的compaction_score &gt;= 1 且 需要进行compact的文件不为NULL 才会需要合并</span></div><div class="line">    <span class="keyword">return</span> (v-&gt;compaction_score_ &gt;= <span class="number">1</span>) || (v-&gt;file_to_compact_ != <span class="literal">NULL</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Add all files listed in any live version to *live.</span></div><div class="line">  <span class="comment">// May also mutate some internal state.</span></div><div class="line">  <span class="comment">/// 将当前存活的文件信息存入live之中</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AddLiveFiles</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">uint64_t</span>&gt;* live)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">// Return the approximate offset in the database of the data for</span></div><div class="line">  <span class="comment">// "key" as of version "v".</span></div><div class="line">  <span class="comment">/// 返回key和version对应的数据在database之中的偏移位置，此值为估计值</span></div><div class="line">  <span class="keyword">uint64_t</span> ApproximateOffsetOf(Version* v, <span class="keyword">const</span> InternalKey&amp; key);</div><div class="line"></div><div class="line">  <span class="comment">// Return a human-readable short (single-line) summary of the number</span></div><div class="line">  <span class="comment">// of files per level.  Uses *scratch as backing store.</span></div><div class="line">  <span class="comment">/// 用于LevelSummary</span></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LevelSummaryStorage</span> &#123;</span></div><div class="line">    <span class="keyword">char</span> buffer[<span class="number">100</span>];</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="comment">/// 返回每个level上文件数目的总结</span></div><div class="line">  <span class="comment">/// 使用sratch用于backing store</span></div><div class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">LevelSummary</span><span class="params">(LevelSummaryStorage* scratch)</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Builder</span>;</span></div><div class="line"></div><div class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Compaction</span>;</span></div><div class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Version</span>;</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">ReuseManifest</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dscname, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dscbase)</span></span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Finalize</span><span class="params">(Version* v)</span></span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">GetRange</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; inputs,</span></span></div><div class="line">                InternalKey* smallest,</div><div class="line">                InternalKey* largest);</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">GetRange2</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; inputs1,</span></span></div><div class="line">                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt;&amp; inputs2,</div><div class="line">                 InternalKey* smallest,</div><div class="line">                 InternalKey* largest);</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetupOtherInputs</span><span class="params">(Compaction* c)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">// Save current contents to *log</span></div><div class="line">  <span class="function">Status <span class="title">WriteSnapshot</span><span class="params">(<span class="built_in">log</span>::Writer* <span class="built_in">log</span>)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/// 添加version最为当前的version</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AppendVersion</span><span class="params">(Version* v)</span></span>;</div><div class="line"></div><div class="line">  Env* <span class="keyword">const</span> env_;</div><div class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> dbname_; <span class="comment">// db name</span></div><div class="line">  <span class="keyword">const</span> Options* <span class="keyword">const</span> options_; <span class="comment">// options</span></div><div class="line">  TableCache* <span class="keyword">const</span> table_cache_; <span class="comment">// sstable cache</span></div><div class="line">  <span class="keyword">const</span> InternalKeyComparator icmp_; <span class="comment">// InternalKey comparator</span></div><div class="line">  <span class="keyword">uint64_t</span> next_file_number_; <span class="comment">// 下一个file number</span></div><div class="line">  <span class="keyword">uint64_t</span> manifest_file_number_; <span class="comment">// number of manifest file</span></div><div class="line">  <span class="keyword">uint64_t</span> last_sequence_; <span class="comment">// 上一个序号</span></div><div class="line">  <span class="keyword">uint64_t</span> log_number_; <span class="comment">// log文件的number</span></div><div class="line">  <span class="keyword">uint64_t</span> prev_log_number_;  <span class="comment">// 0 or backing store for memtable being compacted</span></div><div class="line"></div><div class="line">  <span class="comment">/*</span></div><div class="line">   为了重启db后可以恢复退出前的状态，需要将db中的状态保存下来，这些状态信息就保存在manifest文件中。</div><div class="line">   当db出现异常的时候，为了尽可能多的恢复，manifest中不会只保存当前的状态，而是将历史的状态都保存下来。</div><div class="line">   又考虑到每次状态的完全保存需要的空间和耗费的时间会较多，当前采用的方式是，只在manifest开始保存完整</div><div class="line">   的状态信息(VersionSet::WriteSnapshot())，接下来只保存每次compact产生的操作，重启db时，根据开头</div><div class="line">   的起始状态，依次将后续的VersionEdit replay，即可恢复到退出之前的状态。</div><div class="line">   */</div><div class="line">  <span class="comment">// Opened lazily</span></div><div class="line">  <span class="comment">// manifest文件的封装</span></div><div class="line">  WritableFile* descriptor_file_;</div><div class="line">  <span class="comment">// manifest文件的writer</span></div><div class="line">  <span class="built_in">log</span>::Writer* descriptor_log_;</div><div class="line">  <span class="comment">// 正在服务的Version链表</span></div><div class="line">  Version dummy_versions_;  <span class="comment">// Head of circular doubly-linked list of versions.</span></div><div class="line">  <span class="comment">// 当前最新的Version</span></div><div class="line">  Version* current_;        <span class="comment">// == dummy_versions_.prev_</span></div><div class="line"></div><div class="line">  <span class="comment">// Per-level key at which the next compaction at that level should start.</span></div><div class="line">  <span class="comment">// Either an empty string, or a valid InternalKey.</span></div><div class="line">  <span class="comment">/// 每一个level的下一次compaction开始进行的key</span></div><div class="line">  <span class="comment">/// empty string 或者 InternalKey</span></div><div class="line">  <span class="comment">/*</span></div><div class="line">   为了尽量均匀compact每个level，所以会将这一次compact的end-key作为下一次compact的start-key.</div><div class="line">   compactor_pointer_就保存着每个level下一次compact的start-key.除了current_外的Version，并不会做</div><div class="line">   compact，所以这个值并不保存在Version中。</div><div class="line">   */</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> compact_pointer_[config::kNumLevels];</div><div class="line"></div><div class="line">  <span class="comment">// No copying allowed</span></div><div class="line">  VersionSet(<span class="keyword">const</span> VersionSet&amp;);</div><div class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> VersionSet&amp;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="重点成员函数"><a href="#重点成员函数" class="headerlink" title="重点成员函数"></a>重点成员函数</h2><p>上述成员函数中，LogAndApply将edit应用到当前的版本作为当前最新的版本，并且将edit写入到manifest文件之中，以便leveldb重新启动时能够恢复版本控制信息。而Recover函数则是从CURRENT文件之中获取MANIFEST文件名称，读取Version信息。重启的数据库只需要读取并应用VersionEdit到Version，保留一个版本的Version即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div></pre></td><td class="code"><pre><div class="line">Status VersionSet::Recover(<span class="keyword">bool</span> *save_manifest) &#123;</div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">LogReporter</span> :</span> <span class="keyword">public</span> <span class="built_in">log</span>::Reader::Reporter &#123;</div><div class="line">    Status* status;</div><div class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Corruption</span><span class="params">(<span class="keyword">size_t</span> bytes, <span class="keyword">const</span> Status&amp; s)</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;status-&gt;ok()) *<span class="keyword">this</span>-&gt;status = s;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="comment">// Read "CURRENT" file, which contains a pointer to the current manifest file</span></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> current;</div><div class="line">  Status s = ReadFileToString(env_, CurrentFileName(dbname_), &amp;current);</div><div class="line">  <span class="keyword">if</span> (!s.ok()) &#123;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (current.empty() || current[current.size()<span class="number">-1</span>] != <span class="string">'\n'</span>) &#123;</div><div class="line">    <span class="keyword">return</span> Status::Corruption(<span class="string">"CURRENT file does not end with newline"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">/// 删除末尾的换行符</span></div><div class="line">  current.resize(current.size() - <span class="number">1</span>);</div><div class="line"></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> dscname = dbname_ + <span class="string">"/"</span> + current;</div><div class="line">  SequentialFile* file;</div><div class="line">  s = env_-&gt;NewSequentialFile(dscname, &amp;file);</div><div class="line">  <span class="keyword">if</span> (!s.ok()) &#123;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">bool</span> have_log_number = <span class="literal">false</span>;</div><div class="line">  <span class="keyword">bool</span> have_prev_log_number = <span class="literal">false</span>;</div><div class="line">  <span class="keyword">bool</span> have_next_file = <span class="literal">false</span>;</div><div class="line">  <span class="keyword">bool</span> have_last_sequence = <span class="literal">false</span>;</div><div class="line">  <span class="keyword">uint64_t</span> next_file = <span class="number">0</span>;</div><div class="line">  <span class="keyword">uint64_t</span> last_sequence = <span class="number">0</span>;</div><div class="line">  <span class="keyword">uint64_t</span> log_number = <span class="number">0</span>;</div><div class="line">  <span class="keyword">uint64_t</span> prev_log_number = <span class="number">0</span>;</div><div class="line">  <span class="function">Builder <span class="title">builder</span><span class="params">(<span class="keyword">this</span>, current_)</span></span>;</div><div class="line"></div><div class="line">  &#123;</div><div class="line">    LogReporter reporter;</div><div class="line">    reporter.status = &amp;s;</div><div class="line">    <span class="built_in">log</span>::<span class="function">Reader <span class="title">reader</span><span class="params">(file, &amp;reporter, <span class="literal">true</span><span class="comment">/*checksum*/</span>, <span class="number">0</span><span class="comment">/*initial_offset*/</span>)</span></span>;</div><div class="line">    Slice record;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> scratch;</div><div class="line">    <span class="keyword">while</span> (reader.ReadRecord(&amp;record, &amp;scratch) &amp;&amp; s.ok()) &#123;</div><div class="line">      VersionEdit edit;</div><div class="line">      <span class="comment">/// get VersionEdit</span></div><div class="line">      s = edit.DecodeFrom(record);</div><div class="line">      <span class="keyword">if</span> (s.ok()) &#123;</div><div class="line">        <span class="keyword">if</span> (edit.has_comparator_ &amp;&amp;</div><div class="line">            edit.comparator_ != icmp_.user_comparator()-&gt;Name()) &#123;</div><div class="line">          <span class="comment">/// 和现有的comparator不匹配</span></div><div class="line">          s = Status::InvalidArgument(</div><div class="line">              edit.comparator_ + <span class="string">" does not match existing comparator "</span>,</div><div class="line">              icmp_.user_comparator()-&gt;Name());</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (s.ok()) &#123;</div><div class="line">        <span class="comment">/// 对version应用edit更新</span></div><div class="line">        builder.Apply(&amp;edit);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (edit.has_log_number_) &#123;</div><div class="line">        log_number = edit.log_number_;</div><div class="line">        have_log_number = <span class="literal">true</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (edit.has_prev_log_number_) &#123;</div><div class="line">        prev_log_number = edit.prev_log_number_;</div><div class="line">        have_prev_log_number = <span class="literal">true</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (edit.has_next_file_number_) &#123;</div><div class="line">        next_file = edit.next_file_number_;</div><div class="line">        have_next_file = <span class="literal">true</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (edit.has_last_sequence_) &#123;</div><div class="line">        last_sequence = edit.last_sequence_;</div><div class="line">        have_last_sequence = <span class="literal">true</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">/// 删除原有manifest文件</span></div><div class="line">  <span class="keyword">delete</span> file;</div><div class="line">  file = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (s.ok()) &#123;</div><div class="line">    <span class="keyword">if</span> (!have_next_file) &#123;</div><div class="line">      s = Status::Corruption(<span class="string">"no meta-nextfile entry in descriptor"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!have_log_number) &#123;</div><div class="line">      s = Status::Corruption(<span class="string">"no meta-lognumber entry in descriptor"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!have_last_sequence) &#123;</div><div class="line">      s = Status::Corruption(<span class="string">"no last-sequence-number entry in descriptor"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!have_prev_log_number) &#123;</div><div class="line">      prev_log_number = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/// 标记file number已经使用了</span></div><div class="line">    MarkFileNumberUsed(prev_log_number);</div><div class="line">    MarkFileNumberUsed(log_number);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (s.ok()) &#123;</div><div class="line">    Version* v = <span class="keyword">new</span> Version(<span class="keyword">this</span>);</div><div class="line">    <span class="comment">/// 保存version到v</span></div><div class="line">    builder.SaveTo(v);</div><div class="line">    <span class="comment">// Install recovered version</span></div><div class="line">    <span class="comment">/// 得到compaction操作得分</span></div><div class="line">    Finalize(v);</div><div class="line">    <span class="comment">///  此version作为当前version</span></div><div class="line">    AppendVersion(v);</div><div class="line">    manifest_file_number_ = next_file;</div><div class="line">    next_file_number_ = next_file + <span class="number">1</span>;</div><div class="line">    last_sequence_ = last_sequence;</div><div class="line">    log_number_ = log_number;</div><div class="line">    prev_log_number_ = prev_log_number;</div><div class="line"></div><div class="line">    <span class="comment">// See if we can reuse the existing MANIFEST file.</span></div><div class="line">    <span class="comment">/// 查看是否能够复用当前存在的MANIFEST文件</span></div><div class="line">    <span class="keyword">if</span> (ReuseManifest(dscname, current)) &#123;</div><div class="line">      <span class="comment">// No need to save new manifest</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">/// 需要建立manifest文件</span></div><div class="line">      *save_manifest = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> s;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Compaction相关"><a href="#Compaction相关" class="headerlink" title="Compaction相关"></a>Compaction相关</h2><h3 id="PickCompaction"><a href="#PickCompaction" class="headerlink" title="PickCompaction"></a>PickCompaction</h3><p>每一次调用LogAndApply，应用VersionEdit到当前Version得到更新之后的Version都会调用Finalize评估每个level文件的<code>compaction_score_</code>。这是为了评估每个level所有sstable文件占用的总空间的大小，若超出限制就做好记录，将低level的文件推到更高的level上。</p>
<p>首先，level-0上的文件总数超出限制<code>kL0_CompactionTrigger</code>，或者以下各level文件的数量超出下述范围，都会被认为是违背平衡，选择其中偏差最大的文件记录下来，后续进行compaction处理。</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// level0 10M</span></div><div class="line"><span class="comment">// level1 10M</span></div><div class="line"><span class="comment">// level2 100M</span></div><div class="line"><span class="comment">// level3 1000M</span></div><div class="line"><span class="comment">// level4 10000M</span></div><div class="line"><span class="comment">// level5 100000M</span></div><div class="line"><span class="comment">// level6 1000000M</span></div><div class="line"><span class="comment">// level7 10000000M</span></div></pre></td></tr></table></figure>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// 计算Version内的均衡状态参数: compaction_score_和compaction_level_</span></div><div class="line"><span class="keyword">void</span> VersionSet::Finalize(Version* v) &#123;</div><div class="line">  <span class="comment">// Precomputed best level for next compaction</span></div><div class="line">  <span class="keyword">int</span> best_level = <span class="number">-1</span>;</div><div class="line">  <span class="keyword">double</span> best_score = <span class="number">-1</span>;</div><div class="line"></div><div class="line">  <span class="built_in">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; <span class="built_in">config</span>::kNumLevels<span class="number">-1</span>; level++) &#123;</div><div class="line">    <span class="keyword">double</span> score;</div><div class="line">    <span class="built_in">if</span> (level == <span class="number">0</span>) &#123;</div><div class="line">      <span class="comment">// We treat level-0 specially by bounding the number of files</span></div><div class="line">      <span class="comment">// instead of number of bytes for two reasons:</span></div><div class="line">      <span class="comment">//</span></div><div class="line">      <span class="comment">// (1) With larger write-buffer sizes, it is nice not to do too</span></div><div class="line">      <span class="comment">// many level-0 compactions.</span></div><div class="line">      <span class="comment">//</span></div><div class="line">      <span class="comment">// (2) The files in level-0 are merged on every read and</span></div><div class="line">      <span class="comment">// therefore we wish to avoid too many files when the individual</span></div><div class="line">      <span class="comment">// file size is small (perhaps because of a small write-buffer</span></div><div class="line">      <span class="comment">// setting, or very high compression ratios, or lots of</span></div><div class="line">      <span class="comment">// overwrites/deletions).</span></div><div class="line">      <span class="comment">/// level0文件达到4</span></div><div class="line">      score = v-&gt;files_[level].<span class="built_in">size</span>() /</div><div class="line">          <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(<span class="built_in">config</span>::kL0_CompactionTrigger);</div><div class="line">    &#125; <span class="built_in">else</span> &#123;</div><div class="line">      <span class="comment">// Compute the ratio of current size to size limit.</span></div><div class="line">      <span class="keyword">const</span> uint64_t level_bytes = TotalFileSize(v-&gt;files_[level]);</div><div class="line">      <span class="comment">/// 其他level文件大小之和达到预设大小</span></div><div class="line">      score =</div><div class="line">          <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(level_bytes) / MaxBytesForLevel(options_, level);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">if</span> (score &gt; best_score) &#123;</div><div class="line">      best_level = level;</div><div class="line">      best_score = score;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// record compaction level and compaction score</span></div><div class="line">  v-&gt;compaction_level_ = best_level;</div><div class="line">  v-&gt;compaction_score_ = best_score;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>PickCompaction函数中优先处理<code>size_compaction</code>而非<code>seek_compaction</code>。对于<code>size_compaction</code>会选取上一次compaction结束的key之后的文件开始进行，对于<code>seek_compaction</code>会直接选取之前记录seek数量超标的文件。因为level-0的sstable文件可能会互相重叠，将区间重叠的所有level-0文件取出来。这样就完成了compaction level上输入的sstable文件的选取，还要借助SetupOtherInputs函数选取上一个level上的区间重叠的输入文件。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">Compaction* VersionSet::PickCompaction() &#123;</div><div class="line">  Compaction* c;</div><div class="line">  int level;</div><div class="line"></div><div class="line">  <span class="comment">// We prefer compactions triggered by too much data in a level over</span></div><div class="line">  <span class="comment">// the compactions triggered by seeks.</span></div><div class="line">  <span class="comment">/// 相比seek_compaction, 我们优先处理size_compaction</span></div><div class="line">  <span class="comment">/// 相比由seek产生的不均衡，更优先compact由sstable size / count造成的不平衡</span></div><div class="line">  <span class="comment">/// 因为文件大小超标而需要进行Compaction操作</span></div><div class="line">  <span class="function"><span class="title">const</span> bool size_compaction = (current_-&gt;</span>compaction_score_ &gt;= <span class="number">1</span>);</div><div class="line">  <span class="comment">/// 因为seek次数过多而需要进行Compaction操作</span></div><div class="line">  <span class="function"><span class="title">const</span> bool seek_compaction = (current_-&gt;</span>file_to_compact_ != NULL);</div><div class="line">  <span class="keyword">if</span> (size_compaction) &#123;</div><div class="line">    <span class="function"><span class="title">level</span> = current_-&gt;</span>compaction_level_;</div><div class="line">    assert(level &gt;= <span class="number">0</span>);</div><div class="line">    assert(level+<span class="number">1</span> &lt; config::kNumLevels);</div><div class="line">    c = new Compaction(options_, level);</div><div class="line"></div><div class="line">    <span class="comment">// Pick the first file that comes after compact_pointer_[level]</span></div><div class="line">    <span class="comment">/// 选择大于compact_pointer_[level]的文件</span></div><div class="line">    <span class="function"><span class="title">for</span> (size_t i = 0; i &lt; current_-&gt;</span>files_[level].size(); i++) &#123;</div><div class="line">      F<span class="function"><span class="title">ileMetaData</span>* f = current_-&gt;</span>files_[level][i];</div><div class="line">      <span class="keyword">if</span> (compact_pointer_[level].empty() ||</div><div class="line">          <span class="function"><span class="title">icmp_</span>.Compare(f-&gt;</span>largest.Encode(), compact_pointer_[level]) &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="function"><span class="title">c</span>-&gt;</span>inputs_[<span class="number">0</span>].push_back(f);</div><div class="line">        break;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/// 没有输入，就使用对应level的第一个文件输入</span></div><div class="line">    <span class="function"><span class="title">if</span> (c-&gt;</span>inputs_[<span class="number">0</span>].empty()) &#123;</div><div class="line">      <span class="comment">// Wrap-around to the beginning of the key space</span></div><div class="line">      <span class="function"><span class="title">c</span>-&gt;</span><span class="function"><span class="title">inputs_</span>[0].push_back(current_-&gt;</span>files_[level][<span class="number">0</span>]);</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (seek_compaction) &#123;</div><div class="line">    <span class="function"><span class="title">level</span> = current_-&gt;</span>file_to_compact_level_;</div><div class="line">    c = new Compaction(options_, level);</div><div class="line">    <span class="comment">/// 指定为因为seek而记录的file_to_compact_文件</span></div><div class="line">    <span class="function"><span class="title">c</span>-&gt;</span><span class="function"><span class="title">inputs_</span>[0].push_back(current_-&gt;</span>file_to_compact_);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    return NULL;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/// 输入的version</span></div><div class="line">  <span class="function"><span class="title">c</span>-&gt;</span>input_version_ = current_;</div><div class="line">  <span class="comment">/// reference it</span></div><div class="line">  <span class="function"><span class="title">c</span>-&gt;</span><span class="function"><span class="title">input_version_</span>-&gt;</span>Ref();</div><div class="line"></div><div class="line">  <span class="comment">// Files in level 0 may overlap each other, so pick up all overlapping ones</span></div><div class="line">  <span class="comment">/// 若为level0可能会互相重叠,取出在level-0中与确定compact的sstable有overlap的文件</span></div><div class="line">  <span class="comment">//// level0更新inputs_[0]</span></div><div class="line">  <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</div><div class="line">    InternalKey smallest, largest;</div><div class="line">    G<span class="function"><span class="title">etRange</span>(c-&gt;</span>inputs_[<span class="number">0</span>], &amp;smallest, &amp;largest);</div><div class="line">    <span class="comment">// Note that the next call will discard the file we placed in</span></div><div class="line">    <span class="comment">// c-&gt;inputs_[0] earlier and replace it with an overlapping set</span></div><div class="line">    <span class="comment">// which will include the picked file.</span></div><div class="line">    <span class="comment">/// 取出level0与smallest和largest重叠的文件</span></div><div class="line">    <span class="function"><span class="title">current_</span>-&gt;</span>G<span class="function"><span class="title">etOverlappingInputs</span>(0, &amp;smallest, &amp;largest, &amp;c-&gt;</span>inputs_[<span class="number">0</span>]);</div><div class="line">    <span class="function"><span class="title">assert</span>(!c-&gt;</span>inputs_[<span class="number">0</span>].empty());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/// 取得需要的其他sstable</span></div><div class="line">  SetupOtherInputs(c);</div><div class="line"></div><div class="line">  return c;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="CompactRange"><a href="#CompactRange" class="headerlink" title="CompactRange"></a>CompactRange</h3><p>CompactRange函数的存在是为了应对选取指定level和范围的sstable文件作为输入进行compaction的行为。其行为很简单，选择与指定范围重叠的文件作为compaction level输入的sstable文件。但是选取的文件总空间大小被限制在此level的文件大小限制之内。最后依然调用SetupOtherInputs选取level+1层次上区间重叠的sstable文件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">Compaction* VersionSet::CompactRange(</div><div class="line">    <span class="keyword">int</span> level,</div><div class="line">    <span class="keyword">const</span> InternalKey* begin,</div><div class="line">    <span class="keyword">const</span> InternalKey* end) &#123;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FileMetaData*&gt; inputs;</div><div class="line">  <span class="comment">/// 获取指定level，指定范围内的范围重叠的文件</span></div><div class="line">  current_-&gt;GetOverlappingInputs(level, begin, end, &amp;inputs);</div><div class="line">  <span class="comment">/// 如果指定区间内没有文件，直接返回NULL</span></div><div class="line">  <span class="keyword">if</span> (inputs.empty()) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Avoid compacting too much in one shot in case the range is large.</span></div><div class="line">  <span class="comment">// But we cannot do this for level-0 since level-0 files can overlap</span></div><div class="line">  <span class="comment">// and we must not pick one file and drop another older file if the</span></div><div class="line">  <span class="comment">// two files overlap.</span></div><div class="line">  <span class="comment">/// 避免依次compact过多的sstable，控制一个level中参与compact的sstable size不大于MaxFileSizeForLevel()</span></div><div class="line">  <span class="comment">/// 当前是kTargetFileSize</span></div><div class="line"></div><div class="line">  <span class="keyword">if</span> (level &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> limit = MaxFileSizeForLevel(options_, level);</div><div class="line">    <span class="keyword">uint64_t</span> total = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; inputs.size(); i++) &#123;</div><div class="line">      <span class="keyword">uint64_t</span> s = inputs[i]-&gt;file_size;</div><div class="line">      total += s;</div><div class="line">      <span class="comment">/// 控制输入的文件的大小</span></div><div class="line">      <span class="keyword">if</span> (total &gt;= limit) &#123;</div><div class="line">        inputs.resize(i + <span class="number">1</span>);</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Compaction* c = <span class="keyword">new</span> Compaction(options_, level);</div><div class="line">  <span class="comment">/// 输入文件的版本</span></div><div class="line">  c-&gt;input_version_ = current_;</div><div class="line">  <span class="comment">/// 增加引用计数</span></div><div class="line">  c-&gt;input_version_-&gt;Ref();</div><div class="line">  <span class="comment">/// 记录输入的文件</span></div><div class="line">  c-&gt;inputs_[<span class="number">0</span>] = inputs;</div><div class="line">  <span class="comment">/// 获取compaction操作正确的输入文件</span></div><div class="line">  SetupOtherInputs(c);</div><div class="line">  <span class="keyword">return</span> c;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="SetupOtherInputs"><a href="#SetupOtherInputs" class="headerlink" title="SetupOtherInputs"></a>SetupOtherInputs</h3><p>原则上，level+1 compaction操作输入的sstable文件只需要输入与level层区间重叠的文件，保证最后生成的level+1层的sstable文件内部不发生重叠即可。leveldb也是这么做的，但是做了一点操作在不违反非0 level的文件内部不会产生重叠的情况下尽可能扩大输入文件的范围。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// 取得需要的其他sstable文件</span></div><div class="line"><span class="comment">/// a. 从level-n中获得的sstable的key-range,然后获得与其有overlap的level-n+1中的sstable</span></div><div class="line"><span class="comment">/// b. 在不扩大已经获得的所有sstable的key-range的情况下，尝试添加level-n中的sstable</span></div><div class="line"><span class="comment">/// c. 获得grandparents_</span></div><div class="line"><span class="comment">/// d. 更新level-n中下一次要compact的start-key</span></div><div class="line">void VersionSet::SetupOtherInputs(Compaction* c) &#123;</div><div class="line">  <span class="function"><span class="title">const</span> int level = c-&gt;</span>level();</div><div class="line">  InternalKey smallest, largest;</div><div class="line">  <span class="comment">/// 获得compaction操作所在的level的key的范围</span></div><div class="line">  G<span class="function"><span class="title">etRange</span>(c-&gt;</span>inputs_[<span class="number">0</span>], &amp;smallest, &amp;largest);</div><div class="line">  <span class="comment">/// 获取level+1上与指定区间重叠的文件，加入c-&gt;inputs_[1]</span></div><div class="line">  <span class="function"><span class="title">current_</span>-&gt;</span>G<span class="function"><span class="title">etOverlappingInputs</span>(level+1, &amp;smallest, &amp;largest, &amp;c-&gt;</span>inputs_[<span class="number">1</span>]);</div><div class="line"></div><div class="line">  <span class="comment">// Get entire range covered by compaction</span></div><div class="line">  <span class="comment">/// 获取level和level+1上所有文件的区间范围</span></div><div class="line">  InternalKey all_start, all_limit;</div><div class="line">  G<span class="function"><span class="title">etRange2</span>(c-&gt;</span><span class="function"><span class="title">inputs_</span>[0], c-&gt;</span>inputs_[<span class="number">1</span>], &amp;all_start, &amp;all_limit);</div><div class="line"></div><div class="line">  <span class="comment">// See if we can grow the number of inputs in "level" without</span></div><div class="line">  <span class="comment">// changing the number of "level+1" files we pick up.</span></div><div class="line">  <span class="comment">/// 尽可能扩充选中的文件数量，又做到不违背大于1的level内部文件之间发生重叠</span></div><div class="line">  <span class="function"><span class="title">if</span> (!c-&gt;</span>inputs_[<span class="number">1</span>].empty()) &#123;</div><div class="line">    std::vector&lt;FileMetaData*&gt; expanded0;</div><div class="line">    <span class="comment">/// 获取更新范围之后的level上重叠的文件列表</span></div><div class="line">    <span class="function"><span class="title">current_</span>-&gt;</span>GetOverlappingInputs(level, &amp;all_start, &amp;all_limit, &amp;expanded0);</div><div class="line">    <span class="function"><span class="title">const</span> int64_t inputs0_size = TotalFileSize(c-&gt;</span>inputs_[<span class="number">0</span>]);</div><div class="line">    <span class="function"><span class="title">const</span> int64_t inputs1_size = TotalFileSize(c-&gt;</span>inputs_[<span class="number">1</span>]);</div><div class="line">    <span class="comment">/// 扩展范围的文件的大小</span></div><div class="line">    const int64_t expanded0_size = TotalFileSize(expanded0);</div><div class="line">    <span class="function"><span class="title">if</span> (expanded0.size() &gt; c-&gt;</span>inputs_[<span class="number">0</span>].size() &amp;&amp;</div><div class="line">        inputs1_size + expanded0_size &lt;</div><div class="line">            ExpandedCompactionByteSizeLimit(options_)) &#123; <span class="comment">/// 限制compaction操作涉及的文件大小</span></div><div class="line">      InternalKey new_start, new_limit;</div><div class="line">      <span class="comment">/// 获取expanded之后level文件的取值范围</span></div><div class="line">      GetRange(expanded0, &amp;new_start, &amp;new_limit);</div><div class="line">      std::vector&lt;FileMetaData*&gt; expanded1;</div><div class="line">      <span class="comment">/// 获取level+1上和[new_start,new_limit]重叠的文件列表</span></div><div class="line">      <span class="function"><span class="title">current_</span>-&gt;</span>GetOverlappingInputs(level+<span class="number">1</span>, &amp;new_start, &amp;new_limit,</div><div class="line">                                     &amp;expanded1);</div><div class="line">      <span class="comment">/// level+1上的文件没有发生扩展</span></div><div class="line">      <span class="function"><span class="title">if</span> (expanded1.size() == c-&gt;</span>inputs_[<span class="number">1</span>].size()) &#123;</div><div class="line">        L<span class="function"><span class="title">og</span>(options_-&gt;</span>info_log,</div><div class="line">            <span class="string">"Expanding@%d %d+%d (%ld+%ld bytes) to %d+%d (%ld+%ld bytes)\n"</span>,</div><div class="line">            level,</div><div class="line">            <span class="function"><span class="title">int</span>(c-&gt;</span>inputs_[<span class="number">0</span>].size()),</div><div class="line">            <span class="function"><span class="title">int</span>(c-&gt;</span>inputs_[<span class="number">1</span>].size()),</div><div class="line">            long(inputs0_size), long(inputs1_size),</div><div class="line">            int(expanded0.size()),</div><div class="line">            int(expanded1.size()),</div><div class="line">            long(expanded0_size), long(inputs1_size));</div><div class="line">        smallest = new_start;</div><div class="line">        largest = new_limit;</div><div class="line">        <span class="comment">/// 记录更新之后输入的文件</span></div><div class="line">        <span class="function"><span class="title">c</span>-&gt;</span>inputs_[<span class="number">0</span>] = expanded0;</div><div class="line">        <span class="function"><span class="title">c</span>-&gt;</span>inputs_[<span class="number">1</span>] = expanded1;</div><div class="line">        <span class="comment">/// 记录更新之后的level和level+1上的总区间范围到[all_start,all_limit]</span></div><div class="line">        G<span class="function"><span class="title">etRange2</span>(c-&gt;</span><span class="function"><span class="title">inputs_</span>[0], c-&gt;</span>inputs_[<span class="number">1</span>], &amp;all_start, &amp;all_limit);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Compute the set of grandparent files that overlap this compaction</span></div><div class="line">  <span class="comment">// (parent == level+1; grandparent == level+2)</span></div><div class="line">  <span class="comment">/// 记录grandparents_在[all_start, all_limit]范围内的重叠的文件</span></div><div class="line">  <span class="keyword">if</span> (level + <span class="number">2</span> &lt; config::kNumLevels) &#123;</div><div class="line">    <span class="comment">/// 和[all_start,all_limit]区间重叠的grandparent level 文件的列表存入grandparents_之中</span></div><div class="line">    <span class="function"><span class="title">current_</span>-&gt;</span>GetOverlappingInputs(level + <span class="number">2</span>, &amp;all_start, &amp;all_limit,</div><div class="line">                                   &amp;<span class="function"><span class="title">c</span>-&gt;</span>grandparents_);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/// never happen</span></div><div class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</div><div class="line">    L<span class="function"><span class="title">og</span>(options_-&gt;</span>info_log, <span class="string">"Compacting %d '%s' .. '%s'"</span>,</div><div class="line">        level,</div><div class="line">        smallest.DebugString().c_str(),</div><div class="line">        largest.DebugString().c_str());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Update the place where we will do the next compaction for this level.</span></div><div class="line">  <span class="comment">// We update this immediately instead of waiting for the VersionEdit</span></div><div class="line">  <span class="comment">// to be applied so that if the compaction fails, we will try a different</span></div><div class="line">  <span class="comment">// key range next time.</span></div><div class="line">  <span class="comment">/// 记录当前level compact操作后最大的key</span></div><div class="line">  compact_pointer_[level] = largest.Encode().ToString();</div><div class="line">  <span class="function"><span class="title">c</span>-&gt;</span>edit_.SetCompactPointer(level, largest);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>if (!c-&gt;inputs_[1].empty()) {</code>之后的代码是干什么的呢？是为了尽可能在遵守现有规则的情况下扩大输入文件的范围。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fgwcchih6pj30js03ljrm.jpg" alt=""></p>
<p>上图中，根据level n的输入文件A，可以选中level n+1上与A区间重叠的3个文件作为输入一起进行compaction操作。我们可以发现实际上可以将level n上的E文件加入，而不会扩充level n+1层需要输入的文件。</p>
<p>但是，在如图下述情况下，就不能把文件E加入作为level n上的输入文件。因为，这样就需要把level n+1上的F文件牵扯进来，这不是我们想要的。</p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fgwcgcu6h1j30js03l0sz.jpg" alt=""></p>
<p>可是，下述情况却是可以的，因为我们没有牵扯到level n+1上更多的文件。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fgwcix6gcxj30js03l0sz.jpg" alt=""></p>
<p>当然，扩充之后的文件空间大小之和也不可以超出限制：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">inputs1_size + expanded0_size &lt;</div><div class="line">            ExpandedCompactionByteSizeLimit(<span class="name">options_</span>)</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb Version和VersionEdit]]></title>
      <url>/2017/06/24/leveldb-Version%E5%92%8CVersionEdit/</url>
      <content type="html"><![CDATA[<h1 id="leveldb中的版本控制"><a href="#leveldb中的版本控制" class="headerlink" title="leveldb中的版本控制"></a>leveldb中的版本控制</h1><p>在leveldb之中，随着插入的数据不断增加，数据从memtable不断向更高level的sstable迁移，leveldb内部管理的各个level的文件内容不断发生变化，这种数据的迁移在leveldb内部通过版本控制进行管理。</p>
<p>版本管理通过3个数据结构进行管理，Version表示某一个特定的版本，包括这个版本各个level的文件以及其他数据库相关文件等，VersionEdit表示从上一个版本变更到下一个版本的变化量，将VersionEdit应用到上一个Version之上就得到了更新之后的Version。而VersionSet则用于leveldb的版本管理，其中维护了当前使用的各种版本，特别是最新版本。</p>
<h1 id="Version"><a href="#Version" class="headerlink" title="Version"></a>Version</h1><p>Version类定义如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Version</span> </span>&#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="comment">// Append to *iters a sequence of iterators that will</span></div><div class="line">  <span class="comment">// yield the contents of this Version when merged together.</span></div><div class="line">  <span class="comment">// REQUIRES: This version has been saved (see VersionSet::SaveTo)</span></div><div class="line">  <span class="comment">/// 向iters加入当前Version的内容对应的iterator，在合并之前内容不会修改</span></div><div class="line">  <span class="comment">/// 对level0和其他level做了区分处理</span></div><div class="line">  <span class="comment">/// 当前level所有文件的iterator加入iters中</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AddIterators</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp;, std::vector&lt;Iterator*&gt;* iters)</span></span>;</div><div class="line"></div><div class="line">  struct GetStats &#123;</div><div class="line">    FileMetaData* seek_file; <span class="comment">// 查找的文件</span></div><div class="line">    <span class="keyword">int</span> seek_file_level; <span class="comment">// 查找的文件的level</span></div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="comment">// Lookup the value for key.  If found, store it in *val and</span></div><div class="line">  <span class="comment">// return OK.  Else return a non-OK status.  Fills *stats.</span></div><div class="line">  <span class="comment">// REQUIRES: lock is not held</span></div><div class="line">  <span class="comment">/// 查找key的value，若找到了存储在*val之中，并返回OK，否则返回non-OK status。记录stats。</span></div><div class="line">  <span class="comment">/// 要求：没有持有锁</span></div><div class="line">  <span class="function">Status <span class="title">Get</span><span class="params">(<span class="keyword">const</span> ReadOptions&amp;, <span class="keyword">const</span> LookupKey&amp; key, std::string* val,</span></span></div><div class="line">             GetStats* stats);</div><div class="line"></div><div class="line">  <span class="comment">// Adds "stats" into the current state.  Returns true if a new</span></div><div class="line">  <span class="comment">// compaction may need to be triggered, false otherwise.</span></div><div class="line">  <span class="comment">// REQUIRES: lock is held</span></div><div class="line">  <span class="comment">/// 将stats添加到当前的state之中。如果需要compaction返回true，否则返回false。</span></div><div class="line">  <span class="comment">/// 要求：已经持有锁</span></div><div class="line">  <span class="function">bool <span class="title">UpdateStats</span><span class="params">(<span class="keyword">const</span> GetStats&amp; stats)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">// Record a sample of bytes read at the specified internal key.</span></div><div class="line">  <span class="comment">// Samples are taken approximately once every config::kReadBytesPeriod</span></div><div class="line">  <span class="comment">// bytes.  Returns true if a new compaction may need to be triggered.</span></div><div class="line">  <span class="comment">// REQUIRES: lock is held</span></div><div class="line">  <span class="comment">/// 读 指定key的a sample of bytes 。具体读多少数据取决于config::kReadBytesPeriod</span></div><div class="line">  <span class="comment">/// 如果触发了新的compaction就返回true。</span></div><div class="line">  <span class="comment">/// 要求：持有锁</span></div><div class="line">  <span class="function">bool <span class="title">RecordReadSample</span><span class="params">(Slice key)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">// Reference count management (so Versions do not disappear out from</span></div><div class="line">  <span class="comment">// under live iterators)</span></div><div class="line">  <span class="comment">/// 引用计数管理, 所以对应iterator存活时，Versions不会消失</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Ref</span><span class="params">()</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Unref</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">/// 在*input保存所有level对应的和[begin,end]overlap的文件</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">GetOverlappingInputs</span><span class="params">(</span></span></div><div class="line">      <span class="keyword">int</span> level,</div><div class="line">      <span class="keyword">const</span> InternalKey* begin,         // NULL means before all keys</div><div class="line">      <span class="keyword">const</span> InternalKey* end,           // NULL means after all keys</div><div class="line">      std::vector&lt;FileMetaData*&gt;* inputs);</div><div class="line"></div><div class="line">  <span class="comment">// Returns true iff some file in the specified level overlaps</span></div><div class="line">  <span class="comment">// some part of [*smallest_user_key,*largest_user_key].</span></div><div class="line">  <span class="comment">// smallest_user_key==NULL represents a key smaller than all keys in the DB.</span></div><div class="line">  <span class="comment">// largest_user_key==NULL represents a key largest than all keys in the DB.</span></div><div class="line">  <span class="comment">/// 若指定level中的文件和[*smallest_user_key,*largest_user_key]区间重叠就返回true</span></div><div class="line">  <span class="function">bool <span class="title">OverlapInLevel</span><span class="params">(<span class="keyword">int</span> level,</span></span></div><div class="line">                      <span class="keyword">const</span> Slice* smallest_user_key,</div><div class="line">                      <span class="keyword">const</span> Slice* largest_user_key);</div><div class="line"></div><div class="line">  <span class="comment">// Return the level at which we should place a new memtable compaction</span></div><div class="line">  <span class="comment">// result that covers the range [smallest_user_key,largest_user_key].</span></div><div class="line">  <span class="comment">/// 新的dump的memtable的结果涵盖的key的范围是[smallest_user_key,largest_user_key]</span></div><div class="line">  <span class="comment">/// 返回应该被放置在哪一个level之上</span></div><div class="line">  <span class="function"><span class="keyword">int</span> <span class="title">PickLevelForMemTableOutput</span><span class="params">(<span class="keyword">const</span> Slice&amp; smallest_user_key,</span></span></div><div class="line">                                 <span class="keyword">const</span> Slice&amp; largest_user_key);</div><div class="line"></div><div class="line">  <span class="comment">/// 返回对应level的文件数目</span></div><div class="line">  <span class="function"><span class="keyword">int</span> <span class="title">NumFiles</span><span class="params">(<span class="keyword">int</span> level)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> files_[level].size(); &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Return a human readable string that describes this version's contents.</span></div><div class="line">  <span class="comment">/// debug 字符串</span></div><div class="line">  std::<span class="function">string <span class="title">DebugString</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  friend <span class="class"><span class="keyword">class</span> <span class="title">Compaction</span></span>;</div><div class="line">  friend <span class="class"><span class="keyword">class</span> <span class="title">VersionSet</span></span>;</div><div class="line"></div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">LevelFileNumIterator</span></span>;</div><div class="line">  Iterator* NewConcatenatingIterator(<span class="keyword">const</span> ReadOptions&amp;, <span class="keyword">int</span> level) <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Call func(arg, level, f) for every file that overlaps user_key in</span></div><div class="line">  <span class="comment">// order from newest to oldest.  If an invocation of func returns</span></div><div class="line">  <span class="comment">// false, makes no more calls.</span></div><div class="line">  <span class="comment">//</span></div><div class="line">  <span class="comment">// REQUIRES: user portion of internal_key == user_key.</span></div><div class="line">  <span class="comment">/// 按照由新到旧的顺序，和user_key重合的file，都执行函数func(arg, level, f), 若执行func的结果</span></div><div class="line">  <span class="comment">/// 为false，就break</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ForEachOverlapping</span><span class="params">(Slice user_key, Slice internal_key,</span></span></div><div class="line">                          <span class="keyword">void</span>* arg,</div><div class="line">                          bool (*func)<span class="params">(<span class="keyword">void</span>*, <span class="keyword">int</span>, FileMetaData*)</span>);</div><div class="line"></div><div class="line">  <span class="comment">/// 当前Version属于哪一个VersionSet</span></div><div class="line">  VersionSet* vset_;            <span class="comment">// VersionSet to which this Version belongs</span></div><div class="line">  <span class="comment">/// 链表中的下一个version</span></div><div class="line">  Version* next_;               <span class="comment">// Next version in linked list</span></div><div class="line">  <span class="comment">/// 链表中的上一个version</span></div><div class="line">  Version* prev_;               <span class="comment">// Previous version in linked list</span></div><div class="line">  <span class="comment">/// 引用计数</span></div><div class="line">  <span class="keyword">int</span> refs_;                    <span class="comment">// Number of live refs to this version</span></div><div class="line"></div><div class="line">  <span class="comment">// List of files per level</span></div><div class="line">  <span class="comment">/// 每个level对应的链表</span></div><div class="line">  std::vector&lt;FileMetaData*&gt; files_[config::kNumLevels];</div><div class="line"></div><div class="line">  <span class="comment">/*</span></div><div class="line">   sstable的seek次数达到一定的阈值的时候，可以认为它处在不最优的情况，而我们认为compact后</div><div class="line">   会倾向于均衡的状态，所以在一个sstable的seek次数达到一定的阈值后，主动对其进行compact是合理的。</div><div class="line">   */</div><div class="line">  <span class="comment">/*</span></div><div class="line"> 这个具体 seek 次数阈值(allowed_seeks)的确定，依赖于 sas 盘的 IO 性能:</div><div class="line">  a. 一次磁盘寻道seek耗费10ms。</div><div class="line">  b. 读或者写 1M 数据耗费 10ms (按 100M/s IO 吞吐能力)。</div><div class="line">  c. compact 1M 的数据需要 25M 的 IO:从 level-n 中读 1M 数据，从 level-n+1 中读 10~12M 数据，写入 level-n+1 中 10~12M 数据。</div><div class="line">  所以，compact 1M 的数据的时间相当于做 25 次磁盘 seek，反过来说就是，1 次 seek 相当于 compact 40k 数据。那么，可以得到 seek 阈值</div><div class="line">   allowed_seeks=sstable_size / 40k。保守设置， 当前实际的 allowed_seeks = sstable_size / 10k。</div><div class="line">   每次 compact 完成，构造新的 Version 时 (Builder::Apply()),每个 sstable 的 allowed_seeks 会计算出来保存在 FileMetaData。</div><div class="line">   在每次 get 操作的时候，如果有超过一个 sstable 文件进行了 IO，会将最后一个 IO 的 sstable 的 allowed_seeks 减一，</div><div class="line">   并检查其是否已经用光了 allowed_seeks,若是，则将该 sstable 记录成当前 Version 的 file_to_compact_,并记录其所在的 level(file_to_compact_level_)。</div><div class="line">   */</div><div class="line">  <span class="comment">// Next file to compact based on seek stats.</span></div><div class="line">  <span class="comment">/// 经seek stats评估的下一个需要compact的文件</span></div><div class="line">  FileMetaData* file_to_compact_;</div><div class="line">  <span class="comment">/// 将要compact的文件的level</span></div><div class="line">  <span class="keyword">int</span> file_to_compact_level_;</div><div class="line"></div><div class="line">  <span class="comment">// Level that should be compacted next and its compaction score.</span></div><div class="line">  <span class="comment">// Score &lt; 1 means compaction is not strictly needed.  These fields</span></div><div class="line">  <span class="comment">// are initialized by Finalize().</span></div><div class="line">  <span class="comment">/// compaction 评分，Score &lt; 1 意味着compaction在严格意义上不需要</span></div><div class="line">  <span class="keyword">double</span> compaction_score_;</div><div class="line">  <span class="comment">/// compaction 操作所在的level</span></div><div class="line">  <span class="keyword">int</span> compaction_level_;</div><div class="line"></div><div class="line">  <span class="function">explicit <span class="title">Version</span><span class="params">(VersionSet* vset)</span></span></div><div class="line">      : <span class="title">vset_</span><span class="params">(vset)</span>, <span class="title">next_</span><span class="params">(<span class="keyword">this</span>)</span>, <span class="title">prev_</span><span class="params">(<span class="keyword">this</span>)</span>, <span class="title">refs_</span><span class="params">(<span class="number">0</span>)</span>,</div><div class="line">        <span class="title">file_to_compact_</span><span class="params">(NULL)</span>,</div><div class="line">        <span class="title">file_to_compact_level_</span><span class="params">(<span class="number">-1</span>)</span>,</div><div class="line">        <span class="title">compaction_score_</span><span class="params">(<span class="number">-1</span>)</span>,</div><div class="line">        <span class="title">compaction_level_</span><span class="params">(<span class="number">-1</span>)</span> &#123;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/// destructor of Version</span></div><div class="line">  ~Version();</div><div class="line"></div><div class="line">  <span class="comment">// No copying allowed</span></div><div class="line">  Version(<span class="keyword">const</span> Version&amp;);</div><div class="line">  <span class="keyword">void</span> operator=(<span class="keyword">const</span> Version&amp;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>每一个Version主要管理当前版本的文件，即<code>files_</code>。leveldb在进行版本管理时，将所有的Version当做链表中的一个结点连接起来，其中链表的头结点对应当前最新的Version。</p>
<h2 id="AddIterators"><a href="#AddIterators" class="headerlink" title="AddIterators"></a>AddIterators</h2><p>AddIterators方法将当前Version管理的所有文件的迭代器返回给调用者。因为level-0上的sstable文件内部可能会重叠，而其他level内部的文件不会重叠，重叠只会发生在不同level之间。因而，level-0级别的sstable每一个文件需要生成一个迭代器，其他level每个level生成一个迭代器。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">void Version::AddIterators(const ReadOptions&amp; options,</div><div class="line">                           std::vector&lt;Iterator*&gt;* iters) &#123;</div><div class="line">  <span class="comment">/// 将所有level0对应的iterators加入iters</span></div><div class="line">  <span class="comment">// Merge all level zero files together since they may overlap</span></div><div class="line">  <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; files_[<span class="number">0</span>].size(); i++) &#123;</div><div class="line">    <span class="comment">/// two level iterator，from index block handle iterator to record</span></div><div class="line">    <span class="function"><span class="title">iters</span>-&gt;</span>push_back(</div><div class="line">        <span class="function"><span class="title">vset_</span>-&gt;</span><span class="function"><span class="title">table_cache_</span>-&gt;</span>NewIterator(</div><div class="line">            <span class="function"><span class="title">options</span>, files_[0][i]-&gt;</span><span class="function"><span class="title">number</span>, files_[0][i]-&gt;</span>file_size));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// For levels &gt; 0, we can use a concatenating iterator that sequentially</span></div><div class="line">  <span class="comment">// walks through the non-overlapping files in the level, opening them</span></div><div class="line">  <span class="comment">// lazily.</span></div><div class="line">  <span class="keyword">for</span> (int level = <span class="number">1</span>; level &lt; config::kNumLevels; level++) &#123;</div><div class="line">    <span class="keyword">if</span> (!files_[level].empty()) &#123;</div><div class="line">      <span class="comment">/// two level itertor, from LevelFileNumIterator to sstable iterator</span></div><div class="line">      <span class="function"><span class="title">iters</span>-&gt;</span>push_back(NewConcatenatingIterator(options, level));</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ConcatenatingIterator实际上本质上是一个TwoLevelIterator，完成从LevelFileNumIterator到sstable Iterator之间的转换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> Iterator* <span class="title">GetFileIterator</span><span class="params">(<span class="keyword">void</span>* arg,</span></span></div><div class="line">                                 <span class="keyword">const</span> ReadOptions&amp; options,</div><div class="line">                                 <span class="keyword">const</span> Slice&amp; file_value) &#123;</div><div class="line">  TableCache* cache = <span class="keyword">reinterpret_cast</span>&lt;TableCache*&gt;(arg);</div><div class="line">  <span class="comment">// file number and file size 占用空间大小为16bytes</span></div><div class="line">  <span class="keyword">if</span> (file_value.size() != <span class="number">16</span>) &#123;</div><div class="line">    <span class="keyword">return</span> NewErrorIterator(</div><div class="line">        Status::Corruption(<span class="string">"FileReader invoked with unexpected value"</span>));</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">/// 返回file_number和file_size指定的sstable文件的iterator</span></div><div class="line">    <span class="keyword">return</span> cache-&gt;NewIterator(options,</div><div class="line">                              DecodeFixed64(file_value.data()), <span class="comment">// file number</span></div><div class="line">                              DecodeFixed64(file_value.data() + <span class="number">8</span>)); <span class="comment">// file size</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">Iterator* Version::NewConcatenatingIterator(<span class="keyword">const</span> ReadOptions&amp; options,</div><div class="line">                                            <span class="keyword">int</span> level) <span class="keyword">const</span> &#123;</div><div class="line">  <span class="comment">/// same level file -&gt; sstable iterator</span></div><div class="line">  <span class="keyword">return</span> NewTwoLevelIterator(</div><div class="line">      <span class="keyword">new</span> LevelFileNumIterator(vset_-&gt;icmp_, &amp;files_[level]),</div><div class="line">      &amp;GetFileIterator, vset_-&gt;table_cache_, options);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Get"><a href="#Get" class="headerlink" title="Get"></a>Get</h2><p>Get函数从当前Version管理的sstable文件之中获取key对应的value。它依次遍历每个level的sstable文件进行查找，直到找到指定的key。对于level-0，它将和key区间重叠的每个sstable文件都取出来查找。而因为其他level内部文件不会发生区间重叠，因而只会取出一个和key区间重叠的文件进行查找。level-0的sstable，优先处理更新的文件。</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// 从当前version所管理的sstable之中进行搜索</span></div><div class="line"><span class="comment">/// 查找key的value，若找到了存储在*val之中，并返回OK，否则返回non-OK status。记录stats。</span></div><div class="line"><span class="comment">/// 要求：没有持有锁</span></div><div class="line">Status Version::Get(<span class="keyword">const</span> ReadOptions&amp; options,</div><div class="line">                    <span class="keyword">const</span> LookupKey&amp; k,</div><div class="line">                    std::string* value,</div><div class="line">                    GetStats* stats) &#123;</div><div class="line">  <span class="comment">/// get internal_key slice from k</span></div><div class="line">  Slice ikey = k.internal_key();</div><div class="line">  <span class="comment">/// get user key from k</span></div><div class="line">  Slice user_key = k.user_key();</div><div class="line">  <span class="keyword">const</span> Comparator* ucmp = vset_-&gt;icmp_.user_comparator();</div><div class="line">  Status s;</div><div class="line"></div><div class="line">  stats-&gt;seek_file = <span class="keyword">NULL</span>;</div><div class="line">  stats-&gt;seek_file_level = <span class="number">-1</span>;</div><div class="line">  FileMetaData* last_file_read = <span class="keyword">NULL</span>;</div><div class="line">  <span class="keyword">int</span> last_file_read_level = <span class="number">-1</span>;</div><div class="line"></div><div class="line">  <span class="comment">// We can search level-by-level since entries never hop across</span></div><div class="line">  <span class="comment">// levels.  Therefore we are guaranteed that if we find data</span></div><div class="line">  <span class="comment">// in an smaller level, later levels are irrelevant.</span></div><div class="line">  <span class="comment">/// 因为level更小的记录的sequence number更大，因此只需要沿着level从小到大进行搜索</span></div><div class="line">  std::vector&lt;FileMetaData*&gt; tmp;</div><div class="line">  FileMetaData* tmp2;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> level = <span class="number">0</span>; level &lt; config::kNumLevels; level++) &#123;</div><div class="line">    size_t num_files = files_[level].size();</div><div class="line">    <span class="keyword">if</span> (num_files == <span class="number">0</span>) <span class="keyword">continue</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Get the list of files to search in this level</span></div><div class="line">    FileMetaData* <span class="keyword">const</span>* files = &amp;files_[level][<span class="number">0</span>];</div><div class="line">    <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</div><div class="line">      <span class="comment">// Level-0 files may overlap each other.  Find all files that</span></div><div class="line">      <span class="comment">// overlap user_key and process them in order from newest to oldest.</span></div><div class="line">      tmp.reserve(num_files);</div><div class="line">      <span class="keyword">for</span> (uint32_t i = <span class="number">0</span>; i &lt; num_files; i++) &#123;</div><div class="line">        FileMetaData* f = files[i];</div><div class="line">        <span class="keyword">if</span> (ucmp-&gt;Compare(user_key, f-&gt;smallest.user_key()) &gt;= <span class="number">0</span> &amp;&amp;</div><div class="line">            ucmp-&gt;Compare(user_key, f-&gt;largest.user_key()) &lt;= <span class="number">0</span>) &#123;</div><div class="line">          <span class="comment">// 发生了重叠</span></div><div class="line">          tmp.push_back(f);</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (tmp.<span class="keyword">empty</span>()) <span class="keyword">continue</span>;</div><div class="line">      <span class="comment">/// 优先按照sequence number更大level0文件来查找</span></div><div class="line">      <span class="comment">/// 按照sequence number进行排序,</span></div><div class="line">      std::sort(tmp.begin(), tmp.end(), NewestFirst);</div><div class="line">      <span class="comment">/// 返回sequence最大的哪一个</span></div><div class="line">      files = &amp;tmp[<span class="number">0</span>];</div><div class="line">      <span class="comment">/// file的数目</span></div><div class="line">      num_files = tmp.size();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// Binary search to find earliest index whose largest key &gt;= ikey.</span></div><div class="line">      uint32_t index = FindFile(vset_-&gt;icmp_, files_[level], ikey);</div><div class="line">      <span class="keyword">if</span> (index &gt;= num_files) &#123;</div><div class="line">        files = <span class="keyword">NULL</span>;</div><div class="line">        num_files = <span class="number">0</span>;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        tmp2 = files[index];</div><div class="line">        <span class="comment">/// user_key &lt; files[index] -&gt; smallest.user_key() 不满足条件, 没有发生重叠</span></div><div class="line">        <span class="keyword">if</span> (ucmp-&gt;Compare(user_key, tmp2-&gt;smallest.user_key()) &lt; <span class="number">0</span>) &#123;</div><div class="line">          <span class="comment">// All of "tmp2" is past any data for user_key</span></div><div class="line">          files = <span class="keyword">NULL</span>;</div><div class="line">          num_files = <span class="number">0</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          files = &amp;tmp2;</div><div class="line">          num_files = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (uint32_t i = <span class="number">0</span>; i &lt; num_files; ++i) &#123;</div><div class="line">      <span class="comment">/// 记录上一次seek的file以及对应的seek_file_level</span></div><div class="line">      <span class="keyword">if</span> (last_file_read != <span class="keyword">NULL</span> &amp;&amp; stats-&gt;seek_file == <span class="keyword">NULL</span>) &#123;</div><div class="line">        <span class="comment">// We have had more than one seek for this read.  Charge the 1st file.</span></div><div class="line">        <span class="comment">/// 记录查找到记录所对应的文件以及其所在的level</span></div><div class="line">        stats-&gt;seek_file = last_file_read;</div><div class="line">        stats-&gt;seek_file_level = last_file_read_level;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      FileMetaData* f = files[i];</div><div class="line">      <span class="comment">/// 上次读取的file</span></div><div class="line">      last_file_read = f;</div><div class="line">      <span class="comment">/// 上次读取的level</span></div><div class="line">      last_file_read_level = level;</div><div class="line"></div><div class="line">      Saver saver;</div><div class="line">      saver.state = kNotFound;</div><div class="line">      saver.ucmp = ucmp;</div><div class="line">      saver.user_key = user_key;</div><div class="line">      saver.value = value;</div><div class="line">      <span class="comment">/// 获取对应sstable，将读取的结果使用saver进行保存</span></div><div class="line">      s = vset_-&gt;table_cache_-&gt;Get(options, f-&gt;number, f-&gt;file_size,</div><div class="line">                                   ikey, &amp;saver, SaveValue);</div><div class="line">      <span class="keyword">if</span> (!s.ok()) &#123;</div><div class="line">        <span class="keyword">return</span> s;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">/// 实际上，若第一次循环便返回，后续循环也不会进行了</span></div><div class="line">      <span class="keyword">switch</span> (saver.state) &#123;</div><div class="line">        <span class="keyword">case</span> kNotFound:</div><div class="line">          <span class="comment">///!!! 继续在其他文件之中搜索</span></div><div class="line">          <span class="keyword">break</span>;      <span class="comment">// Keep searching in other files</span></div><div class="line">        <span class="keyword">case</span> kFound:</div><div class="line">          <span class="keyword">return</span> s;</div><div class="line">        <span class="comment">/// the same as kNotFound</span></div><div class="line">        <span class="keyword">case</span> kDeleted:</div><div class="line">          s = Status::NotFound(Slice());  <span class="comment">// Use empty error message for speed</span></div><div class="line">          <span class="keyword">return</span> s;</div><div class="line">        <span class="keyword">case</span> kCorrupt:</div><div class="line">          s = Status::Corruption(<span class="string">"corrupted key for "</span>, user_key);</div><div class="line">          <span class="keyword">return</span> s;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 没有找到对应的key</span></div><div class="line">  <span class="keyword">return</span> Status::NotFound(Slice());  <span class="comment">// Use an empty error message for speed</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="PickLevelForMemTableOutput"><a href="#PickLevelForMemTableOutput" class="headerlink" title="PickLevelForMemTableOutput"></a>PickLevelForMemTableOutput</h1><p>对于新生成的sstable文件，此函数用于选取其应该放置的level。优先将新生成的sstable文件放置在level-0上，除非其和上一级的文件没有发生重叠，并且和grandparents level的sstable重叠区间的文件体积没有超出预设值。当然，输出的level值还受到<code>kMaxMemCompactLevel</code>的限制。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// 如果新生成的sstable与level-0中的文件有overlap，选level 0</span></div><div class="line"><span class="comment">/// 向上尝试不大于kMaxMemCompactLevel的level，如果与level产生overlap，即返回</span></div><div class="line"><span class="comment">/// 对于不产生overlap的level，同时考虑kMaxGrandParentOverlapBytes的阈值判断</span></div><div class="line"><span class="comment">/// 对于memtable，选取其放置的level</span></div><div class="line"><span class="keyword">int</span> Version::PickLevelForMemTableOutput(</div><div class="line">    <span class="keyword">const</span> Slice&amp; smallest_user_key,</div><div class="line">    <span class="keyword">const</span> Slice&amp; largest_user_key) &#123;</div><div class="line">  <span class="keyword">int</span> level = <span class="number">0</span>;</div><div class="line">  <span class="comment">/// 若在level0上没有重叠</span></div><div class="line">  <span class="built_in">if</span> (!OverlapInLevel(<span class="number">0</span>, &amp;smallest_user_key, &amp;largest_user_key)) &#123;</div><div class="line">    <span class="comment">// Push to next level if there is no overlap in next level,</span></div><div class="line">    <span class="comment">// and the #bytes overlapping in the level after that are limited.</span></div><div class="line">    InternalKey start(smallest_user_key, kMaxSequenceNumber, kValueTypeForSeek);</div><div class="line">    InternalKey limit(largest_user_key, <span class="number">0</span>, <span class="keyword">static_cast</span>&lt;ValueType&gt;(<span class="number">0</span>));</div><div class="line">    std::vector&lt;FileMetaData*&gt; overlaps;</div><div class="line">    <span class="comment">// memtable dump成的sstable，允许推向的最高level, 默认设置为2</span></div><div class="line">    <span class="built_in">while</span> (level &lt; <span class="built_in">config</span>::kMaxMemCompactLevel) &#123;</div><div class="line">      <span class="comment">/// 若和level + 1发生了重叠，那么break</span></div><div class="line">      <span class="built_in">if</span> (OverlapInLevel(level + <span class="number">1</span>, &amp;smallest_user_key, &amp;largest_user_key)) &#123;</div><div class="line">        <span class="built_in">break</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="built_in">if</span> (level + <span class="number">2</span> &lt; <span class="built_in">config</span>::kNumLevels) &#123;</div><div class="line">        <span class="comment">// Check that file does not overlap too many grandparent bytes.</span></div><div class="line">        GetOverlappingInputs(level + <span class="number">2</span>, &amp;start, &amp;limit, &amp;overlaps);</div><div class="line">        <span class="keyword">const</span> int64_t sum = TotalFileSize(overlaps);</div><div class="line">        <span class="comment">/// 重叠的文件总空间是否超出指定值20MB</span></div><div class="line">        <span class="comment">/// 为了限制和grandparent level overlap的数据的总量</span></div><div class="line">        <span class="built_in">if</span> (sum &gt; MaxGrandParentOverlapBytes(vset_-&gt;options_)) &#123;</div><div class="line">          <span class="built_in">break</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      level++;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">/// 若在level0上发生了重叠，那么新dump的memtable文件也加入level0</span></div><div class="line">  <span class="built_in">return</span> level;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="RecordReadSample"><a href="#RecordReadSample" class="headerlink" title="RecordReadSample"></a>RecordReadSample</h1><p>在leveldb中认为更高level的sstable文件更加倾向于平衡，能够减少查询时访问的文件的数目。若为了访问某个值，从某个文件开始进行查找，并且不在这个文件之中，那么说明此文件应该被推向更高的level，来减少未来更多的seek操作的开销。在leveldb之中，每个sstable文件预设的阈值为<code>max(sstable_size / 10K)</code>，若某文件seek操作符合上述情况达到此次数，就会被标记，未来会在后台线程之中被进行compaction处理。RecordReadSample函数就是为了记录此情况而设的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// 对于输入的internalkey在重叠的文件上都执行Match函数，记录对于internal_key重叠的次数</span></div><div class="line"><span class="comment">/// 次数达到2次，就执行UpdateStats，减少f的allowed_seeks, 递减到0，就将其作为我们执行compaction的起点</span></div><div class="line"><span class="keyword">bool</span> Version::RecordReadSample(Slice internal_key) &#123;</div><div class="line">  ParsedInternalKey ikey;</div><div class="line">  <span class="comment">/// 解析InternalKey失败</span></div><div class="line">  <span class="keyword">if</span> (!ParseInternalKey(internal_key, &amp;ikey)) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">State</span> &#123;</span></div><div class="line">    GetStats stats;  <span class="comment">// Holds first matching file</span></div><div class="line">    <span class="keyword">int</span> matches;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">Match</span><span class="params">(<span class="keyword">void</span>* arg, <span class="keyword">int</span> level, FileMetaData* f)</span> </span>&#123;</div><div class="line">      State* state = <span class="keyword">reinterpret_cast</span>&lt;State*&gt;(arg);</div><div class="line">      state-&gt;matches++;</div><div class="line">      <span class="comment">/// 只记住第一次match时所对应的文件和level</span></div><div class="line">      <span class="keyword">if</span> (state-&gt;matches == <span class="number">1</span>) &#123;</div><div class="line">        <span class="comment">// Remember first match.</span></div><div class="line">        state-&gt;stats.seek_file = f;</div><div class="line">        state-&gt;stats.seek_file_level = level;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// We can stop iterating once we have a second match.</span></div><div class="line">      <span class="comment">/// 如果已经发生了两次level级别的重叠，那么直接暂停，不再尝试寻找</span></div><div class="line">      <span class="comment">/// 新的overlapping</span></div><div class="line">      <span class="keyword">return</span> state-&gt;matches &lt; <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  State state;</div><div class="line">  state.matches = <span class="number">0</span>;</div><div class="line">  ForEachOverlapping(ikey.user_key, internal_key, &amp;state, &amp;State::Match);</div><div class="line"></div><div class="line">  <span class="comment">// Must have at least two matches since we want to merge across</span></div><div class="line">  <span class="comment">// files. But what if we have a single file that contains many</span></div><div class="line">  <span class="comment">// overwrites and deletions?  Should we have another mechanism for</span></div><div class="line">  <span class="comment">// finding such files?</span></div><div class="line">  <span class="comment">/// 如果和两个以上的level发生重叠，那么调用UpdateStats，减少allowed_seeks</span></div><div class="line">  <span class="comment">/// 若递减到0，就需要触发compaction</span></div><div class="line">  <span class="keyword">if</span> (state.matches &gt;= <span class="number">2</span>) &#123;</div><div class="line">    <span class="comment">// 1MB cost is about 1 seek (see comment in Builder::Apply).</span></div><div class="line">    <span class="keyword">return</span> UpdateStats(state.stats);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="VersionEdit"><a href="#VersionEdit" class="headerlink" title="VersionEdit"></a>VersionEdit</h1><p>Version之中，管理每个特定的sstable文件使用此数据结构进行描述：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FileMetaData</span> &#123;</span></div><div class="line">  <span class="keyword">int</span> refs;  <span class="comment">// reference count</span></div><div class="line">  <span class="keyword">int</span> allowed_seeks;          <span class="comment">// Seeks allowed until compaction compact之前允许的seek次数</span></div><div class="line">  <span class="keyword">uint64_t</span> number;            <span class="comment">// number of file</span></div><div class="line">  <span class="keyword">uint64_t</span> file_size;         <span class="comment">// File size in bytes</span></div><div class="line">  InternalKey smallest;       <span class="comment">// Smallest internal key served by table / sstable文件的最小key</span></div><div class="line">  InternalKey largest;        <span class="comment">// Largest internal key served by table / sstable文件的最大key</span></div><div class="line"></div><div class="line">  FileMetaData() : refs(<span class="number">0</span>), allowed_seeks(<span class="number">1</span> &lt;&lt; <span class="number">30</span>), file_size(<span class="number">0</span>) &#123; &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>VersionEdit记录了下一个Version相对于上一个Version之间的变化。它有自己的序列化和反序列化方法，序列化之后的字符串会记录在manifest文件之中，记录数据库最新的版本信息。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fgwb3xlvnzj30fj03pmxp.jpg" alt=""></p>
<p>VersionEdit的主要成员如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span> comparator_; <span class="comment">// 比较器的名称</span></div><div class="line"><span class="keyword">uint64_t</span> log_number_; <span class="comment">// 日志文件编号</span></div><div class="line"><span class="keyword">uint64_t</span> prev_log_number_; <span class="comment">// 上一个日志文件编号</span></div><div class="line"><span class="keyword">uint64_t</span> next_file_number_; <span class="comment">// 下一个日志文件编号</span></div><div class="line">SequenceNumber last_sequence_; <span class="comment">// 上一个序列号</span></div><div class="line"><span class="keyword">bool</span> has_comparator_; <span class="comment">// 是否有比较器</span></div><div class="line"><span class="keyword">bool</span> has_log_number_; <span class="comment">// 是否有log number</span></div><div class="line"><span class="keyword">bool</span> has_prev_log_number_; <span class="comment">// 是否有上一个log number</span></div><div class="line"><span class="keyword">bool</span> has_next_file_number_; <span class="comment">// 是否有下一个file number</span></div><div class="line"><span class="keyword">bool</span> has_last_sequence_; <span class="comment">// 是否有上一个sequence</span></div><div class="line"><span class="comment">// 压缩点&lt;层次，InternalKey键&gt;</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, InternalKey&gt; &gt; compact_pointers_;</div><div class="line"><span class="comment">// 删除文件集合</span></div><div class="line">DeletedFileSet deleted_files_;</div><div class="line"><span class="comment">// 新添加的文件集合</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt; <span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, FileMetaData&gt; &gt; new_files_;</div></pre></td></tr></table></figure>
<p>按照上图格式定义，就能很轻松地看懂序列化和反序列化的相关代码：</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">/// Encode VersionEdit into <span class="built_in">string</span> specified by dst</div><div class="line">void VersionEdit::EncodeTo(<span class="built_in">std</span>::<span class="built_in">string</span>* dst) const &#123;</div><div class="line">  /// has comparator, <span class="built_in">put</span> tag <span class="keyword">and</span> comparator name into dst</div><div class="line">  <span class="keyword">if</span> (has_comparator_) &#123;</div><div class="line">    PutVarint32(dst, kComparator);</div><div class="line">    PutLengthPrefixedSlice(dst, comparator_);</div><div class="line">  &#125;</div><div class="line">  /// has <span class="built_in">log</span> number, <span class="built_in">put</span> kLogNumber tag <span class="keyword">and</span> log_number_</div><div class="line">  <span class="keyword">if</span> (has_log_number_) &#123;</div><div class="line">    PutVarint32(dst, kLogNumber);</div><div class="line">    PutVarint64(dst, log_number_);</div><div class="line">  &#125;</div><div class="line">  /// has prev <span class="built_in">log</span> number, <span class="built_in">put</span> kPrevLogNumber tag <span class="keyword">and</span> prev_log_number_</div><div class="line">  <span class="keyword">if</span> (has_prev_log_number_) &#123;</div><div class="line">    PutVarint32(dst, kPrevLogNumber);</div><div class="line">    PutVarint64(dst, prev_log_number_);</div><div class="line">  &#125;</div><div class="line">  /// has next file number, <span class="built_in">put</span> kNextFileNumber tag <span class="keyword">and</span> next_file_number_</div><div class="line">  <span class="keyword">if</span> (has_next_file_number_) &#123;</div><div class="line">    PutVarint32(dst, kNextFileNumber);</div><div class="line">    PutVarint64(dst, next_file_number_);</div><div class="line">  &#125;</div><div class="line">  /// has last_sequence, <span class="built_in">put</span> kLastSequence tag <span class="keyword">and</span> last_sequence_</div><div class="line">  <span class="keyword">if</span> (has_last_sequence_) &#123;</div><div class="line">    PutVarint32(dst, kLastSequence);</div><div class="line">    PutVarint64(dst, last_sequence_);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /// <span class="built_in">put</span> kCompactPointer tag <span class="keyword">and</span> pair&lt;level, InternelKey&gt; of each <span class="built_in">elem</span> of compact_pointers_</div><div class="line">  <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; compact_pointers_.size(); i++) &#123;</div><div class="line">    PutVarint32(dst, kCompactPointer);</div><div class="line">    PutVarint32(dst, compact_pointers_[i].<span class="built_in">first</span>);  // level</div><div class="line">    PutLengthPrefixedSlice(dst, compact_pointers_[i].<span class="built_in">second</span>.Encode());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /// <span class="built_in">put</span> kDeletedFile tag <span class="keyword">and</span> pair&lt;level, file number&gt; of each <span class="built_in">elem</span> of deleted_files_</div><div class="line">  <span class="keyword">for</span> (DeletedFileSet::const_iterator iter = deleted_files_.begin();</div><div class="line">       iter != deleted_files_.end();</div><div class="line">       ++iter) &#123;</div><div class="line">    PutVarint32(dst, kDeletedFile);</div><div class="line">    PutVarint32(dst, iter-&gt;<span class="built_in">first</span>);   // level</div><div class="line">    PutVarint64(dst, iter-&gt;<span class="built_in">second</span>);  // file number</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  /// <span class="built_in">put</span> kNewFile tag <span class="keyword">and</span> FileMetaData of each <span class="built_in">elem</span> of new_files_</div><div class="line">  <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; new_files_.size(); i++) &#123;</div><div class="line">    const FileMetaData&amp; f = new_files_[i].<span class="built_in">second</span>;</div><div class="line">    PutVarint32(dst, kNewFile);</div><div class="line">    PutVarint32(dst, new_files_[i].<span class="built_in">first</span>);  // level</div><div class="line">    PutVarint64(dst, f.number);</div><div class="line">    PutVarint64(dst, f.file_size);</div><div class="line">    PutLengthPrefixedSlice(dst, f.smallest.Encode());</div><div class="line">    PutLengthPrefixedSlice(dst, f.largest.Encode());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// Decode VersionEdit from string specified by src</span></div><div class="line">Status VersionEdit::DecodeFrom(<span class="keyword">const</span> Slice&amp; src) &#123;</div><div class="line">  <span class="comment">/// 首先进行清理</span></div><div class="line">  Clear();</div><div class="line">  Slice input = src;</div><div class="line">  <span class="comment">/// 用于记录出错消息</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* msg = <span class="literal">NULL</span>;</div><div class="line">  <span class="keyword">uint32_t</span> tag;</div><div class="line"></div><div class="line">  <span class="comment">// Temporary storage for parsing</span></div><div class="line">  <span class="comment">/// temporary usage</span></div><div class="line">  <span class="keyword">int</span> level;</div><div class="line">  <span class="keyword">uint64_t</span> number;</div><div class="line">  FileMetaData f;</div><div class="line">  Slice str;</div><div class="line">  InternalKey key;</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (msg == <span class="literal">NULL</span> &amp;&amp; GetVarint32(&amp;input, &amp;tag)) &#123;</div><div class="line">    <span class="comment">/// 读取tag</span></div><div class="line">    <span class="keyword">switch</span> (tag) &#123;</div><div class="line">      <span class="keyword">case</span> kComparator:</div><div class="line">        <span class="keyword">if</span> (GetLengthPrefixedSlice(&amp;input, &amp;str)) &#123;</div><div class="line">          comparator_ = str.ToString();</div><div class="line">          has_comparator_ = <span class="literal">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          msg = <span class="string">"comparator name"</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">      <span class="keyword">case</span> kLogNumber:</div><div class="line">        <span class="keyword">if</span> (GetVarint64(&amp;input, &amp;log_number_)) &#123;</div><div class="line">          has_log_number_ = <span class="literal">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          msg = <span class="string">"log number"</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">      <span class="keyword">case</span> kPrevLogNumber:</div><div class="line">        <span class="keyword">if</span> (GetVarint64(&amp;input, &amp;prev_log_number_)) &#123;</div><div class="line">          has_prev_log_number_ = <span class="literal">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          msg = <span class="string">"previous log number"</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">      <span class="keyword">case</span> kNextFileNumber:</div><div class="line">        <span class="keyword">if</span> (GetVarint64(&amp;input, &amp;next_file_number_)) &#123;</div><div class="line">          has_next_file_number_ = <span class="literal">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          msg = <span class="string">"next file number"</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">      <span class="keyword">case</span> kLastSequence:</div><div class="line">        <span class="keyword">if</span> (GetVarint64(&amp;input, &amp;last_sequence_)) &#123;</div><div class="line">          has_last_sequence_ = <span class="literal">true</span>;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          msg = <span class="string">"last sequence number"</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="comment">/// get compact pointer</span></div><div class="line">      <span class="keyword">case</span> kCompactPointer:</div><div class="line">        <span class="keyword">if</span> (GetLevel(&amp;input, &amp;level) &amp;&amp;</div><div class="line">            GetInternalKey(&amp;input, &amp;key)) &#123;</div><div class="line">          compact_pointers_.push_back(<span class="built_in">std</span>::make_pair(level, key));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          msg = <span class="string">"compaction pointer"</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">        <span class="comment">/// get deleted files</span></div><div class="line">      <span class="keyword">case</span> kDeletedFile:</div><div class="line">        <span class="keyword">if</span> (GetLevel(&amp;input, &amp;level) &amp;&amp;</div><div class="line">            GetVarint64(&amp;input, &amp;number)) &#123;</div><div class="line">          deleted_files_.insert(<span class="built_in">std</span>::make_pair(level, number));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          msg = <span class="string">"deleted file"</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="comment">/// get elem of new_files_</span></div><div class="line">      <span class="keyword">case</span> kNewFile:</div><div class="line">        <span class="keyword">if</span> (GetLevel(&amp;input, &amp;level) &amp;&amp;</div><div class="line">            GetVarint64(&amp;input, &amp;f.number) &amp;&amp;</div><div class="line">            GetVarint64(&amp;input, &amp;f.file_size) &amp;&amp;</div><div class="line">            GetInternalKey(&amp;input, &amp;f.smallest) &amp;&amp;</div><div class="line">            GetInternalKey(&amp;input, &amp;f.largest)) &#123;</div><div class="line">          new_files_.push_back(<span class="built_in">std</span>::make_pair(level, f));</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          msg = <span class="string">"new-file entry"</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        msg = <span class="string">"unknown tag"</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/// 输入没有读取完，并且记录的出错消息为NULL</span></div><div class="line">  <span class="keyword">if</span> (msg == <span class="literal">NULL</span> &amp;&amp; !input.empty()) &#123;</div><div class="line">    msg = <span class="string">"invalid tag"</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Status result;</div><div class="line">  <span class="comment">/// 出错了</span></div><div class="line">  <span class="keyword">if</span> (msg != <span class="literal">NULL</span>) &#123;</div><div class="line">    result = Status::Corruption(<span class="string">"VersionEdit"</span>, msg);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb table_cache解析]]></title>
      <url>/2017/06/23/leveldb-table-cache%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>leveldb在打开sstable的时候，会将这个sstable对应的table 句柄存入cache。cache内部基于LRU算法进行管理，默认cache的容积为990，也就是说leveldb默认情况下最多能同时打开的sstable文件的数目为990个。在执行compaction操作时，创建的sstable也会加入此cache。同样，在执行sstable上的查找时，所打开的sstable文件也会存入table cache之中。在leveldb中，默认执行随机文件读写操作是基于<code>PosixMmapReadableFile</code>。若table cache之中的一条记录离开了，会执行下述函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// delete table, file, and TableAndFile object allocated on heap</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DeleteEntry</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">void</span>* value)</span> </span>&#123;</div><div class="line">  TableAndFile* tf = <span class="keyword">reinterpret_cast</span>&lt;TableAndFile*&gt;(value);</div><div class="line">  <span class="keyword">delete</span> tf-&gt;table;</div><div class="line">  <span class="comment">/// 此处关闭了打开的文件</span></div><div class="line">  <span class="keyword">delete</span> tf-&gt;file;</div><div class="line">  <span class="keyword">delete</span> tf;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>leveldb基于lru cache限制了打开文件的数目，减少了对内存的占用。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>TableCache使用<code>file_number</code>作为key来存储sstable的句柄信息。在执行查找table操作时，若没有找到对应的记录，会根据输入的<code>file_number</code>打开对应的sstable文件，并且将其存入TableCache之中。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">Status TableCache::FindTable(uint64_t file_number, uint64_t file_size,</div><div class="line">                             Cache::Handle** handle) &#123;</div><div class="line">  Status s;</div><div class="line">  <span class="comment">/// use file_number as key</span></div><div class="line">  <span class="keyword">char</span> buf[sizeof(file_number)];</div><div class="line">  EncodeFixed64(buf, file_number);</div><div class="line">  Slice key(buf, sizeof(buf));</div><div class="line"><span class="comment">  *handle = cache_-&gt;Lookup(key);</span></div><div class="line">  <span class="keyword">if</span> (*handle == NULL) &#123;</div><div class="line">    std::string fname = TableFileName(dbname_, file_number);</div><div class="line">    RandomAccessFile* <span class="keyword">file</span> = NULL;</div><div class="line">    <span class="keyword">Table</span>* <span class="keyword">table</span> = NULL;</div><div class="line">    <span class="comment">///首先尝试ldb文件，再尝试sst文件</span></div><div class="line">    s = env_-&gt;NewRandomAccessFile(fname, &amp;<span class="keyword">file</span>);</div><div class="line">    <span class="keyword">if</span> (!s.ok()) &#123;</div><div class="line">      std::string old_fname = SSTTableFileName(dbname_, file_number);</div><div class="line">      <span class="keyword">if</span> (env_-&gt;NewRandomAccessFile(old_fname, &amp;<span class="keyword">file</span>).ok()) &#123;</div><div class="line">        s = Status::OK();</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (s.ok()) &#123;</div><div class="line">      <span class="comment">/// 打开sstable</span></div><div class="line">      s = <span class="keyword">Table</span>::<span class="keyword">Open</span>(*options_, <span class="keyword">file</span>, file_size, &amp;<span class="keyword">table</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!s.ok()) &#123;</div><div class="line">      <span class="keyword">assert</span>(<span class="keyword">table</span> == NULL);</div><div class="line">      delete <span class="keyword">file</span>;</div><div class="line">      <span class="comment">// We do not cache error results so that if the error is transient,</span></div><div class="line">      <span class="comment">// or somebody repairs the file, we recover automatically.</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">/// 记录sstable，file object</span></div><div class="line">      TableAndFile* tf = new TableAndFile;</div><div class="line">      tf-&gt;<span class="keyword">file</span> = <span class="keyword">file</span>;</div><div class="line">      tf-&gt;<span class="keyword">table</span> = <span class="keyword">table</span>;</div><div class="line">      <span class="comment">/// 占用cache_的空间为1，表示一条记录。</span></div><div class="line">      <span class="comment">/// 通过cache_控制打开的文件的数目</span></div><div class="line"><span class="comment">      *handle = cache_-&gt;Insert(key, tf, 1, &amp;DeleteEntry);</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> s;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从TableCache之中删除记录，将输入的<code>file_number</code>作为key，在TableCache中删除对应的记录。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// 从cache中删除file_number对应的记录</span></div><div class="line"><span class="keyword">void</span> TableCache::Evict(<span class="keyword">uint64_t</span> file_number) &#123;</div><div class="line">  <span class="keyword">char</span> buf[<span class="keyword">sizeof</span>(file_number)];</div><div class="line">  EncodeFixed64(buf, file_number);</div><div class="line">  cache_-&gt;Erase(Slice(buf, <span class="keyword">sizeof</span>(buf)));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>获取<code>file_number</code>指定文件的sstable的Iterator，首先执行FindTable获取对应sstable的句柄，然后返回sstable的Iterator。在Iterator存活期间，此记录在TableCache之中不能被删除。在Iterator被析构时，需要执行Release操作，通知Cache此sstable对应的记录可以被安全地清理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">Iterator* TableCache::NewIterator(<span class="keyword">const</span> ReadOptions&amp; options,</div><div class="line">                                  <span class="keyword">uint64_t</span> file_number,</div><div class="line">                                  <span class="keyword">uint64_t</span> file_size,</div><div class="line">                                  Table** tableptr) &#123;</div><div class="line">  <span class="keyword">if</span> (tableptr != <span class="literal">NULL</span>) &#123;</div><div class="line">    *tableptr = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Cache::Handle* handle = <span class="literal">NULL</span>;</div><div class="line">  Status s = FindTable(file_number, file_size, &amp;handle);</div><div class="line">  <span class="keyword">if</span> (!s.ok()) &#123;</div><div class="line">    <span class="keyword">return</span> NewErrorIterator(s);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/// 获取sstable对象</span></div><div class="line">  Table* table = <span class="keyword">reinterpret_cast</span>&lt;TableAndFile*&gt;(cache_-&gt;Value(handle))-&gt;table;</div><div class="line">  Iterator* result = table-&gt;NewIterator(options);</div><div class="line">  <span class="comment">// when destruct, release from cache</span></div><div class="line">  result-&gt;RegisterCleanup(&amp;UnrefEntry, cache_, handle);</div><div class="line">  <span class="keyword">if</span> (tableptr != <span class="literal">NULL</span>) &#123;</div><div class="line">    <span class="comment">/// 记录对应的sstable</span></div><div class="line">    *tableptr = table;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/// 注册的清理函数</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UnrefEntry</span><span class="params">(<span class="keyword">void</span>* arg1, <span class="keyword">void</span>* arg2)</span> </span>&#123;</div><div class="line">  <span class="comment">/// get cache ptr</span></div><div class="line">  Cache* cache = <span class="keyword">reinterpret_cast</span>&lt;Cache*&gt;(arg1);</div><div class="line">  <span class="comment">/// get cache data</span></div><div class="line">  Cache::Handle* h = <span class="keyword">reinterpret_cast</span>&lt;Cache::Handle*&gt;(arg2);</div><div class="line">  <span class="comment">/// release data to cache</span></div><div class="line">  cache-&gt;Release(h);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb snapshot解析]]></title>
      <url>/2017/06/23/leveldb-snapshot%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在leveldb之中，提供了快照机制，保证不同时刻定义的iterator能够获得与当前时刻保持一致的视图，在遍历访问数据库时仍然可以对数据库进行修改，而不用锁死整个数据库。</p>
<p>获取快照实际上是返回当前最新的读写记录的sequence number，并将这个值记录在链表之中。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Snapshot* DBImpl::GetSnapshot() &#123;</div><div class="line">  <span class="comment">/// 记录当前version构建snapshot对象，并将其插入链表之中</span></div><div class="line">  MutexLock l(&amp;mutex_);</div><div class="line">  <span class="keyword">return</span> snapshots_.<span class="keyword">New</span>(versions_-&gt;LastSequence());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除非进行compaction操作，否则具有相同key但是sequence number不同的记录不会精简只保留sequence number最大的哪一个。leveldb保证在compaction操作时，不会将user key相同，但sequence number大于取出的snapshots列表中最小的那个snapshot的记录删除。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// db/db_impl.cc DoCompactionWork</span></div><div class="line">...</div><div class="line"> <span class="keyword">if</span> (snapshots_.empty()) &#123;</div><div class="line">    <span class="comment">/// 记录最小的snapshots_编号</span></div><div class="line">    <span class="function"><span class="title">compact</span>-&gt;</span><span class="function"><span class="title">smallest_snapshot</span> = versions_-&gt;</span>LastSequence();</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">/// 取snapshot列表之中最小的sequence number</span></div><div class="line">    <span class="function"><span class="title">compact</span>-&gt;</span><span class="function"><span class="title">smallest_snapshot</span> = snapshots_.oldest()-&gt;</span>number_;</div><div class="line">  &#125;</div><div class="line">...</div><div class="line">      <span class="comment">/// 若sequence number 小于 snapshot list中最小的那个sequence number</span></div><div class="line">      <span class="function"><span class="title">if</span> (last_sequence_for_key &lt;= compact-&gt;</span>smallest_snapshot) &#123;</div><div class="line">        <span class="comment">// Hidden by an newer entry for same user key</span></div><div class="line">        drop = <span class="literal">true</span>;    <span class="comment">// (A)</span></div><div class="line">      &#125;</div><div class="line">      <span class="comment">/// key是删除的，并且该key不位于指定的Snapshot之内，并且key在level-n+1以上的level中</span></div><div class="line">      <span class="comment">/// 不存在，则丢弃</span></div><div class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (ikey.type == kTypeDeletion &amp;&amp;</div><div class="line">                 <span class="function"><span class="title">ikey</span>.sequence &lt;= compact-&gt;</span>smallest_snapshot &amp;&amp;</div><div class="line">                 <span class="function"><span class="title">compact</span>-&gt;</span><span class="function"><span class="title">compaction</span>-&gt;</span>IsBaseLevelForKey(ikey.user_key)) &#123;</div><div class="line">        <span class="comment">// For this user key:</span></div><div class="line">        <span class="comment">// (1) there is no data in higher levels</span></div><div class="line">        <span class="comment">// (2) data in lower levels will have larger sequence numbers</span></div><div class="line">        <span class="comment">// (3) data in layers that are being compacted here and have</span></div><div class="line">        <span class="comment">//     smaller sequence numbers will be dropped in the next</span></div><div class="line">        <span class="comment">//     few iterations of this loop (by rule (A) above).</span></div><div class="line">        <span class="comment">// Therefore this deletion marker is obsolete and can be dropped.</span></div><div class="line">        drop = <span class="literal">true</span>;</div><div class="line">      &#125;</div></pre></td></tr></table></figure>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>snapshot的实现是基于一个简单的双向链表，链表中每一个结点都记录一个sequence number。双向链表的末尾对应的是sequence number最小的snapshot。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// snapshots存在DB的双向链表之中，每一个SnapshotImpl对应一个结点</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnapshotImpl</span> :</span> <span class="keyword">public</span> Snapshot &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  SequenceNumber number_;  <span class="comment">// const after creation</span></div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">SnapshotList</span>;</span></div><div class="line"></div><div class="line">  <span class="comment">// SnapshotImpl is kept in a doubly-linked circular list</span></div><div class="line">  SnapshotImpl* prev_;</div><div class="line">  SnapshotImpl* next_;</div><div class="line"></div><div class="line">  SnapshotList* list_;                 <span class="comment">// just for sanity checks</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>双向环形链表：</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">SnapshotList</span> </span>&#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  SnapshotList() &#123;</div><div class="line">    list_.prev_ = &amp;list_;</div><div class="line">    list_.next_ = &amp;list_;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">bool</span> <span class="keyword">empty</span>() <span class="keyword">const</span> &#123; <span class="keyword">return</span> list_.next_ == &amp;list_; &#125;</div><div class="line">  SnapshotImpl* oldest() <span class="keyword">const</span> &#123; assert(!<span class="keyword">empty</span>()); <span class="keyword">return</span> list_.next_; &#125;</div><div class="line">  SnapshotImpl* newest() <span class="keyword">const</span> &#123; assert(!<span class="keyword">empty</span>()); <span class="keyword">return</span> list_.prev_; &#125;</div><div class="line"></div><div class="line">  <span class="comment">/// 在链表头部插入一个新的结点</span></div><div class="line">  <span class="keyword">const</span> SnapshotImpl* <span class="keyword">New</span>(SequenceNumber seq) &#123;</div><div class="line">    <span class="comment">/// 创建结点</span></div><div class="line">    SnapshotImpl* s = <span class="keyword">new</span> SnapshotImpl;</div><div class="line">    <span class="comment">/// 记录sequence</span></div><div class="line">    s-&gt;number_ = seq;</div><div class="line">    s-&gt;list_ = this;</div><div class="line">    s-&gt;next_ = &amp;list_;</div><div class="line">    s-&gt;prev_ = list_.prev_;</div><div class="line">    s-&gt;prev_-&gt;next_ = s;</div><div class="line">    s-&gt;next_-&gt;prev_ = s;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/// 从list中删除s所对应的节点</span></div><div class="line">  void Delete(<span class="keyword">const</span> SnapshotImpl* s) &#123;</div><div class="line">    assert(s-&gt;list_ == this);</div><div class="line">    s-&gt;prev_-&gt;next_ = s-&gt;next_;</div><div class="line">    s-&gt;next_-&gt;prev_ = s-&gt;prev_;</div><div class="line">    delete s;</div><div class="line">  &#125;</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="comment">// Dummy head of doubly-linked list of snapshots</span></div><div class="line">  SnapshotImpl list_;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb WriteBatch解析]]></title>
      <url>/2017/06/23/leveldb-WriteBatch%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>在leveldb之中，包括put，delete等操作都是基于对WriteBatch的操作。当多线程同时调用put时，会将put操作组合起来合并成为一个WriteBatch对象，统一写入到memtable之中。</p>
<p>WriteBatch的具体格式如下所示：<br><img src="https://ww2.sinaimg.cn/large/a15b4afegy1fgv2xvt003j20ib02sq2r" alt="WriteBatch"></p>
<p>从图中可以发现，WriteBatch由sequence number，count和records构成，其中count记载了record的数目。sequence number是第一条record所对应的sequence number。</p>
<p>记录的类型有两种，分别对应添加和删除两种操作，这两种记录的格式如下所示：</p>
<ul>
<li><p>Put<br><img src="https://ww2.sinaimg.cn/large/a15b4afegy1fgv34gonm5j20f602tmwy" alt=""></p>
</li>
<li><p>Delete</p>
</li>
</ul>
<p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1fgv3rcwo4dj30bz032a9u.jpg" alt=""></p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>在WriteBatch之中，内部使用一个string存放所有的记录。按照WriteBatch的格式定义，对于Put和Delete操作，很容易理解以下代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> WriteBatch::Put(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value) &#123;</div><div class="line">  <span class="comment">/// 更新count值</span></div><div class="line">  WriteBatchInternal::SetCount(<span class="keyword">this</span>, WriteBatchInternal::Count(<span class="keyword">this</span>) + <span class="number">1</span>);</div><div class="line">  <span class="comment">/// 类型为kTypeValue</span></div><div class="line">  rep_.push_back(<span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(kTypeValue));</div><div class="line">  <span class="comment">/// key</span></div><div class="line">  PutLengthPrefixedSlice(&amp;rep_, key);</div><div class="line">  <span class="comment">/// value</span></div><div class="line">  PutLengthPrefixedSlice(&amp;rep_, value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> WriteBatch::Delete(<span class="keyword">const</span> Slice&amp; key) &#123;</div><div class="line">  <span class="comment">/// 更新Count值</span></div><div class="line">  WriteBatchInternal::SetCount(<span class="keyword">this</span>, WriteBatchInternal::Count(<span class="keyword">this</span>) + <span class="number">1</span>);</div><div class="line">  <span class="comment">/// 类型为kTypeDeletion</span></div><div class="line">  rep_.push_back(<span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(kTypeDeletion));</div><div class="line">  <span class="comment">/// 存储key</span></div><div class="line">  PutLengthPrefixedSlice(&amp;rep_, key);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在WriteBatch之中，还提供了Iterate操作，其实质上是从前往后依次遍历WriteBatch之中内部存储的记录，将所记录的操作通过handler在memtable上执行。如果执行的record数目与count不同，说明发生了错误。</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">Status WriteBatch::Iterate(Handler* handler) <span class="keyword">const</span> &#123;</div><div class="line">  Slice input(rep_);</div><div class="line">  <span class="comment">/// rep_的大小不可能小于kHeader</span></div><div class="line">  <span class="keyword">if</span> (input.size() &lt; kHeader) &#123;</div><div class="line">    <span class="keyword">return</span> Status::Corruption(<span class="string">"malformed WriteBatch (too small)"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  input.remove_prefix(kHeader);</div><div class="line">  Slice key, value;</div><div class="line">  <span class="keyword">int</span> found = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span> (!input.<span class="keyword">empty</span>()) &#123;</div><div class="line">    found++;</div><div class="line">    <span class="keyword">char</span> tag = input[<span class="number">0</span>];</div><div class="line">    input.remove_prefix(<span class="number">1</span>);</div><div class="line">    <span class="keyword">switch</span> (tag) &#123;</div><div class="line">      <span class="keyword">case</span> kTypeValue:</div><div class="line">        <span class="keyword">if</span> (GetLengthPrefixedSlice(&amp;input, &amp;key) &amp;&amp;</div><div class="line">            GetLengthPrefixedSlice(&amp;input, &amp;value)) &#123;</div><div class="line">          <span class="comment">/// 向memtable中进行插入</span></div><div class="line">          handler-&gt;Put(key, value);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="keyword">return</span> Status::Corruption(<span class="string">"bad WriteBatch Put"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">case</span> kTypeDeletion:</div><div class="line">        <span class="keyword">if</span> (GetLengthPrefixedSlice(&amp;input, &amp;key)) &#123;</div><div class="line">          <span class="comment">/// 从memtable之中删除</span></div><div class="line">          handler-&gt;Delete(key);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="keyword">return</span> Status::Corruption(<span class="string">"bad WriteBatch Delete"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="keyword">default</span>:</div><div class="line">        <span class="keyword">return</span> Status::Corruption(<span class="string">"unknown WriteBatch tag"</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">/// iterate的数量不一致</span></div><div class="line">  <span class="keyword">if</span> (found != WriteBatchInternal::Count(this)) &#123;</div><div class="line">    <span class="keyword">return</span> Status::Corruption(<span class="string">"WriteBatch has wrong count"</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> Status::OK();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb memtable解析]]></title>
      <url>/2017/06/23/leveldb-memtable%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在leveldb之中，写入的数据会首先写入到memtable之中。如果memtable写入达到上限，会转换成为immutable memtable。之后通过compaction操作，将memtable转换成为sstable进行存储。整个系统的架构如下所示：</p>
<p><img src="https://ww2.sinaimg.cn/large/a15b4afegy1fguz8sqb4uj20nn0dbt9g" alt=""></p>
<p>leveldb中的memtable和immutable memtable都是由数据结构skiplist来组织的。跳表中存储的数据包含用户输入的key和value，但是为了判断前后关系只需要取出key来进行比较。因而，需要自定义comparator来实现正确的比较方式。</p>
<h1 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h1><p>在memtable之中，为了存储key和value的值，将二者组合起来存储需要记录二者的长度。因而，skiplist中存储的记录包含：key长度 + key + value长度 + value。此key还包括sequence number以及type。所以添加记录需要进行如下处理：</p>
<figure class="highlight irpf90"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">void MemTable::Add(SequenceNumber s, ValueType <span class="keyword">type</span>,</div><div class="line">                   const Slice&amp; key,</div><div class="line">                   const Slice&amp; <span class="keyword">value</span>) &#123;</div><div class="line">  // <span class="keyword">Format</span> of an <span class="built_in">entry</span> is concatenation of:</div><div class="line">  //  key_size     : varint32 of internal_key.<span class="built_in">size</span>()</div><div class="line">  //  key bytes    : <span class="built_in">char</span>[internal_key.<span class="built_in">size</span>()]</div><div class="line">  //  value_size   : varint32 of <span class="keyword">value</span>.<span class="built_in">size</span>()</div><div class="line">  //  <span class="keyword">value</span> bytes  : <span class="built_in">char</span>[<span class="keyword">value</span>.<span class="built_in">size</span>()]</div><div class="line">  size_t key_size = key.<span class="built_in">size</span>();</div><div class="line">  size_t val_size = <span class="keyword">value</span>.<span class="built_in">size</span>();</div><div class="line">  /// <span class="keyword">sequence</span> <span class="keyword">number</span> + <span class="keyword">value</span> <span class="keyword">type</span> (bytes)</div><div class="line">  size_t internal_key_size = key_size + <span class="number">8</span>;</div><div class="line">  ///实际存储: internal key length + internal key + <span class="keyword">data</span> length + <span class="keyword">data</span></div><div class="line">  const size_t encoded_len =</div><div class="line">      VarintLength(internal_key_size) + internal_key_size +</div><div class="line">      VarintLength(val_size) + val_size;</div><div class="line">  <span class="built_in">char</span>* buf = arena_.<span class="built_in">Allocate</span>(encoded_len);</div><div class="line">  <span class="built_in">char</span>* p = EncodeVarint32(buf, internal_key_size);</div><div class="line">  memcpy(p, key.<span class="keyword">data</span>(), key_size);</div><div class="line">  p += key_size;</div><div class="line">  EncodeFixed64(p, (s &lt;&lt; <span class="number">8</span>) | <span class="keyword">type</span>);</div><div class="line">  p += <span class="number">8</span>;</div><div class="line">  p = EncodeVarint32(p, val_size);</div><div class="line">  memcpy(p, <span class="keyword">value</span>.<span class="keyword">data</span>(), val_size);</div><div class="line">  <span class="keyword">assert</span>((p + val_size) - buf == encoded_len);</div><div class="line">  table_.Insert(buf);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而搜索需要输入的是LookupKey，这是skiplist内部用于搜索的key。其中包含的是整个key的长度，user key以及value type 和 sequence number。借助skiplist提供的迭代器进行搜索，根据返回key的值和类型返回结果。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> MemTable::Get(<span class="keyword">const</span> LookupKey&amp; key, <span class="built_in">std</span>::<span class="built_in">string</span>* value, Status* s) &#123;</div><div class="line">  <span class="comment">// key length, key, sequence number + value type</span></div><div class="line">  Slice memkey = key.memtable_key();</div><div class="line">  Table::<span class="function">Iterator <span class="title">iter</span><span class="params">(&amp;table_)</span></span>;</div><div class="line">  iter.Seek(memkey.data());</div><div class="line">  <span class="keyword">if</span> (iter.Valid()) &#123;</div><div class="line">    <span class="comment">// entry format is:</span></div><div class="line">    <span class="comment">//    klength  varint32</span></div><div class="line">    <span class="comment">//    userkey  char[klength]</span></div><div class="line">    <span class="comment">//    tag      uint64</span></div><div class="line">    <span class="comment">//    vlength  varint32</span></div><div class="line">    <span class="comment">//    value    char[vlength]</span></div><div class="line">    <span class="comment">// Check that it belongs to same user key.  We do not check the</span></div><div class="line">    <span class="comment">// sequence number since the Seek() call above should have skipped</span></div><div class="line">    <span class="comment">// all entries with overly large sequence numbers.</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* entry = iter.key();</div><div class="line">    <span class="keyword">uint32_t</span> key_length;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* key_ptr = GetVarint32Ptr(entry, entry+<span class="number">5</span>, &amp;key_length);</div><div class="line">    <span class="keyword">if</span> (comparator_.comparator.user_comparator()-&gt;Compare(</div><div class="line">            Slice(key_ptr, key_length - <span class="number">8</span>),</div><div class="line">            key.user_key()) == <span class="number">0</span>) &#123;</div><div class="line">      <span class="comment">// Correct user key</span></div><div class="line">      <span class="keyword">const</span> <span class="keyword">uint64_t</span> tag = DecodeFixed64(key_ptr + key_length - <span class="number">8</span>);</div><div class="line">      <span class="keyword">switch</span> (<span class="keyword">static_cast</span>&lt;ValueType&gt;(tag &amp; <span class="number">0xff</span>)) &#123;</div><div class="line">        <span class="keyword">case</span> kTypeValue: &#123;</div><div class="line">          Slice v = GetLengthPrefixedSlice(key_ptr + key_length);</div><div class="line">          value-&gt;assign(v.data(), v.size());</div><div class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">/// 删除的记录，其标记是kTypeDeletion</span></div><div class="line">        <span class="keyword">case</span> kTypeDeletion:</div><div class="line">          *s = Status::NotFound(Slice());</div><div class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>memtable对外提供范文的Iterator实际上是对skiplist迭代器的封装，使其符合Iterator接口。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">class MemTableIterator: <span class="keyword">public</span> Iterator &#123;</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="keyword">explicit</span> MemTableIterator(MemTable::Table* table) : iter_(table) &#123; &#125;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keyword">bool</span> Valid() <span class="keyword">const</span> &#123; <span class="built_in">return</span> iter_.Valid(); &#125;</div><div class="line">  <span class="comment">/// seek要将key 转换为internal key</span></div><div class="line">  <span class="keyword">virtual</span> <span class="keyword">void</span> Seek(<span class="keyword">const</span> Slice&amp; k) &#123; iter_.Seek(EncodeKey(&amp;tmp_, k)); &#125;</div><div class="line">  <span class="keyword">virtual</span> <span class="keyword">void</span> SeekToFirst() &#123; iter_.SeekToFirst(); &#125;</div><div class="line">  <span class="keyword">virtual</span> <span class="keyword">void</span> SeekToLast() &#123; iter_.SeekToLast(); &#125;</div><div class="line">  <span class="keyword">virtual</span> <span class="keyword">void</span> Next() &#123; iter_.Next(); &#125;</div><div class="line">  <span class="keyword">virtual</span> <span class="keyword">void</span> Prev() &#123; iter_.Prev(); &#125;</div><div class="line">  <span class="keyword">virtual</span> Slice key() <span class="keyword">const</span> &#123; <span class="built_in">return</span> GetLengthPrefixedSlice(iter_.key()); &#125;</div><div class="line">  <span class="keyword">virtual</span> Slice value() <span class="keyword">const</span> &#123;</div><div class="line">    Slice key_slice = GetLengthPrefixedSlice(iter_.key());</div><div class="line">    <span class="comment">/// 存储value 也是长度(varint32) + 数据</span></div><div class="line">    <span class="built_in">return</span> GetLengthPrefixedSlice(key_slice.data() + key_slice.<span class="built_in">size</span>());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> Status status() <span class="keyword">const</span> &#123; <span class="built_in">return</span> Status::OK(); &#125;</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  MemTable::Table::Iterator iter_;</div><div class="line">  std::<span class="keyword">string</span> tmp_;       <span class="comment">// For passing to EncodeKey</span></div><div class="line"></div><div class="line">  <span class="comment">// No copying allowed</span></div><div class="line">  MemTableIterator(<span class="keyword">const</span> MemTableIterator&amp;);</div><div class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> MemTableIterator&amp;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>skiplist内部使用的比较器是基于user key, sequence number以及value type进行比较的，如下所示：</p>
<pre><code>int MemTable::KeyComparator::operator()(const char* aptr, const char* bptr)
    const {
  // Internal keys are encoded as length-prefixed strings.
  Slice a = GetLengthPrefixedSlice(aptr);
  Slice b = GetLengthPrefixedSlice(bptr);
  /// compare internal key
  return comparator.Compare(a, b);
}
</code></pre>]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb log模块解析]]></title>
      <url>/2017/06/23/leveldb-log%E6%A8%A1%E5%9D%97%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>leveldb在写入数据的时候，不仅将数据写入memtable，而且写入到log文件之后才认为写入完成。log是通过追加写入，保证了写入速度；数据落盘之后才对外提供访问，保证了数据的完整性。数据库在重新打开时，会从log文件之中恢复memtable文件的数据。</p>
<p>leveldb在存储log记录的时候，log文件内部的格式如下图所示：</p>
<p><img src="https://ww2.sinaimg.cn/large/a15b4afegy1fguxicicdgj20kg0bw3ze" alt=""></p>
<p>整个log文件由很多个数据块构成，如果一条记录能够完整地存储在当前数据块之中，其类型应该为FULL。如果一条record分散地存储在不同的数据块之中，则他会被分解成几个record，每个record的类型分别按照先后顺序对应FIRST，MIDDLE或者LAST。</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">RecordType</span> &#123;</span></div><div class="line">  /<span class="regexp">/ Zero is reserved for preallocated files</span></div><div class="line">  kZeroType = 0,</div><div class="line"></div><div class="line">  kFullType = 1, /<span class="regexp">/ 记录在块内部已经完整了</span></div><div class="line"></div><div class="line">  /<span class="regexp">/ For fragments</span></div><div class="line">  kFirstType = 2, /<span class="regexp">/ 开头</span></div><div class="line">  kMiddleType = 3, /<span class="regexp">/ 中间</span></div><div class="line">  kLastType = 4 /<span class="regexp">/ 结尾</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>为了保证每一条数据的数据完整性，记录数据类型，每一条具体的记录又由检验码，记录长度，类型和数据构成。</p>
<p><img src="https://ww2.sinaimg.cn/large/a15b4afegy1fguxoyz3qlj20hh04fjse" alt=""></p>
<h1 id="写入log记录"><a href="#写入log记录" class="headerlink" title="写入log记录"></a>写入log记录</h1><p>写入记录时，若当前块剩余空间小于kHeaderSize，填充全0。对于写入的记录，根据当前块剩余大小以及剩余要写入的数据量的大小确定其所属的类型，然后将其写入到log文件之中。每一次写入之后都会flush文件，保证数据完整落盘。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// 向数据块之中添加记录</span></div><div class="line">Status Writer::AddRecord(<span class="keyword">const</span> Slice&amp; slice) &#123;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* ptr = slice.data();</div><div class="line">  <span class="comment">// 剩余需要写入的数据量</span></div><div class="line">  <span class="keyword">size_t</span> left = slice.size();</div><div class="line"></div><div class="line">  <span class="comment">// Fragment the record if necessary and emit it.  Note that if slice</span></div><div class="line">  <span class="comment">// is empty, we still want to iterate once to emit a single</span></div><div class="line">  <span class="comment">// zero-length record</span></div><div class="line">  <span class="comment">/// 如果slice是空的，我们仍然会产生一个0长度的记录</span></div><div class="line">  Status s;</div><div class="line">  <span class="keyword">bool</span> begin = <span class="literal">true</span>;</div><div class="line">  <span class="keyword">do</span> &#123;</div><div class="line">    <span class="comment">/// 剩余空间</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">int</span> leftover = kBlockSize - block_offset_;</div><div class="line">    assert(leftover &gt;= <span class="number">0</span>);</div><div class="line">    <span class="comment">/// 剩余空间不足以写入header，填充全0</span></div><div class="line">    <span class="keyword">if</span> (leftover &lt; kHeaderSize) &#123;</div><div class="line">      <span class="comment">// Switch to a new block</span></div><div class="line">      <span class="keyword">if</span> (leftover &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// Fill the trailer (literal below relies on kHeaderSize being 7)</span></div><div class="line">        assert(kHeaderSize == <span class="number">7</span>);</div><div class="line">        <span class="comment">/// 块剩余的空间填充全0</span></div><div class="line">        dest_-&gt;Append(Slice(<span class="string">"\x00\x00\x00\x00\x00\x00"</span>, leftover));</div><div class="line">      &#125;</div><div class="line">      block_offset_ = <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Invariant: we never leave &lt; kHeaderSize bytes in a block.</span></div><div class="line">    assert(kBlockSize - block_offset_ - kHeaderSize &gt;= <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">/// 可用空间</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> avail = kBlockSize - block_offset_ - kHeaderSize;</div><div class="line">    <span class="comment">/// 分段长度</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> fragment_length = (left &lt; avail) ? left : avail;</div><div class="line"></div><div class="line">    RecordType type;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">bool</span> end = (left == fragment_length);</div><div class="line">    <span class="keyword">if</span> (begin &amp;&amp; end) &#123; <span class="comment">// 全部放入此数据块中</span></div><div class="line">      type = kFullType;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (begin) &#123; <span class="comment">// 数据的开始部分放入此数据块中</span></div><div class="line">      type = kFirstType;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (end) &#123; <span class="comment">// 数据的结束部分放入此数据块中</span></div><div class="line">      type = kLastType;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      type = kMiddleType; <span class="comment">// 数据的中间部分放入此数据块中</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    s = EmitPhysicalRecord(type, ptr, fragment_length);</div><div class="line">    ptr += fragment_length;</div><div class="line">    left -= fragment_length;</div><div class="line">    begin = <span class="literal">false</span>;</div><div class="line">  &#125; <span class="keyword">while</span> (s.ok() &amp;&amp; left &gt; <span class="number">0</span>);</div><div class="line">  <span class="keyword">return</span> s;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/// 存储物理记录</span></div><div class="line">Status Writer::EmitPhysicalRecord(RecordType t, <span class="keyword">const</span> <span class="keyword">char</span>* ptr, <span class="keyword">size_t</span> n) &#123;</div><div class="line">  assert(n &lt;= <span class="number">0xffff</span>);  <span class="comment">// Must fit in two bytes</span></div><div class="line">  assert(block_offset_ + kHeaderSize + n &lt;= kBlockSize);</div><div class="line"></div><div class="line">  <span class="comment">// Format the header</span></div><div class="line">  <span class="keyword">char</span> buf[kHeaderSize];</div><div class="line">  <span class="comment">/// 存储记录的长度</span></div><div class="line">  <span class="comment">/// 末尾1byte</span></div><div class="line">  buf[<span class="number">4</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(n &amp; <span class="number">0xff</span>);</div><div class="line">  <span class="comment">/// 开头处1byte</span></div><div class="line">  buf[<span class="number">5</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(n &gt;&gt; <span class="number">8</span>);</div><div class="line">  <span class="comment">// type</span></div><div class="line">  buf[<span class="number">6</span>] = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(t);</div><div class="line"></div><div class="line">  <span class="comment">// Compute the crc of the record type and the payload.</span></div><div class="line">  <span class="keyword">uint32_t</span> crc = crc32c::Extend(type_crc_[t], ptr, n);</div><div class="line">  crc = crc32c::Mask(crc);                 <span class="comment">// Adjust for storage</span></div><div class="line">  EncodeFixed32(buf, crc);</div><div class="line"></div><div class="line">  <span class="comment">// Write the header and the payload</span></div><div class="line">  Status s = dest_-&gt;Append(Slice(buf, kHeaderSize));</div><div class="line">  <span class="keyword">if</span> (s.ok()) &#123;</div><div class="line">    <span class="comment">/// 写入数据部分</span></div><div class="line">    s = dest_-&gt;Append(Slice(ptr, n));</div><div class="line">    <span class="keyword">if</span> (s.ok()) &#123;</div><div class="line">      <span class="comment">// flush data into file</span></div><div class="line">      <span class="comment">/// 保证数据落盘</span></div><div class="line">      s = dest_-&gt;Flush();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 更新block_offset_</span></div><div class="line">  block_offset_ += kHeaderSize + n;</div><div class="line">  <span class="keyword">return</span> s;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="读log文件"><a href="#读log文件" class="headerlink" title="读log文件"></a>读log文件</h1><p>对于自定义数据格式文件来说，为了应对各种错误，读操作比写入操作实现起来需要注意更多细节。因为可能会在写入log文件的过程之中，突然因为各种原因崩溃，导致log文件写入不完整，因而读取这一部分操作需要能够正确的处理，这种错误需要进行特殊对待。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// 读取物理记录</span></div><div class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> Reader::ReadPhysicalRecord(Slice* result) &#123;</div><div class="line">  <span class="comment">// loop forever</span></div><div class="line">  <span class="built_in">while</span> (true) &#123;</div><div class="line">    <span class="built_in">if</span> (buffer_.<span class="built_in">size</span>() &lt; kHeaderSize) &#123;</div><div class="line">      <span class="built_in">if</span> (!eof_) &#123;</div><div class="line">        <span class="comment">// Last read was a full read, so this is a trailer to skip</span></div><div class="line">        buffer_.<span class="built_in">clear</span>();</div><div class="line">        <span class="comment">/// 读取下一个数据块</span></div><div class="line">        Status status = file_-&gt;Read(kBlockSize, &amp;buffer_, backing_store_);</div><div class="line">        <span class="comment">/// 更新块级别的offset</span></div><div class="line">        end_of_buffer_offset_ += buffer_.<span class="built_in">size</span>();</div><div class="line">        <span class="built_in">if</span> (!status.ok()) &#123;</div><div class="line">          buffer_.<span class="built_in">clear</span>();</div><div class="line">          ReportDrop(kBlockSize, status);</div><div class="line">          eof_ = true;</div><div class="line">          <span class="built_in">return</span> kEof;</div><div class="line">        &#125; <span class="built_in">else</span> <span class="built_in">if</span> (buffer_.<span class="built_in">size</span>() &lt; kBlockSize) &#123;</div><div class="line">          <span class="comment">/// 读取的数据小于块大小，EOF</span></div><div class="line">          eof_ = true;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">continue</span>;</div><div class="line">      &#125; <span class="built_in">else</span> &#123; <span class="comment">/// EOF &amp;&amp; buffer_.size() &lt; kHeaderSize</span></div><div class="line">        <span class="comment">// Note that if buffer_ is non-empty, we have a truncated header at the</span></div><div class="line">        <span class="comment">// end of the file, which can be caused by the writer crashing in the</span></div><div class="line">        <span class="comment">// middle of writing the header. Instead of considering this an error,</span></div><div class="line">        <span class="comment">// just report EOF.</span></div><div class="line">        <span class="comment">/// 如果buffer_不为空，可能是因为writer在写入header的过程中崩溃了，这不是错误，</span></div><div class="line">        <span class="comment">/// 将这种情况也视为EOF</span></div><div class="line">        buffer_.<span class="built_in">clear</span>();</div><div class="line">        <span class="built_in">return</span> kEof;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Parse the header</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* header = buffer_.data();</div><div class="line">    <span class="keyword">const</span> uint32_t a = <span class="keyword">static_cast</span>&lt;uint32_t&gt;(header[<span class="number">4</span>]) &amp; <span class="number">0xff</span>;</div><div class="line">    <span class="keyword">const</span> uint32_t b = <span class="keyword">static_cast</span>&lt;uint32_t&gt;(header[<span class="number">5</span>]) &amp; <span class="number">0xff</span>;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> type = header[<span class="number">6</span>];</div><div class="line">    <span class="comment">// 获取length记录</span></div><div class="line">    <span class="keyword">const</span> uint32_t length = a | (b &lt;&lt; <span class="number">8</span>);</div><div class="line">    <span class="comment">/// 一条记录的长度不可能超出数据块，除非发生错误</span></div><div class="line">    <span class="built_in">if</span> (kHeaderSize + length &gt; buffer_.<span class="built_in">size</span>()) &#123;</div><div class="line">      size_t drop_size = buffer_.<span class="built_in">size</span>();</div><div class="line">      buffer_.<span class="built_in">clear</span>();</div><div class="line">      <span class="built_in">if</span> (!eof_) &#123;</div><div class="line">        ReportCorruption(drop_size, <span class="string">"bad record length"</span>);</div><div class="line">        <span class="built_in">return</span> kBadRecord;</div><div class="line">      &#125;</div><div class="line">      <span class="comment">// If the end of the file has been reached without reading |length| bytes</span></div><div class="line">      <span class="comment">// of payload, assume the writer died in the middle of writing the record.</span></div><div class="line">      <span class="comment">// Don't report a corruption.</span></div><div class="line">      <span class="comment">/// 假设writer在写入的过程之中崩溃，不认为是错误</span></div><div class="line">      <span class="built_in">return</span> kEof;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/// Zero type 的长度不可能为0，这是一个错误, record 有问题</span></div><div class="line">    <span class="built_in">if</span> (type == kZeroType &amp;&amp; length == <span class="number">0</span>) &#123;</div><div class="line">      <span class="comment">// Skip zero length record without reporting any drops since</span></div><div class="line">      <span class="comment">// such records are produced by the mmap based writing code in</span></div><div class="line">      <span class="comment">// env_posix.cc that preallocates file regions.</span></div><div class="line">      buffer_.<span class="built_in">clear</span>();</div><div class="line">      <span class="built_in">return</span> kBadRecord;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Check crc</span></div><div class="line">    <span class="built_in">if</span> (checksum_) &#123;</div><div class="line">      uint32_t expected_crc = crc32c::Unmask(DecodeFixed32(header));</div><div class="line">      uint32_t actual_crc = crc32c::Value(header + <span class="number">6</span>, <span class="number">1</span> + length);</div><div class="line">      <span class="comment">/// 报告校验失败</span></div><div class="line">      <span class="built_in">if</span> (actual_crc != expected_crc) &#123;</div><div class="line">        <span class="comment">// Drop the rest of the buffer since "length" itself may have</span></div><div class="line">        <span class="comment">// been corrupted and if we trust it, we could find some</span></div><div class="line">        <span class="comment">// fragment of a real log record that just happens to look</span></div><div class="line">        <span class="comment">// like a valid log record.</span></div><div class="line">        size_t drop_size = buffer_.<span class="built_in">size</span>();</div><div class="line">        buffer_.<span class="built_in">clear</span>();</div><div class="line">        ReportCorruption(drop_size, <span class="string">"checksum mismatch"</span>);</div><div class="line">        <span class="built_in">return</span> kBadRecord;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/// remove 前缀</span></div><div class="line">    buffer_.remove_prefix(kHeaderSize + length);</div><div class="line"></div><div class="line">    <span class="comment">// Skip physical record that started before initial_offset_</span></div><div class="line">    <span class="comment">/// warning: buffer_ 已经remove了这条记录</span></div><div class="line">    <span class="built_in">if</span> (end_of_buffer_offset_ - buffer_.<span class="built_in">size</span>() - kHeaderSize - length &lt;</div><div class="line">        initial_offset_) &#123;</div><div class="line">      result-&gt;<span class="built_in">clear</span>();</div><div class="line">      <span class="built_in">return</span> kBadRecord;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">/// only return the record only</span></div><div class="line">    *result = Slice(header + kHeaderSize, length);</div><div class="line">    <span class="built_in">return</span> type;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>读取log记录时，根据读取的数据记录的类型，将分散的记录组合成为完整的record返回给调用者。当出现错误或者读到文件末尾时，此函数都会返回false。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 读取record</span></div><div class="line">bool Reader::ReadRecord(Slice* record, std::string* scratch) &#123;</div><div class="line">  <span class="keyword">if</span> (last_record_offset_ &lt; initial_offset_) &#123;</div><div class="line">    <span class="comment">/// 调到initial_offset_对应的block</span></div><div class="line">    <span class="keyword">if</span> (!SkipToInitialBlock()) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  scratch-&gt;<span class="built_in">clear</span>();</div><div class="line">  record-&gt;<span class="built_in">clear</span>();</div><div class="line">  bool in_fragmented_record = <span class="keyword">false</span>; <span class="comment">// 上条记录是否完整</span></div><div class="line">  <span class="comment">// Record offset of the logical record that we're reading</span></div><div class="line">  <span class="comment">// 0 is a dummy value to make compilers happy</span></div><div class="line">  uint64_t prospective_record_offset = <span class="number">0</span>; <span class="comment">// 记录的偏移量</span></div><div class="line"></div><div class="line">  Slice fragment;</div><div class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">    <span class="comment">/// 读取物理record</span></div><div class="line">    <span class="keyword">const</span> unsigned <span class="built_in">int</span> record_type = ReadPhysicalRecord(&amp;fragment);</div><div class="line"></div><div class="line">    <span class="comment">// ReadPhysicalRecord may have only had an empty trailer remaining in its</span></div><div class="line">    <span class="comment">// internal buffer. Calculate the offset of the next physical record now</span></div><div class="line">    <span class="comment">// that it has returned, properly accounting for its header size.</span></div><div class="line">    <span class="comment">/// 物理记录的偏移, 指向结尾位置</span></div><div class="line">    uint64_t physical_record_offset =</div><div class="line">        end_of_buffer_offset_ - buffer_.<span class="built_in">size</span>() - kHeaderSize - fragment.<span class="built_in">size</span>();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (resyncing_) &#123;</div><div class="line">      <span class="keyword">if</span> (record_type == kMiddleType) &#123;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (record_type == kLastType) &#123;</div><div class="line">        resyncing_ = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">continue</span>;</div><div class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// kFullType</span></div><div class="line">        resyncing_ = <span class="keyword">false</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (record_type) &#123;</div><div class="line">      <span class="keyword">case</span> kFullType:</div><div class="line">        <span class="keyword">if</span> (in_fragmented_record) &#123;</div><div class="line">          <span class="comment">// Handle bug in earlier versions of log::Writer where</span></div><div class="line">          <span class="comment">// it could emit an empty kFirstType record at the tail end</span></div><div class="line">          <span class="comment">// of a block followed by a kFullType or kFirstType record</span></div><div class="line">          <span class="comment">// at the beginning of the next block.</span></div><div class="line">          <span class="keyword">if</span> (scratch-&gt;empty()) &#123;</div><div class="line">            in_fragmented_record = <span class="keyword">false</span>;</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">            ReportCorruption(scratch-&gt;<span class="built_in">size</span>(), <span class="string">"partial record without end(1)"</span>);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">        prospective_record_offset = physical_record_offset;</div><div class="line">        scratch-&gt;<span class="built_in">clear</span>();</div><div class="line">        *record = fragment;</div><div class="line">        last_record_offset_ = prospective_record_offset;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">      <span class="keyword">case</span> kFirstType:</div><div class="line">        <span class="keyword">if</span> (in_fragmented_record) &#123;</div><div class="line">          <span class="comment">// Handle bug in earlier versions of log::Writer where</span></div><div class="line">          <span class="comment">// it could emit an empty kFirstType record at the tail end</span></div><div class="line">          <span class="comment">// of a block followed by a kFullType or kFirstType record</span></div><div class="line">          <span class="comment">// at the beginning of the next block.</span></div><div class="line">          <span class="keyword">if</span> (scratch-&gt;empty()) &#123;</div><div class="line">            in_fragmented_record = <span class="keyword">false</span>;</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">            ReportCorruption(scratch-&gt;<span class="built_in">size</span>(), <span class="string">"partial record without end(2)"</span>);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">        prospective_record_offset = physical_record_offset;</div><div class="line">        <span class="comment">// 将record记录加入scratch之中</span></div><div class="line">        scratch-&gt;assign(fragment.data(), fragment.<span class="built_in">size</span>());</div><div class="line">        in_fragmented_record = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">      <span class="keyword">case</span> kMiddleType:</div><div class="line">        <span class="comment">// 上条记录不完整，报错</span></div><div class="line">        <span class="keyword">if</span> (!in_fragmented_record) &#123;</div><div class="line">          ReportCorruption(fragment.<span class="built_in">size</span>(),</div><div class="line">                           <span class="string">"missing start of fragmented record(1)"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          <span class="comment">// 添加中间的数据块</span></div><div class="line">          scratch-&gt;<span class="built_in">append</span>(fragment.data(), fragment.<span class="built_in">size</span>());</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">      <span class="keyword">case</span> kLastType:</div><div class="line">        <span class="comment">// 上条记录不完整，报错退出</span></div><div class="line">        <span class="keyword">if</span> (!in_fragmented_record) &#123;</div><div class="line">          ReportCorruption(fragment.<span class="built_in">size</span>(),</div><div class="line">                           <span class="string">"missing start of fragmented record(2)"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">          scratch-&gt;<span class="built_in">append</span>(fragment.data(), fragment.<span class="built_in">size</span>());</div><div class="line">          <span class="comment">// 记录最终的结果</span></div><div class="line">          *record = Slice(*scratch);</div><div class="line">          last_record_offset_ = prospective_record_offset;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">      <span class="keyword">case</span> kEof:</div><div class="line">        <span class="keyword">if</span> (in_fragmented_record) &#123;</div><div class="line">          <span class="comment">// This can be caused by the writer dying immediately after</span></div><div class="line">          <span class="comment">// writing a physical record but before completing the next; don't</span></div><div class="line">          <span class="comment">// treat it as a corruption, just ignore the entire logical record.</span></div><div class="line">          scratch-&gt;<span class="built_in">clear</span>();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line"></div><div class="line">      <span class="keyword">case</span> kBadRecord:</div><div class="line">        <span class="keyword">if</span> (in_fragmented_record) &#123;</div><div class="line">          ReportCorruption(scratch-&gt;<span class="built_in">size</span>(), <span class="string">"error in middle of record"</span>);</div><div class="line">          in_fragmented_record = <span class="keyword">false</span>;</div><div class="line">          scratch-&gt;<span class="built_in">clear</span>();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      <span class="comment">// 未知的类型</span></div><div class="line">      <span class="keyword">default</span>: &#123;</div><div class="line">        <span class="built_in">char</span> buf[<span class="number">40</span>];</div><div class="line">        snprintf(buf, sizeof(buf), <span class="string">"unknown record type %u"</span>, record_type);</div><div class="line">        ReportCorruption(</div><div class="line">            (fragment.<span class="built_in">size</span>() + (in_fragmented_record ? scratch-&gt;<span class="built_in">size</span>() : <span class="number">0</span>)),</div><div class="line">            buf);</div><div class="line">        in_fragmented_record = <span class="keyword">false</span>;</div><div class="line">        scratch-&gt;<span class="built_in">clear</span>();</div><div class="line">        <span class="keyword">break</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb dbformat解析]]></title>
      <url>/2017/06/22/leveldb-dbformat%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在leveldb中dbformat中，定义了几种不同类型的key，这几种类型的key的格式都是在dbformat之中定义的。在leveldb之中，会在用户定义的key后面附加上sequence number，用于标志key的先后顺序。在leveldb之中，删除key并不会真正将其从硬盘文件之中删除，而是将其类型标识为已经删除。的类型如下所示：</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">enum</span> <span class="title">ValueType</span> &#123;</span></div><div class="line">  /<span class="regexp">/ 数据已经删除</span></div><div class="line">  kTypeDeletion = 0x0,</div><div class="line">  /<span class="regexp">/ 是有效的value值</span></div><div class="line">  kTypeValue = 0x1</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>实际上，ValueType是和SequenceNumber组合在一起存储的，共占据64bit，其中sequence number占据前56位，后面8位用于标志value的类型。</p>
<h1 id="各种类型的key"><a href="#各种类型的key" class="headerlink" title="各种类型的key"></a>各种类型的key</h1><h2 id="InternalKey"><a href="#InternalKey" class="headerlink" title="InternalKey"></a>InternalKey</h2><p>InternalKey的格式是输入的<code>user_key</code>后面再加上sequence number和标志类型的ValueType。整个key的格式是：user key + sequence number + value type。因而，由ParsedInternalKey存储为字符串需要进行如下操作：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将sequence number 和 value type 组合成为 uint64_t</span></div><div class="line"><span class="keyword">static</span> uint64_t PackSequenceAndType(uint64_t seq, ValueType t) &#123;</div><div class="line">  <span class="keyword">assert</span>(seq &lt;= kMaxSequenceNumber);</div><div class="line">  <span class="keyword">assert</span>(t &lt;= kValueTypeForSeek);</div><div class="line">  <span class="keyword">return</span> (seq &lt;&lt; <span class="number">8</span>) | t;</div><div class="line">&#125;</div><div class="line"><span class="keyword">void</span> AppendInternalKey(std::string* result, <span class="keyword">const</span> ParsedInternalKey&amp; <span class="built_in">key</span>) &#123;</div><div class="line">  result-&gt;<span class="built_in">append</span>(<span class="built_in">key</span>.user_key.data(), <span class="built_in">key</span>.user_key.<span class="built_in">size</span>());</div><div class="line">  PutFixed64(result, PackSequenceAndType(<span class="built_in">key</span>.sequence, <span class="built_in">key</span>.type));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="LookupKey"><a href="#LookupKey" class="headerlink" title="LookupKey"></a>LookupKey</h2><p>LookupKey相比InternalKey，在前面使用varint32格式记录了整个InternalKey所占据的空间大小。整个key的格式是：length + user key + sequence number + value_type。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LookupKey</span> &#123;</span></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="comment">// Initialize *this for looking up user_key at a snapshot with</span></div><div class="line">  <span class="comment">// the specified sequence number.</span></div><div class="line">  LookupKey(<span class="keyword">const</span> Slice&amp; user_key, SequenceNumber sequence);</div><div class="line"></div><div class="line">  ~LookupKey();</div><div class="line"></div><div class="line">  <span class="comment">// Return a key suitable for lookup in a MemTable.</span></div><div class="line">  <span class="function">Slice <span class="title">memtable_key</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> Slice(start_, end_ - start_); &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Return an internal key (suitable for passing to an internal iterator)</span></div><div class="line">  <span class="function">Slice <span class="title">internal_key</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> Slice(kstart_, end_ - kstart_); &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Return the user key</span></div><div class="line">  <span class="function">Slice <span class="title">user_key</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> Slice(kstart_, end_ - kstart_ - <span class="number">8</span>); &#125;</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="comment">/// lookup key 内部format如下所示</span></div><div class="line">  <span class="comment">// We construct a char array of the form:</span></div><div class="line">  <span class="comment">//    klength  varint32               &lt;-- start_</span></div><div class="line">  <span class="comment">//    userkey  char[klength]          &lt;-- kstart_</span></div><div class="line">  <span class="comment">//    tag      uint64</span></div><div class="line">  <span class="comment">//                                    &lt;-- end_</span></div><div class="line">  <span class="comment">// The array is a suitable MemTable key.</span></div><div class="line">  <span class="comment">// The suffix starting with "userkey" can be used as an InternalKey.</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* start_;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* kstart_;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* end_;</div><div class="line">  <span class="keyword">char</span> space_[<span class="number">200</span>];      <span class="comment">// Avoid allocation for short keys</span></div><div class="line"></div><div class="line">  <span class="comment">// No copying allowed</span></div><div class="line">  LookupKey(<span class="keyword">const</span> LookupKey&amp;);</div><div class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> LookupKey&amp;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>LookupKey类内部，<code>start_</code>标志整个LookupKey的开始位置，<code>kstart_</code>指向<code>user_key</code>的开始位置，<code>end_</code>指向整个LookupKey的结束位置。按照LookupKey格式，初始化各类成员，可以理解构造函数。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">LookupKey::LookupKey(<span class="keyword">const</span> Slice&amp; user_key, SequenceNumber s) &#123;</div><div class="line">  size_t <span class="built_in">usize</span> = user_key.size();</div><div class="line">  <span class="comment">/// varint32 + sequence number + value type</span></div><div class="line">  size_t needed = <span class="built_in">usize</span> + <span class="number">13</span>;  <span class="comment">// A conservative estimate</span></div><div class="line">  <span class="built_in">char</span>* dst;</div><div class="line">  <span class="comment">// 空间足够了</span></div><div class="line">  <span class="keyword">if</span> (needed &lt;= <span class="keyword">sizeof</span>(space_)) &#123;</div><div class="line">    dst = space_;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// new 分配空间</span></div><div class="line">    dst = new <span class="built_in">char</span>[needed];</div><div class="line">  &#125;</div><div class="line">  start_ = dst;</div><div class="line">  <span class="comment">// encode length</span></div><div class="line">  dst = EncodeVarint32(dst, <span class="built_in">usize</span> + <span class="number">8</span>);</div><div class="line">  <span class="comment">// start_ 指向user key的开始处</span></div><div class="line">  kstart_ = dst;</div><div class="line">  <span class="comment">// encode user key</span></div><div class="line">  memcpy(dst, user_key.data(), <span class="built_in">usize</span>);</div><div class="line">  dst += <span class="built_in">usize</span>;</div><div class="line">  <span class="comment">// encode sequence number and type</span></div><div class="line">  EncodeFixed64(dst, PackSequenceAndType(s, kValueTypeForSeek));</div><div class="line">  dst += <span class="number">8</span>;</div><div class="line">  <span class="comment">// 指向数据结束处</span></div><div class="line">  end_ = dst;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="InternalKeyComparator"><a href="#InternalKeyComparator" class="headerlink" title="InternalKeyComparator"></a>InternalKeyComparator</h1><p>因为在InternalKey中引入了sequence number和value type，因而需要在Comparator的基础之上引入对Comparator相关接口实现进行改动才能适应。</p>
<p>在进行比较的时候，优先按照user key进行比较，若user key一样，则按照sequence number进行排序，sequence number更大的被视为较小。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// 优先按照user key进行升序排序，然后按照sequence number 降序排序</span></div><div class="line"><span class="comment">/// node-&gt;key key</span></div><div class="line"><span class="keyword">int</span> InternalKeyComparator::Compare(<span class="keyword">const</span> Slice&amp; akey, <span class="keyword">const</span> Slice&amp; bkey) <span class="keyword">const</span> &#123;</div><div class="line">  <span class="comment">// Order by:</span></div><div class="line">  <span class="comment">//    increasing user key (according to user-supplied comparator)</span></div><div class="line">  <span class="comment">//    decreasing sequence number</span></div><div class="line">  <span class="comment">//    decreasing type (though sequence# should be enough to disambiguate)</span></div><div class="line">  <span class="keyword">int</span> r = user_comparator_-&gt;Compare(ExtractUserKey(akey), ExtractUserKey(bkey));</div><div class="line">  <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> anum = DecodeFixed64(akey.data() + akey.size() - <span class="number">8</span>);</div><div class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> bnum = DecodeFixed64(bkey.data() + bkey.size() - <span class="number">8</span>);</div><div class="line">    <span class="keyword">if</span> (anum &gt; bnum) &#123;</div><div class="line">      r = <span class="number">-1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (anum &lt; bnum) &#123;</div><div class="line">      r = +<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> r;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于<code>FindShortestSeparator</code>和<code>FindShortSuccessor</code>操作，需要在基类的基础之上再加上sequence number和value type，sequence number取最大值。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> InternalKeyComparator::FindShortestSeparator(</div><div class="line">      std::string* start,</div><div class="line">      <span class="keyword">const</span> Slice&amp; limit) <span class="keyword">const</span> &#123;</div><div class="line">  <span class="comment">// Attempt to shorten the user portion of the key</span></div><div class="line">  Slice user_start = ExtractUserKey(*start);</div><div class="line">  Slice user_limit = ExtractUserKey(limit);</div><div class="line">  std::string tmp(user_start.data(), user_start.<span class="built_in">size</span>());</div><div class="line">  <span class="comment">/// 找到比user_start大，比user_limit小的key</span></div><div class="line">  user_comparator_-&gt;FindShortestSeparator(&amp;tmp, user_limit);</div><div class="line">  <span class="keyword">if</span> (tmp.<span class="built_in">size</span>() &lt; user_start.<span class="built_in">size</span>() &amp;&amp;</div><div class="line">      user_comparator_-&gt;Compare(user_start, tmp) &lt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">// User key has become shorter physically, but larger logically.</span></div><div class="line">    <span class="comment">// Tack on the earliest possible number to the shortened user key.</span></div><div class="line">    PutFixed64(&amp;tmp, PackSequenceAndType(kMaxSequenceNumber,kValueTypeForSeek));</div><div class="line">    <span class="keyword">assert</span>(<span class="keyword">this</span>-&gt;Compare(*start, tmp) &lt; <span class="number">0</span>);</div><div class="line">    <span class="keyword">assert</span>(<span class="keyword">this</span>-&gt;Compare(tmp, limit) &lt; <span class="number">0</span>);</div><div class="line">    start-&gt;swap(tmp);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> InternalKeyComparator::FindShortSuccessor(std::string* <span class="built_in">key</span>) <span class="keyword">const</span> &#123;</div><div class="line">  Slice user_key = ExtractUserKey(*<span class="built_in">key</span>);</div><div class="line">  std::string tmp(user_key.data(), user_key.<span class="built_in">size</span>());</div><div class="line">  <span class="comment">/// 找到比key大的key, 存于tmp中</span></div><div class="line">  user_comparator_-&gt;FindShortSuccessor(&amp;tmp);</div><div class="line">  <span class="keyword">if</span> (tmp.<span class="built_in">size</span>() &lt; user_key.<span class="built_in">size</span>() &amp;&amp;</div><div class="line">      user_comparator_-&gt;Compare(user_key, tmp) &lt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">// User key has become shorter physically, but larger logically.</span></div><div class="line">    <span class="comment">// Tack on the earliest possible number to the shortened user key.</span></div><div class="line">    PutFixed64(&amp;tmp, PackSequenceAndType(kMaxSequenceNumber,kValueTypeForSeek));</div><div class="line">    <span class="keyword">assert</span>(<span class="keyword">this</span>-&gt;Compare(*<span class="built_in">key</span>, tmp) &lt; <span class="number">0</span>);</div><div class="line">    <span class="built_in">key</span>-&gt;swap(tmp);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb跳表]]></title>
      <url>/2017/06/22/leveldb%E8%B7%B3%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p>跳跃链表允许快速查询一个有序连续元素的数据链表。快速查询是通过维护一个多层次的链表，且每一层链表中的元素是前一层链表元素的子集。基于并联的链表，其效率可以比拟二叉查找树。在leveldb之中，基本的memtable和immutable memtable就是基于跳表实现的。leveldb内部键值对的有序性也是基于跳表的从前到后的有序性实现的。</p>
<p>基本的跳表结构如下所示:<br><img src="http://static.zybuluo.com/zhoudayang/ufvy4pc2g55hio7kei2hznb3/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f322f32632f536b69705f6c6973745f6164645f656c656d656e742d656e2e676966.gif" alt="68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f322f32632f536b69705f6c6973745f6164645f656c656d656e742d656e2e676966.gif-47.9kB"></p>
<p>我们可以发现，跳表之中每一个结点的高度是随机的，相同高度的节点按照key的先后顺序前后相连，高层次的链表中的节点更加稀疏。因此，在执行搜索的时候，不要从底层的链表开始一次遍历，只需要首先沿着高层链表依次往后遍历，直到刚好到达整个跳表尾端前面刚好大于等于要搜索的key的位置，然后再往下在低层的链表中继续按照此策略搜索，直至到达最底层的链表顺序遍历搜索。可以发现，采取这种搜索策略，大大加快了搜索的速度。实际上，跳表的搜索效率是和平衡二叉树一致的，都是<code>nlogn</code>级别。</p>
<h1 id="实现简介"><a href="#实现简介" class="headerlink" title="实现简介"></a>实现简介</h1><h2 id="原子指针"><a href="#原子指针" class="headerlink" title="原子指针"></a>原子指针</h2><p>在leveldb之中，为了支持对memtable的并发访问，在实现跳表的时候，使用了原子指针数据结构。其实现主要是利用内存屏障，在对指针变量有更新的时候，使用内存屏障保证先后顺序，并且使得其他线程cache中的指针值失效，触发从内存之中重新读取。同样，在load指针值的时候，也使用内存屏障，保证先后顺序，保证读操作之前的所有写入操作生效之后，再从内存之中读取最新的指针值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span>* <span class="title">Acquire_Load</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">    <span class="keyword">void</span>* result = rep_;</div><div class="line">    MemoryBarrier();</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Release_Store</span><span class="params">(<span class="keyword">void</span>* v)</span> </span>&#123;</div><div class="line">    MemoryBarrier();</div><div class="line">    rep_ = v;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>跳表之中每个结点都是由一个<code>port::AtomicPointer</code>类型的数组构成，数组中的每一个成员对应跳表中某一层次的节点。关于指针的存取，为了充分提升性能，定义了非原子操作和原子操作的版本，区别使用。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Implementation details follow</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, class Comparator&gt;</div><div class="line">struct SkipList&lt;Key,Comparator&gt;::Node &#123;</div><div class="line">  <span class="keyword">explicit</span> Node(<span class="keyword">const</span> Key&amp; k) : key(k) &#123; &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 键</span></div><div class="line">  Key <span class="keyword">const</span> key;</div><div class="line"></div><div class="line">  <span class="comment">// Accessors/mutators for links.  Wrapped in methods so we can</span></div><div class="line">  <span class="comment">// add the appropriate barriers as necessary.</span></div><div class="line">  <span class="comment">// 获取n对应level的链表结点</span></div><div class="line">  Node* Next(<span class="keyword">int</span> n) &#123;</div><div class="line">    assert(n &gt;= <span class="number">0</span>);</div><div class="line">    <span class="comment">// Use an 'acquire load' so that we observe a fully initialized</span></div><div class="line">    <span class="comment">// version of the returned Node.</span></div><div class="line">    <span class="built_in">return</span> <span class="keyword">reinterpret_cast</span>&lt;Node*&gt;(next_[n].Acquire_Load());</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 设置n对应level上的链表结点</span></div><div class="line">  <span class="keyword">void</span> SetNext(<span class="keyword">int</span> n, Node* x) &#123;</div><div class="line">    assert(n &gt;= <span class="number">0</span>);</div><div class="line">    <span class="comment">// Use a 'release store' so that anybody who reads through this</span></div><div class="line">    <span class="comment">// pointer observes a fully initialized version of the inserted node.</span></div><div class="line">    next_[n].Release_Store(x);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/// No-barrier version</span></div><div class="line">  <span class="comment">// No-barrier variants that can be safely used in a few locations.</span></div><div class="line">  Node* NoBarrier_Next(<span class="keyword">int</span> n) &#123;</div><div class="line">    assert(n &gt;= <span class="number">0</span>);</div><div class="line">    <span class="built_in">return</span> <span class="keyword">reinterpret_cast</span>&lt;Node*&gt;(next_[n].NoBarrier_Load());</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">void</span> NoBarrier_SetNext(<span class="keyword">int</span> n, Node* x) &#123;</div><div class="line">    assert(n &gt;= <span class="number">0</span>);</div><div class="line">    next_[n].NoBarrier_Store(x);</div><div class="line">  &#125;</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="comment">// Array of length equal to the node height.  next_[0] is lowest level link.</span></div><div class="line">  <span class="comment">// 指向第一个level，实质上此数组的大小并不为1，这是c中struct的一个tricky</span></div><div class="line">  port::AtomicPointer next_[<span class="number">1</span>];</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在创建新节点的时候，使用内置的Arena内存分配器分配内存。节点中数组的大小为<code>kMaxHeight</code>，这是整个跳表所能够支持的最高层级。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></div><div class="line"><span class="title">typename</span> <span class="title">SkipList</span>&lt;Key,Comparator&gt;::Node*</div><div class="line">SkipList&lt;Key,Comparator&gt;::NewNode(<span class="keyword">const</span> Key&amp; key, <span class="keyword">int</span> height) &#123;</div><div class="line">  <span class="comment">/// 数组的capacity为height</span></div><div class="line">  <span class="comment">//调用Arena内存分配器进行分配</span></div><div class="line">  <span class="keyword">char</span>* mem = arena_-&gt;AllocateAligned(</div><div class="line">      <span class="keyword">sizeof</span>(Node) + <span class="keyword">sizeof</span>(port::AtomicPointer) * (height - <span class="number">1</span>));</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> (mem) Node(key);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>在跳表之中，查找主要基于<code>FindGreaterOrEqual</code>和<code>FindLessThan</code>方法。查找大于或者等于key的节点方式是：从最高层往前遍历，直到x所指向的位置比key小，且next指向的位置比key大。如果当前所处的level为0，则next位置则为恰好大于或者等于key的位置，否则，继续在下层链表之中进行搜索。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></div><div class="line"><span class="title">typename</span> <span class="title">SkipList</span>&lt;Key,Comparator&gt;::Node* SkipList&lt;Key,Comparator&gt;::FindGreaterOrEqual(<span class="keyword">const</span> Key&amp; key, Node** prev)</div><div class="line">    <span class="keyword">const</span> &#123;</div><div class="line">  Node* x = head_;</div><div class="line">  <span class="keyword">int</span> level = GetMaxHeight() - <span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">    Node* next = x-&gt;Next(level);</div><div class="line">    <span class="comment">/// 优先从高层链表往后遍历找到正确的位置</span></div><div class="line">    <span class="comment">// 还没有找到正确的位置，继续往前遍历链表</span></div><div class="line">    <span class="comment">/// key在链表结点next的后面</span></div><div class="line">    <span class="keyword">if</span> (KeyIsAfterNode(key, next)) &#123;</div><div class="line">      <span class="comment">// Keep searching in this list</span></div><div class="line">      x = next;</div><div class="line">    &#125;</div><div class="line">      <span class="comment">/// key在链表结点next的前面，在x结点的后面</span></div><div class="line">      <span class="comment">/// key的prev节点应该指向x</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">if</span> (prev != <span class="literal">NULL</span>) prev[level] = x;</div><div class="line">      <span class="comment">// 若已经是最底层的链表，直接返回这个结点</span></div><div class="line">      <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> next;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// Switch to next list</span></div><div class="line">        <span class="comment">/// 进入更底层的链表，继续查找，直到第0层链表</span></div><div class="line">        level--;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述函数还有一个参数是一个Node*类型的数组，他存放的是每一个level级别链表输入的key的前一个节点的指针。其实就是每个level上，x小于key, 但是<code>x-&gt;next</code> 大于等于key的那个结点x。</p>
<p>请注意，当输入key的sequence number大于或者等于跳表之中的节点，而user key部分一致，上述函数返回的节点指向的是跳表中sequence number较小，但user key部分一致的节点。<code>FindLessThan</code>的实现和<code>FindGreaterOrEqual</code>差不多，都是沿着高层链表往后遍历，直到next指向的节点比key大，并且当前位于第0层链表。不同于<code>FindLessThan</code>的是，<code>FindGreaterOrEqual</code>返回的是x结点，即next结点的上一个结点。</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">template&lt;typename Key, class Comparator&gt;</div><div class="line">typename SkipList&lt;Key,Comparator&gt;::Node*</div><div class="line">SkipList&lt;Key,Comparator&gt;::FindLessThan(<span class="keyword">const</span> Key&amp; key) <span class="keyword">const</span> &#123;</div><div class="line">  Node* x = head_<span class="comment">;</span></div><div class="line">  <span class="built_in">int</span> level = GetMaxHeight() - <span class="number">1</span><span class="comment">;</span></div><div class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">    // 断言当前x为head_结点，否则必有x-&gt;key &lt; key 成立</div><div class="line">    assert(x == head_ || compare_(x-&gt;key, key) &lt; <span class="number">0</span>)<span class="comment">;</span></div><div class="line">    // 拿到当前level层的下一个结点</div><div class="line">    Node* <span class="keyword">next</span> = x-&gt;<span class="keyword">Next</span>(level)<span class="comment">;</span></div><div class="line">    // 若<span class="keyword">next</span>指向<span class="literal">NULL</span>，或者<span class="keyword">next</span>-&gt;key &gt;= key</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">next</span> == <span class="literal">NULL</span> || compare_(<span class="keyword">next</span>-&gt;key, key) &gt;= <span class="number">0</span>) &#123;</div><div class="line">      // 已经是最底层的链表，直接返回对应的结点</div><div class="line">      <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> x<span class="comment">;</span></div><div class="line">      &#125; <span class="keyword">else</span> &#123; // 转向更底层的链表</div><div class="line">        // <span class="keyword">Switch</span> <span class="keyword">to</span> <span class="keyword">next</span> list</div><div class="line">        level--<span class="comment">;</span></div><div class="line">      &#125; // <span class="keyword">next</span> &amp;&amp; compare_(<span class="keyword">next</span>-&gt;key, key) &lt; <span class="number">0</span>, 继续遍历到下一个结点</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      x = <span class="keyword">next</span><span class="comment">;</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>若要定位到跳表的head节点，直接返回其head节点即可。定位到last节点由<code>FindLast</code>实现，从上到下，依次往后遍历，直到到达level 0，且x节点的后一个节点指向NULL，则x为跳表的最后一个节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 首先在最上层链表遍历到尾端，再转向底层结点，直到到达最低层链表的末尾结点</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></div><div class="line"><span class="title">typename</span> <span class="title">SkipList</span>&lt;Key,Comparator&gt;::Node* SkipList&lt;Key,Comparator&gt;::FindLast()</div><div class="line">    <span class="keyword">const</span> &#123;</div><div class="line">  Node* x = head_;</div><div class="line">  <span class="keyword">int</span> level = GetMaxHeight() - <span class="number">1</span>;</div><div class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">    Node* next = x-&gt;Next(level);</div><div class="line">    <span class="keyword">if</span> (next == <span class="literal">NULL</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (level == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// Switch to next list</span></div><div class="line">        level--;</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      x = next;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>相比跳表的搜索，跳表的插入会稍显复杂。跳表每次插入的时候，新节点的高度实际上是随机产生的。插入会首先获取条表中大于或者等于key节点的第一个节点，并记录每一个对应level的前一个节点的地址保存在prev之中。最后更新prev数组中各节点的next值以及要插入的节点的next值即可。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 向skiplist中插入key</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, class Comparator&gt;</div><div class="line"><span class="keyword">void</span> SkipList&lt;Key,Comparator&gt;::Insert(<span class="keyword">const</span> Key&amp; key) &#123;</div><div class="line">  <span class="comment">// TODO(opt): We can use a barrier-free variant of FindGreaterOrEqual()</span></div><div class="line">  <span class="comment">// here since Insert() is externally synchronized.</span></div><div class="line">  Node* prev[kMaxHeight];</div><div class="line">  Node* x = FindGreaterOrEqual(key, prev);</div><div class="line"></div><div class="line">  <span class="comment">// Our data structure does not allow duplicate insertion</span></div><div class="line">  assert(x == NULL || !Equal(key, x-&gt;key));</div><div class="line"></div><div class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = RandomHeight();</div><div class="line">  <span class="built_in">if</span> (<span class="built_in">height</span> &gt; GetMaxHeight()) &#123;</div><div class="line">    <span class="comment">// 更高层的结点，其prev指向head_</span></div><div class="line">    <span class="built_in">for</span> (<span class="keyword">int</span> i = GetMaxHeight(); i &lt; <span class="built_in">height</span>; i++) &#123;</div><div class="line">      prev[i] = head_;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//fprintf(stderr, "Change height from %d to %d\n", max_height_, height);</span></div><div class="line"></div><div class="line">    <span class="comment">// It is ok to mutate max_height_ without any synchronization</span></div><div class="line">    <span class="comment">// with concurrent readers.  A concurrent reader that observes</span></div><div class="line">    <span class="comment">// the new value of max_height_ will see either the old value of</span></div><div class="line">    <span class="comment">// new level pointers from head_ (NULL), or a new value set in</span></div><div class="line">    <span class="comment">// the loop below.  In the former case the reader will</span></div><div class="line">    <span class="comment">// immediately drop to the next level since NULL sorts after all</span></div><div class="line">    <span class="comment">// keys.  In the latter case the reader will use the new node.</span></div><div class="line">    max_height_.NoBarrier_Store(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(<span class="built_in">height</span>));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  x = NewNode(key, <span class="built_in">height</span>);</div><div class="line">  <span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">height</span>; i++) &#123;</div><div class="line">    <span class="comment">// NoBarrier_SetNext() suffices since we will add a barrier when</span></div><div class="line">    <span class="comment">// we publish a pointer to "x" in prev[i].</span></div><div class="line">    <span class="comment">// 复制prev数组</span></div><div class="line">    x-&gt;NoBarrier_SetNext(i, prev[i]-&gt;NoBarrier_Next(i));</div><div class="line">    <span class="comment">// prev-&gt;next 也指向key</span></div><div class="line">    prev[i]-&gt;SetNext(i, x);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>跳表内部迭代器的接口定义和leveldb头文件中Iterator基本一致，但是没有继承头文件中的迭代器接口。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Iterator</span> &#123;</span></div><div class="line">   <span class="keyword">public</span>:</div><div class="line">    <span class="comment">// Initialize an iterator over the specified list.</span></div><div class="line">    <span class="comment">// The returned iterator is not valid.</span></div><div class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Iterator</span><span class="params">(<span class="keyword">const</span> SkipList* <span class="built_in">list</span>)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// Returns true iff the iterator is positioned at a valid node.</span></div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// Returns the key at the current position.</span></div><div class="line">    <span class="comment">// REQUIRES: Valid()</span></div><div class="line">    <span class="function"><span class="keyword">const</span> Key&amp; <span class="title">key</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// Advances to the next position.</span></div><div class="line">    <span class="comment">// REQUIRES: Valid()</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Next</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// Advances to the previous position.</span></div><div class="line">    <span class="comment">// REQUIRES: Valid()</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// Advance to the first entry with a key &gt;= target</span></div><div class="line">    <span class="comment">// 此操作之后，指向第一条key &gt;= target的记录</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Key&amp; target)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// Position at the first entry in list.</span></div><div class="line">    <span class="comment">// Final state of iterator is Valid() iff list is not empty.</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">// Position at the last entry in list.</span></div><div class="line">    <span class="comment">// Final state of iterator is Valid() iff list is not empty.</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">   <span class="keyword">private</span>:</div><div class="line">    <span class="comment">// itertor从属的链表</span></div><div class="line">    <span class="keyword">const</span> SkipList* list_;</div><div class="line">    <span class="comment">// 链表中的结点</span></div><div class="line">    Node* node_;</div><div class="line">    <span class="comment">// Intentionally copyable</span></div><div class="line">  &#125;;</div></pre></td></tr></table></figure>
<p>我们可以发现，跳表中Iterator的相关操作基本上是对搜索操作的一次转调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// constructor of Iterator inside skiplist</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></div><div class="line"><span class="title">inline</span> <span class="title">SkipList</span>&lt;Key,Comparator&gt;::Iterator::Iterator(<span class="keyword">const</span> SkipList* <span class="built_in">list</span>) &#123;</div><div class="line">  list_ = <span class="built_in">list</span>;</div><div class="line">  node_ = <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 若node_不为nil，那么Iterator是Valid的</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></div><div class="line"><span class="title">inline</span> <span class="title">bool</span> <span class="title">SkipList</span>&lt;Key,Comparator&gt;::Iterator::Valid() <span class="keyword">const</span> &#123;</div><div class="line">  <span class="keyword">return</span> node_ != <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 返回node_对应的key_</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></div><div class="line"><span class="title">inline</span> <span class="title">const</span> <span class="title">Key</span>&amp; <span class="title">SkipList</span>&lt;Key,Comparator&gt;::Iterator::key() <span class="keyword">const</span> &#123;</div><div class="line">  assert(Valid());</div><div class="line">  <span class="keyword">return</span> node_-&gt;key;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 移动node_指向链表中的下一个结点</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></div><div class="line"><span class="title">inline</span> <span class="title">void</span> <span class="title">SkipList</span>&lt;Key,Comparator&gt;::Iterator::Next() &#123;</div><div class="line">  assert(Valid());</div><div class="line">  node_ = node_-&gt;Next(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Iterator指向上一个结点</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></div><div class="line"><span class="title">inline</span> <span class="title">void</span> <span class="title">SkipList</span>&lt;Key,Comparator&gt;::Iterator::Prev() &#123;</div><div class="line">  <span class="comment">// Instead of using explicit "prev" links, we just search for the</span></div><div class="line">  <span class="comment">// last node that falls before key.</span></div><div class="line">  assert(Valid());</div><div class="line">  <span class="comment">// node_应该指向恰好小于当前key的节点</span></div><div class="line">  <span class="comment">// 此操作是在skiplist的层面进行</span></div><div class="line">  node_ = list_-&gt;FindLessThan(node_-&gt;key);</div><div class="line">  <span class="comment">// 若链表为空，node_指向null，iterator 已经不再 valid了</span></div><div class="line">  <span class="keyword">if</span> (node_ == list_-&gt;head_) &#123;</div><div class="line">    node_ = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 转调用skiplist中的FindGreaterOrEqual函数，node指向第一个大于等于target的节点</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></div><div class="line"><span class="title">inline</span> <span class="title">void</span> <span class="title">SkipList</span>&lt;Key,Comparator&gt;::Iterator::Seek(<span class="keyword">const</span> Key&amp; target) &#123;</div><div class="line">  node_ = list_-&gt;FindGreaterOrEqual(target, <span class="literal">NULL</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// iterator指向head_对应的结点</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></div><div class="line"><span class="title">inline</span> <span class="title">void</span> <span class="title">SkipList</span>&lt;Key,Comparator&gt;::Iterator::SeekToFirst() &#123;</div><div class="line">  node_ = list_-&gt;head_-&gt;Next(<span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// node_是skiplist中最后的节点</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Key, <span class="class"><span class="keyword">class</span> <span class="title">Comparator</span>&gt;</span></div><div class="line"><span class="title">inline</span> <span class="title">void</span> <span class="title">SkipList</span>&lt;Key,Comparator&gt;::Iterator::SeekToLast() &#123;</div><div class="line">  node_ = list_-&gt;FindLast();</div><div class="line">  <span class="comment">// 判断链表是否为空，设置iterator的状态</span></div><div class="line">  <span class="keyword">if</span> (node_ == list_-&gt;head_) &#123;</div><div class="line">    node_ = <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb bloom filter]]></title>
      <url>/2017/06/13/leveldb-bloom-filter/</url>
      <content type="html"><![CDATA[<p>bloom过滤器在1970年由布隆提出。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于快速检索一个元素是否在一个集合中。使用布隆过滤器能够确定某个元素<strong>不在</strong>集合之中，但是布隆过滤器可能会误报，将本来不在集合中的元素归类为在集合之中的元素。</p>
<p>在leveldb的布隆过滤器，需要指定每个key需要的向量位数，如下所示：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">explicit</span> BloomFilterPolicy(<span class="keyword">int</span> bits_per_key)</div><div class="line">    : bits_per_key_(bits_per_key)</div><div class="line">&#123;</div><div class="line">  <span class="comment">// we intentionally round down to reduce probing cost a little bit</span></div><div class="line">  k_ = <span class="keyword">static_cast</span>&lt;size_t&gt;(bits_per_key * <span class="number">0.69</span>); <span class="comment">// 0.69 =~ ln(2)</span></div><div class="line">  <span class="built_in">if</span> (k_ &lt; <span class="number">1</span>)</div><div class="line">    k_ = <span class="number">1</span>;</div><div class="line">  <span class="built_in">if</span> (k_ &gt; <span class="number">30</span>)</div><div class="line">    k_ = <span class="number">30</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>leveldb 会在向量的最后记录<code>k_</code>的值,<code>k_</code>代表每个key需要设置hash位的次数。</p>
<p>对于创建filter，leveldb会根据key的个数和<code>bits_per_key_</code>设置计算总共需要的二进制位数，将其向上取整到byte为单位，并且最小为8byte。对于每个key，重复设置<code>k_</code>次对应bit位，每次hash值加上delta <code>const uint32_t delta = (h &gt;&gt; 17) | (h &lt;&lt; 15);</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CreateFilter</span><span class="params">(<span class="keyword">const</span> Slice *keys, <span class="keyword">int</span> n, <span class="built_in">std</span>::<span class="built_in">string</span> *dst)</span> <span class="keyword">const</span></span></div><div class="line">&#123;</div><div class="line">  <span class="comment">// compute bloom filter size (in both bits and bytes)</span></div><div class="line">  <span class="keyword">size_t</span> bits = n * bits_per_key_;</div><div class="line"></div><div class="line">  <span class="comment">// for small n, we can see a very high false positive rate. Fix it by enforcing</span></div><div class="line">  <span class="comment">// a minimum bloom filter length.</span></div><div class="line">  <span class="keyword">if</span> (bits &lt; <span class="number">64</span>)</div><div class="line">    bits = <span class="number">64</span>;</div><div class="line"></div><div class="line">  <span class="keyword">size_t</span> bytes = (bits + <span class="number">7</span>) / <span class="number">8</span>;</div><div class="line">  bits = bytes * <span class="number">8</span>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> init_size = dst-&gt;size();</div><div class="line">  dst-&gt;resize(init_size + bytes, <span class="number">0</span>);</div><div class="line">  dst-&gt;push_back(<span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(k_)); <span class="comment">// remember # of probes in filter</span></div><div class="line">  <span class="comment">// 因为采用的是push_back, 所以现在dst的实际大小为 init_size + 1 + bytes</span></div><div class="line">  <span class="comment">// 最后一个byte用于存放k_</span></div><div class="line">  <span class="keyword">char</span> *<span class="built_in">array</span> = &amp;(*dst)[init_size];</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</div><div class="line">  &#123;</div><div class="line">    <span class="comment">// use double-hashing to generate a sequence of hash values.</span></div><div class="line">    <span class="comment">// se analysis in [Kirsch,Mitzenmacher 2006].</span></div><div class="line">    <span class="keyword">uint32_t</span> h = BloomHash(keys[i]);</div><div class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> delta = (h &gt;&gt; <span class="number">17</span>) | (h &lt;&lt; <span class="number">15</span>); <span class="comment">// rotate right 17 bits</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; k_; j++)</div><div class="line">    &#123;</div><div class="line">      <span class="keyword">const</span> <span class="keyword">uint32_t</span> bitpos = h % bits;</div><div class="line">      <span class="comment">// 设置对应位</span></div><div class="line">      <span class="built_in">array</span>[bitpos/<span class="number">8</span>] |= (<span class="number">1</span> &lt;&lt; (bitpos % <span class="number">8</span>));</div><div class="line">      <span class="comment">// h+= delta</span></div><div class="line">      h += delta;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至于<code>KeyMayMatch</code>操作，就是对于给定key，首先拿到<code>k_</code>的值，然后进行<code>k_</code>次比较，比较每次计算得出的hash值对应的向量位是否设置为1，若<code>k_</code>次比较完毕之后，对应bit都设置为1，那么有理由相信这个key符合要求，否则，此key一定不在bloom集合之中。这里对<code>k_</code>做了特殊处理，对于<code>k_</code>大于30的情况，统一认定为符合filter，这是保留用途。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">KeyMayMatch</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; bloom_filter)</span> <span class="keyword">const</span></span></div><div class="line"> &#123;</div><div class="line">   <span class="keyword">const</span> <span class="keyword">size_t</span> len = bloom_filter.size();</div><div class="line">   <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">   <span class="keyword">const</span> <span class="keyword">char</span>* <span class="built_in">array</span> = bloom_filter.data();</div><div class="line">   <span class="keyword">const</span> <span class="keyword">size_t</span> bits = (len - <span class="number">1</span>) * <span class="number">8</span>;</div><div class="line"></div><div class="line">   <span class="comment">// use the encoded k so that we can read filters generated by bloom filters created using different parameters.</span></div><div class="line">   <span class="keyword">const</span> <span class="keyword">size_t</span> k = <span class="built_in">array</span>[len - <span class="number">1</span>];</div><div class="line">   <span class="keyword">if</span> (k &gt; <span class="number">30</span>)</div><div class="line">   &#123;</div><div class="line">     <span class="comment">// reserved for potentially new encodings for short bloom filters.</span></div><div class="line">     <span class="comment">// consider it a match</span></div><div class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">uint32_t</span> h = BloomHash(key);</div><div class="line">   <span class="keyword">const</span> <span class="keyword">uint32_t</span> delta = (h &gt;&gt; <span class="number">17</span>) | (h &lt;&lt; <span class="number">15</span>);</div><div class="line">   <span class="keyword">for</span>(<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; k; j++)</div><div class="line">   &#123;</div><div class="line">     <span class="keyword">const</span> <span class="keyword">uint32_t</span> bitpos = h % bits;</div><div class="line">     <span class="keyword">if</span>((<span class="built_in">array</span>[bitpos/<span class="number">8</span>] &amp; (<span class="number">1</span> &lt;&lt; (bitpos %<span class="number">8</span>))) == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">     h += delta;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>求hash值的操作实际上是对hash操作的简单封装，指定seed为<code>0xbc9f1d34</code>。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> uint32_t BloomHash(<span class="keyword">const</span> Slice &amp;<span class="built_in">key</span>)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> Hash(<span class="built_in">key</span>.data(), <span class="built_in">key</span>.<span class="built_in">size</span>(), <span class="number">0xbc9f1d34</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb Arena内存分配器]]></title>
      <url>/2017/06/13/leveldb-Arena%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8/</url>
      <content type="html"><![CDATA[<p>leveldb使用vector存放使用malloc分配的内存。在析构的时候，对这些分配的内存统一进行释放。</p>
<p>在分配内存时，首先判断上一个剩余块空间是否足够，足够就直接从剩余空间之中分配内存，否则调用AllocateFallback, 分配一块的新的内存。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">inline</span> char* Arena<span class="type">::Allocate</span>(size_t <span class="built_in">bytes</span>)</div><div class="line">&#123;</div><div class="line">  assert(<span class="built_in">bytes</span> &gt; <span class="number">0</span>);</div><div class="line">  <span class="keyword">if</span>(<span class="built_in">bytes</span> &lt;= alloc_bytes_remaining_)</div><div class="line">  &#123;</div><div class="line">    char* result = alloc_ptr_;</div><div class="line">    alloc_ptr_ += <span class="built_in">bytes</span>;</div><div class="line">    alloc_bytes_remaining_ -= <span class="built_in">bytes</span>;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> AllocateFallback(<span class="built_in">bytes</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在分配新的内存时，判断要分配的内存是否大于分配内存块大小kBlockSize的1/4，若大于，直接分配此大小的内存。否则分配一块kBlockSize大小的内存，从此内存块之中分配需要的内存，记录当前块剩余空间，以便下次内存分配能够利用剩余的空间。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">char</span>* <span class="type">Arena</span>::<span class="type">AllocateFallback</span>(size_t bytes)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span>(bytes &gt; kBlockSize / <span class="number">4</span>)</div><div class="line">  &#123;</div><div class="line">    // <span class="keyword">object</span> <span class="keyword">is</span> more than a quarter <span class="keyword">of</span> our <span class="keyword">block</span> size. <span class="type">Allocate</span> it separately to</div><div class="line">    // avoid wasting too much space <span class="keyword">in</span> leftover bytes.</div><div class="line">    <span class="built_in">char</span>* <span class="literal">result</span> = <span class="type">AllocateNewBlock</span>(bytes);</div><div class="line">    <span class="keyword">return</span> <span class="literal">result</span>;</div><div class="line">  &#125;</div><div class="line">  // we waste the remaining space <span class="keyword">in</span> the current <span class="keyword">block</span></div><div class="line">  alloc_ptr_ = <span class="type">AllocateNewBlock</span>(kBlockSize);</div><div class="line">  alloc_bytes_remaining_ = kBlockSize;</div><div class="line"></div><div class="line">  <span class="built_in">char</span>* <span class="literal">result</span> = alloc_ptr_;</div><div class="line">  alloc_ptr_ += bytes;</div><div class="line">  alloc_bytes_remaining_ -= bytes;</div><div class="line">  <span class="keyword">return</span> <span class="literal">result</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还有一种需求是分配的内存需要对齐，这需要保证分配的内存地址能够整除8（64位cpu），所以可能需要跳过一段内存区域，返回对齐的地址空间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">char</span>* Arena::AllocateAligned(<span class="keyword">size_t</span> bytes)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">int</span> align = (<span class="keyword">sizeof</span>(<span class="keyword">void</span>*) &gt; <span class="number">8</span>) ? <span class="keyword">sizeof</span>(<span class="keyword">void</span>*) : <span class="number">8</span>;</div><div class="line">  assert((align &amp; (align - <span class="number">1</span>)) == <span class="number">0</span>); <span class="comment">// pointer size should be a power of 2</span></div><div class="line">  <span class="keyword">size_t</span> current_mod = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(alloc_ptr_) &amp; (align - <span class="number">1</span>);</div><div class="line">  <span class="keyword">size_t</span> slop = (current_mod == <span class="number">0</span> ? <span class="number">0</span> : align - current_mod);</div><div class="line">  <span class="keyword">size_t</span> needed = bytes + slop;</div><div class="line">  <span class="keyword">char</span>* result;</div><div class="line">  <span class="keyword">if</span>(needed &lt;= alloc_bytes_remaining_)</div><div class="line">  &#123;</div><div class="line">    result = alloc_ptr_ + slop;</div><div class="line">    alloc_ptr_ += needed;</div><div class="line">    alloc_bytes_remaining_ -= needed;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">  &#123;</div><div class="line">    <span class="comment">// AllocateFallback always returned aligned memory</span></div><div class="line">    result = AllocateFallback(bytes);</div><div class="line">  &#125;</div><div class="line">  assert((<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(result) &amp; (align - <span class="number">1</span>)) == <span class="number">0</span>);</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至于分配块内存，是直接调用new运算符来分配，其实质是利用malloc。在此过程中还记录了内存空间的总用量，注意要包括vector中记录内存地址占用的内存大小。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">char</span>* Arena::AllocateNewBlock(<span class="keyword">size_t</span> block_bytes)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">char</span>* result = <span class="keyword">new</span> <span class="keyword">char</span>[block_bytes];</div><div class="line">  blocks_.push_back(result);</div><div class="line">  <span class="comment">// also add pointer size at blocks_</span></div><div class="line">  memory_usage_.NoBarrier_Store(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(MemoryUsage() + block_bytes + <span class="keyword">sizeof</span>(<span class="keyword">char</span>*)));</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb测试夹具]]></title>
      <url>/2017/06/13/leveldb%E6%B5%8B%E8%AF%95%E5%A4%B9%E5%85%B7/</url>
      <content type="html"><![CDATA[<p>一直以来，都想实现一个简单的单元测试工具，从根本上理解单元测试框架的实现原理。今天看了leveldb中的源码testharness.cc，感觉已经彻底理解了。</p>
<h2 id="核心技术"><a href="#核心技术" class="headerlink" title="核心技术"></a>核心技术</h2><p>和log实现一样，实现单元测试框架的核心是要用好宏。如果对宏没有清晰的认知，恐怕连相关的代码都无法理解。</p>
<p>以下主要补充说明#和##在宏中的作用：<br><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define WARN_IF(<span class="built_in">EXP</span>) <span class="keyword">do</span> &#123; <span class="keyword">if</span>(<span class="built_in">EXP</span>) fprintf(stderr, <span class="string">"Warning! "</span>#<span class="built_in">EXP</span><span class="string">"\n"</span>); &#125; <span class="keyword">while</span>(<span class="number">0</span>)</div></pre></td></tr></table></figure></p>
<p>#对他后面的变量左右添加双引号，所以上述宏定义之中可以将表达式转换为字符串输出。</p>
<figure class="highlight tp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">#define CONCAT(<span class="keyword">X</span>, <span class="keyword">Y</span>) <span class="keyword">X</span>##<span class="keyword">Y</span></div></pre></td></tr></table></figure>
<p>##则用于连接两个变量。上述宏定义是一个简单的连接操作。</p>
<h2 id="断言的实现"><a href="#断言的实现" class="headerlink" title="断言的实现"></a>断言的实现</h2><p>断言的实现是基于类Tester完成的，类成员中由<code>std::stringstream ss_</code> 来记录输出的错误信息。如果Tester中的用于测试的成员函数出错了，会记录状态为出错，这样在析构的时候就会将ss_的错误信息输出到stderr之中, 并且调用<strong>exit</strong>退出。</p>
<p>为了避免重复输入内容完全一样，仅仅名称和比较运算符不同的测试函数，在这里使用了宏定义进行简化。<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#define BINARY_OP(name,op)                              \</span></div><div class="line">  template &lt;<span class="class"><span class="keyword">class</span> <span class="title">X</span>, <span class="title">class</span> <span class="title">Y</span>&gt;                           \</span></div><div class="line">  Tester&amp; name(<span class="keyword">const</span> X&amp; x, <span class="keyword">const</span> Y&amp; y) &#123;                <span class="string">\</span></div><div class="line">    <span class="keyword">if</span> (! (x op y)) &#123;                                   <span class="string">\</span></div><div class="line">      ss_ &lt;&lt; <span class="string">" failed: "</span> &lt;&lt; x &lt;&lt; (<span class="string">" "</span> <span class="comment">#op " ") &lt;&lt; y;    \</span></div><div class="line">      ok_ = <span class="literal">false</span>;                                      <span class="string">\</span></div><div class="line">    &#125;                                                   <span class="string">\</span></div><div class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;                                       <span class="string">\</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  BINARY_OP(IsEq, ==)</div><div class="line">  BINARY_OP(IsNe, !=)</div><div class="line">  BINARY_OP(IsGe, &gt;=)</div><div class="line">  BINARY_OP(IsGt, &gt;)</div><div class="line">  BINARY_OP(IsLe, &lt;=)</div><div class="line">  BINARY_OP(IsLt, &lt;)</div><div class="line"><span class="comment">#undef BINARY_OP</span></div></pre></td></tr></table></figure></p>
<p>对于后续不再使用的宏定义要及时将其undef，这里符合了google的编程规范。</p>
<p>通过代码可以发现，对于ASSERT_TRUE, ASSERT_OK, ASSERT_EQ, ASSERT_NE的调用原理实际上是创建一个Tester临时成员，并且立即调用对应的比较函数。这样若检查失败，那么临时对象在析构的时候会输出错误信息，并且程序终止运行。</p>
<h2 id="增加测试案例"><a href="#增加测试案例" class="headerlink" title="增加测试案例"></a>增加测试案例</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// testharness.h</span></div><div class="line"><span class="meta">#define TCONCAT(a,b) TCONCAT1(a,b)</span></div><div class="line"><span class="meta">#define TCONCAT1(a,b) a##b</span></div><div class="line"></div><div class="line"><span class="meta">#define TEST(base,name)                                                 \</span></div><div class="line"><span class="keyword">class</span> TCONCAT(_Test_,name) : public base &#123;                              \</div><div class="line"> public:                                                                \</div><div class="line">  <span class="keyword">void</span> _Run();                                                          \</div><div class="line">  <span class="keyword">static</span> <span class="keyword">void</span> _RunIt() &#123;                                                \</div><div class="line">    TCONCAT(_Test_,name) t;                                             \</div><div class="line">    t._Run();                                                           \</div><div class="line">  &#125;                                                                     \</div><div class="line">&#125;;                                                                      \</div><div class="line"><span class="keyword">bool</span> TCONCAT(_Test_ignored_,name) =                                     \</div><div class="line">  ::leveldb::test::RegisterTest(<span class="meta">#base, #name, &amp;TCONCAT(_Test_,name)::_RunIt); \</span></div><div class="line"><span class="keyword">void</span> TCONCAT(_Test_,name)::_Run()</div><div class="line"></div><div class="line"><span class="comment">// Register the specified test.  Typically not used directly, but</span></div><div class="line"><span class="comment">// invoked via the macro expansion of TEST.</span></div><div class="line"><span class="keyword">extern</span> <span class="keyword">bool</span> RegisterTest(<span class="keyword">const</span> <span class="keyword">char</span>* base, <span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">void</span> (*func)());</div><div class="line"></div><div class="line"><span class="comment">//testharness.cc</span></div><div class="line"><span class="keyword">struct</span> Test &#123;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* base;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* name;</div><div class="line">  <span class="keyword">void</span> (*func)();</div><div class="line">&#125;;</div><div class="line">std::vector&lt;Test&gt;* tests;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">bool</span> RegisterTest(<span class="keyword">const</span> <span class="keyword">char</span>* base, <span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">void</span> (*func)()) &#123;</div><div class="line">  <span class="keyword">if</span> (tests == <span class="literal">NULL</span>) &#123;</div><div class="line">    tests = new std::vector&lt;Test&gt;;</div><div class="line">  &#125;</div><div class="line">  Test t;</div><div class="line">  t.base = base;</div><div class="line">  t.name = name;</div><div class="line">  t.func = func;</div><div class="line">  tests-&gt;push_back(t);</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> RunAllTests() &#123;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* matcher = getenv(<span class="string">"LEVELDB_TESTS"</span>);</div><div class="line"></div><div class="line">  <span class="keyword">int</span> num = <span class="number">0</span>;</div><div class="line">  <span class="keyword">if</span> (tests != <span class="literal">NULL</span>) &#123;</div><div class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; tests-&gt;size(); i++) &#123;</div><div class="line">      <span class="keyword">const</span> Test&amp; t = (*tests)[i];</div><div class="line">      <span class="keyword">if</span> (matcher != <span class="literal">NULL</span>) &#123;</div><div class="line">        std::string name = t.base;</div><div class="line">        name.push_back(<span class="string">'.'</span>);</div><div class="line">        name.append(t.name);</div><div class="line">        <span class="keyword">if</span> (strstr(name.c_str(), matcher) == <span class="literal">NULL</span>) &#123;</div><div class="line">          <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      fprintf(stderr, <span class="string">"==== Test %s.%s\n"</span>, t.base, t.name);</div><div class="line">      (*t.func)();</div><div class="line">      ++num;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  fprintf(stderr, <span class="string">"==== PASSED %d tests\n"</span>, num);</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在leveldb中，每个测试案例对应一个struct test实例，其成员包括base(基础名称), name, 以及一个无参的void类型函数。测试所有案例就是依次调用所有案例的测试函数。</p>
<p>以下代码演示了测试的具体使用方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 有删减</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"util/crc32c.h"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"util/testharness.h"</span></span></div><div class="line"></div><div class="line"><span class="keyword">namespace</span> leveldb &#123;</div><div class="line"><span class="keyword">namespace</span> crc32c &#123;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CRC</span> &#123;</span> &#125;;</div><div class="line"></div><div class="line">TEST(CRC, StandardResults) &#123;</div><div class="line">  <span class="comment">// From rfc3720 section B.4.</span></div><div class="line">  <span class="keyword">char</span> buf[<span class="number">32</span>];</div><div class="line"></div><div class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> leveldb::test::RunAllTests();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>拆解前述代码的宏定义，可以发现，每次调用依次test就是定义一个与之相关的class，宏定义将具体的Run_实现交给用户进行。宏定义TEST中已经将此类的static成员函数定义好了，此成员函数是创建一个此类的对象，并且调用其Run_方法。这样只需将此类的static函数作为struct Test中的函数指针指向的函数，在进行测试的时候，调用此静态函数就会调用用户定义的测试方法。虽然过程比较百转千折，但是实现非常精妙！</p>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MergingIterator和TwoLevelIterator]]></title>
      <url>/2017/06/13/MergingIterator%E5%92%8CTwoLevelIterator/</url>
      <content type="html"><![CDATA[<h2 id="MergingIterator"><a href="#MergingIterator" class="headerlink" title="MergingIterator"></a>MergingIterator</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>MergingIterator的存在能够将多个iterator对应的数据结合起来，统一成一个iterator对外提供服务。迭代器的先后顺序仍然表示数据的大小关系，但是MegingIterator并不会对输入的迭代器进行去重处理。</p>
<p>通过构造函数可以发现，若没有输入任何迭代器，则返回一个empty iterator；若只输入了一个迭代器，则返回这个迭代器；在其他情况下才会创建MergingIterator对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 输入0，返回空的iterator，1，返回本身，n返回合并iterator</span></div><div class="line"><span class="function">Iterator* <span class="title">NewMergingIterator</span><span class="params">(<span class="keyword">const</span> Comparator* cmp, Iterator** <span class="built_in">list</span>, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">  assert(n &gt;= <span class="number">0</span>);</div><div class="line">  <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">return</span> NewEmptyIterator();</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">list</span>[<span class="number">0</span>];</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MergingIterator(cmp, <span class="built_in">list</span>, n);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="实现解析"><a href="#实现解析" class="headerlink" title="实现解析"></a>实现解析</h3><h4 id="SeekToFirst，SeekToLast-和-Seek"><a href="#SeekToFirst，SeekToLast-和-Seek" class="headerlink" title="SeekToFirst，SeekToLast 和 Seek"></a>SeekToFirst，SeekToLast 和 Seek</h4><p>先从简单的讲起，SeekToFirst操作对所有输入的迭代器执行SeekToFirst操作，然后找到其中最小的一个就是第一个迭代器，并且记录迭代器前进方向为kForward。SeekToLast实现同理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_; i++) &#123;</div><div class="line">     children_[i].SeekToFirst();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 找到最小的</span></div><div class="line">   FindSmallest();</div><div class="line">   <span class="comment">// 方向是前进</span></div><div class="line">   direction_ = kForward;</div><div class="line"> &#125;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_; i++) &#123;</div><div class="line">     children_[i].SeekToLast();</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 找到最大的</span></div><div class="line">   FindLargest();</div><div class="line">   <span class="comment">// 方向是后退</span></div><div class="line">   direction_ = kReverse;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>Seek操作是对所有输入的迭代器统一执行Seek操作，找到其中最小的迭代器返回。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">virtual <span class="function"><span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Slice&amp; <span class="keyword">target</span>)</span> </span>&#123;</div><div class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_; i++) &#123;</div><div class="line">     children_[i].Seek(<span class="keyword">target</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// 找到最小的</span></div><div class="line">   FindSmallest();</div><div class="line">   <span class="comment">// 方向是前进</span></div><div class="line">   direction_ = kForward;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>FindSmallest函数遍历所有输入的迭代器，记录key最小的迭代器为current_;FindLargest遍历所有输入的迭代器，记录key最大的迭代器为current_。</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 简单的O(n)遍历查找</span></div><div class="line">void MergingIterator::FindSmallest() &#123;</div><div class="line">  IteratorWrapper* smallest = <span class="keyword">NULL</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_; i++) &#123;</div><div class="line">    IteratorWrapper* child = &amp;children_[i];</div><div class="line">    <span class="keyword">if</span> (child-&gt;Valid()) &#123;</div><div class="line">      <span class="keyword">if</span> (smallest == <span class="keyword">NULL</span>) &#123;</div><div class="line">        smallest = child;</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparator_-&gt;Compare(child-&gt;key(), smallest-&gt;key()) &lt; <span class="number">0</span>) &#123;</div><div class="line">        smallest = child;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  current_ = smallest;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void MergingIterator::FindLargest() &#123;</div><div class="line">  IteratorWrapper* largest = <span class="keyword">NULL</span>;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n_<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">    IteratorWrapper* child = &amp;children_[i];</div><div class="line">    <span class="keyword">if</span> (child-&gt;Valid()) &#123;</div><div class="line">      <span class="keyword">if</span> (largest == <span class="keyword">NULL</span>) &#123;</div><div class="line">        largest = child;</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparator_-&gt;Compare(child-&gt;key(), largest-&gt;key()) &gt; <span class="number">0</span>) &#123;</div><div class="line">        largest = child;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  current_ = largest;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Prev-和-Next"><a href="#Prev-和-Next" class="headerlink" title="Prev 和 Next"></a>Prev 和 Next</h4><p>Prev操作是找到从左边最接近当前key的迭代器位置。若当前迭代器的遍历方向是kReverse，那么children_记录的除了current_之外的迭代器都current_小。因而其他迭代器都不用移动，只需current_向前移动一位，这样所有迭代器都比当前位置的key小，其中最大的就是最接近当前位置的迭代器。</p>
<p>在其他情况下，就要对其他迭代器先执行Seek(key())操作，再执行Prev操作，移动到刚好小于当前key的位置。对于当前迭代器仍然只执行Prev操作。这样所有迭代器都是刚好比key小的位置，其中最大的就是最接近当前位置的迭代器。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">virtual void Prev() &#123;</div><div class="line">    assert(Valid());</div><div class="line"></div><div class="line">    <span class="comment">/// Ensure that all children are positioned before key().</span></div><div class="line">    <span class="comment">/// reverse 情况下，其他child的key都比current小</span></div><div class="line">    <span class="comment">// If we are moving in the reverse direction, it is already</span></div><div class="line">    <span class="comment">// true for all of the non-current_ children since current_ is</span></div><div class="line">    <span class="comment">// the largest child and key() == current_-&gt;key().  Otherwise,</span></div><div class="line">    <span class="comment">// we explicitly position the non-current_ children.</span></div><div class="line">    <span class="keyword">if</span> (direction_ != kReverse) &#123;</div><div class="line">      <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n_; i++) &#123;</div><div class="line">        IteratorWrapper* child = &amp;children_[i];</div><div class="line">        <span class="keyword">if</span> (child != current_) &#123;</div><div class="line">          <span class="function"><span class="title">child</span>-&gt;</span>Seek(key());</div><div class="line">          <span class="function"><span class="title">if</span> (child-&gt;</span>Valid()) &#123;</div><div class="line">            <span class="comment">// Child is at first entry &gt;= key().  Step back one to be &lt; key()</span></div><div class="line">            <span class="function"><span class="title">child</span>-&gt;</span>Prev();</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// Child has no entries &gt;= key().  Position at last entry.</span></div><div class="line">            <span class="function"><span class="title">child</span>-&gt;</span>SeekToLast();</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      direction_ = kReverse;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="title">current_</span>-&gt;</span>Prev();</div><div class="line">    <span class="comment">// 找其中最大的</span></div><div class="line">    FindLargest();</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>Next的实现方式同理，下面仅列出代码：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">virtual void Next() &#123;</div><div class="line">    assert(Valid());</div><div class="line"></div><div class="line">    <span class="comment">/// Ensure that all children are positioned after key().</span></div><div class="line">    <span class="comment">/// forward 情况下，其他child的key都比current大</span></div><div class="line">    <span class="comment">// If we are moving in the forward direction, it is already</span></div><div class="line">    <span class="comment">// true for all of the non-current_ children since current_ is</span></div><div class="line">    <span class="comment">// the smallest child and key() == current_-&gt;key().  Otherwise,</span></div><div class="line">    <span class="comment">// we explicitly position the non-current_ children.</span></div><div class="line">    <span class="keyword">if</span> (direction_ != kForward) &#123;</div><div class="line">      <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; n_; i++) &#123;</div><div class="line">        IteratorWrapper* child = &amp;children_[i];</div><div class="line">        <span class="keyword">if</span> (child != current_) &#123;</div><div class="line">          <span class="function"><span class="title">child</span>-&gt;</span>Seek(key());</div><div class="line">          <span class="function"><span class="title">if</span> (child-&gt;</span>Valid() &amp;&amp;</div><div class="line">              <span class="function"><span class="title">comparator_</span>-&gt;</span>C<span class="function"><span class="title">ompare</span>(key(), child-&gt;</span>key()) == <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">// child指向比key()大的位置</span></div><div class="line">            <span class="function"><span class="title">child</span>-&gt;</span>Next();</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      direction_ = kForward;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// current指向下一位</span></div><div class="line">    <span class="function"><span class="title">current_</span>-&gt;</span>Next();</div><div class="line">    <span class="comment">// 找其中最小的</span></div><div class="line">    FindSmallest();</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h2 id="TwoLevelIterator"><a href="#TwoLevelIterator" class="headerlink" title="TwoLevelIterator"></a>TwoLevelIterator</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>TwoLevelIterator输入Index block 对应的iterator，以及输入的BlockReader函数，将index iterator所管理的数据块整合成为一个iterator，对外提供数据服务。</p>
<h3 id="初始化data-iterator"><a href="#初始化data-iterator" class="headerlink" title="初始化data iterator"></a>初始化data iterator</h3><p>初始化data iterator的操作很简单，获取<code>index_iter_</code>当前位置的值作为block handle来初始化data iterator。在此过程中会记录此handle的值。若<code>data_iter_</code>不为空，且handle与记录的值不变，则不会重新初始化<code>data_iter_</code>。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// initialize data iterator</span></div><div class="line"><span class="literal">void</span> TwoLevelIterator<span class="type">::InitDataBlock</span>() &#123;</div><div class="line">  <span class="keyword">if</span> (!index_iter_.Valid()) &#123;</div><div class="line">    SetDataIterator(<span class="built_in">NULL</span>);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    Slice <span class="keyword">handle</span> = index_iter_.value();</div><div class="line">    <span class="keyword">if</span> (data_iter_.iter() != <span class="built_in">NULL</span> &amp;&amp; <span class="keyword">handle</span>.compare(data_block_handle_) == <span class="number">0</span>) &#123;</div><div class="line">      <span class="comment">// data_iter_ is already constructed with this iterator, so</span></div><div class="line">      <span class="comment">// no need to change anything</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// 获取data iter</span></div><div class="line">      Iterator* iter = (*block_function_)(arg_, options_, <span class="keyword">handle</span>);</div><div class="line">      <span class="comment">// 保存创建data_iter的handle信息</span></div><div class="line">      data_block_handle_.assign(<span class="keyword">handle</span>.<span class="built_in">data</span>(), <span class="keyword">handle</span>.size());</div><div class="line">      <span class="comment">// 设置data iterator</span></div><div class="line">      SetDataIterator(iter);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 设置data iter</span></div><div class="line"><span class="literal">void</span> TwoLevelIterator<span class="type">::SetDataIterator</span>(Iterator* data_iter) &#123;</div><div class="line">  <span class="keyword">if</span> (data_iter_.iter() != <span class="built_in">NULL</span>) SaveError(data_iter_.status());</div><div class="line">  data_iter_.<span class="built_in">Set</span>(data_iter);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="iterator的Seek相关操作"><a href="#iterator的Seek相关操作" class="headerlink" title="iterator的Seek相关操作"></a>iterator的Seek相关操作</h3><p>iterator的Seek相关操作也非常简单，首先根据不同的Seek操作对<code>index_iter_</code>进行相应的移动，根据当前<code>index_iter_</code>的值初始化<code>data_iter_</code>，再移动到正确的位置上。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">void</span> <span class="selector-tag">TwoLevelIterator</span><span class="selector-pseudo">::Seek(const</span> <span class="selector-tag">Slice</span><span class="selector-tag">&amp;</span> <span class="selector-tag">target</span>) &#123;</div><div class="line">  <span class="selector-tag">index_iter_</span><span class="selector-class">.Seek</span>(target);</div><div class="line">  <span class="selector-tag">InitDataBlock</span>();</div><div class="line">  <span class="selector-tag">if</span> (data_iter_.iter() != NULL) <span class="selector-tag">data_iter_</span><span class="selector-class">.Seek</span>(target);</div><div class="line">  <span class="selector-tag">SkipEmptyDataBlocksForward</span>();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">void</span> <span class="selector-tag">TwoLevelIterator</span><span class="selector-pseudo">::SeekToFirst()</span> &#123;</div><div class="line">  <span class="selector-tag">index_iter_</span><span class="selector-class">.SeekToFirst</span>();</div><div class="line">  <span class="selector-tag">InitDataBlock</span>();</div><div class="line">  <span class="selector-tag">if</span> (data_iter_.iter() != NULL) <span class="selector-tag">data_iter_</span><span class="selector-class">.SeekToFirst</span>();</div><div class="line">  <span class="selector-tag">SkipEmptyDataBlocksForward</span>();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">void</span> <span class="selector-tag">TwoLevelIterator</span><span class="selector-pseudo">::SeekToLast()</span> &#123;</div><div class="line">  <span class="selector-tag">index_iter_</span><span class="selector-class">.SeekToLast</span>();</div><div class="line">  <span class="selector-tag">InitDataBlock</span>();</div><div class="line">  <span class="selector-tag">if</span> (data_iter_.iter() != NULL) <span class="selector-tag">data_iter_</span><span class="selector-class">.SeekToLast</span>();</div><div class="line">  <span class="selector-tag">SkipEmptyDataBlocksBackward</span>();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="向前后移动以及Skip操作"><a href="#向前后移动以及Skip操作" class="headerlink" title="向前后移动以及Skip操作"></a>向前后移动以及Skip操作</h2><p><code>data_iter_</code>在移动过程中，有可能因为已经遍历过数据块的最后一条record，<code>data_iter_</code>需要继续移动，指向下一个数据块，而且<code>index_iter_</code>也可能指向空的数据块。对于这些情况，都需要跳过一些数据块，即如下代码所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 向前跳过空的data_iter_</span></div><div class="line"><span class="keyword">void</span> TwoLevelIterator::SkipEmptyDataBlocksForward() &#123;</div><div class="line">  <span class="keyword">while</span> (data_iter_.iter() == <span class="literal">NULL</span> || !data_iter_.Valid()) &#123;</div><div class="line">    <span class="comment">// Move to next block</span></div><div class="line">    <span class="keyword">if</span> (!index_iter_.Valid()) &#123;</div><div class="line">      SetDataIterator(<span class="literal">NULL</span>);</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    index_iter_.Next();</div><div class="line">    InitDataBlock();</div><div class="line">    <span class="keyword">if</span> (data_iter_.iter() != <span class="literal">NULL</span>) data_iter_.SeekToFirst();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 向后跳过空的data_iter_</span></div><div class="line"><span class="keyword">void</span> TwoLevelIterator::SkipEmptyDataBlocksBackward() &#123;</div><div class="line">  <span class="keyword">while</span> (data_iter_.iter() == <span class="literal">NULL</span> || !data_iter_.Valid()) &#123;</div><div class="line">    <span class="comment">// Move to next block</span></div><div class="line">    <span class="keyword">if</span> (!index_iter_.Valid()) &#123;</div><div class="line">      SetDataIterator(<span class="literal">NULL</span>);</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    index_iter_.Prev();</div><div class="line">    InitDataBlock();</div><div class="line">    <span class="keyword">if</span> (data_iter_.iter() != <span class="literal">NULL</span>) data_iter_.SeekToLast();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上述基础上，Prev和Next操作只需要在移动<code>data_iter_</code>移动之后，进行相应的跳空处理即可。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">void</span> <span class="selector-tag">TwoLevelIterator</span><span class="selector-pseudo">::Next()</span> &#123;</div><div class="line">  <span class="selector-tag">assert</span>(Valid());</div><div class="line">  <span class="selector-tag">data_iter_</span><span class="selector-class">.Next</span>();</div><div class="line">  <span class="selector-tag">SkipEmptyDataBlocksForward</span>();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="selector-tag">void</span> <span class="selector-tag">TwoLevelIterator</span><span class="selector-pseudo">::Prev()</span> &#123;</div><div class="line">  <span class="selector-tag">assert</span>(Valid());</div><div class="line">  <span class="selector-tag">data_iter_</span><span class="selector-class">.Prev</span>();</div><div class="line">  <span class="selector-tag">SkipEmptyDataBlocksBackward</span>();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此，leveldb table路径下所有代码分析完毕，下面转入db路径，深入到leveldb的实际建构之中。</p>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb sstable 读取解析]]></title>
      <url>/2017/06/11/leveldb-sstable-%E8%AF%BB%E5%8F%96%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="leveldb-sstable-读取解析"><a href="#leveldb-sstable-读取解析" class="headerlink" title="leveldb sstable 读取解析"></a>leveldb sstable 读取解析</h1><p>结构化数据的读取比写入实现起来更为复杂，levledb中的sstable读取又一次说明了这一点。sstable的读取操作定义在<code>table.h</code>和<code>table.cc</code>之中。在这一节代码中主要实现了sstable的打开操作，以及如何从index handle得到对应block 的interator。</p>
<p><img src="http://static.zybuluo.com/zhoudayang/7si3xos5zadjqg3gujar7mil/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-11%20%E4%B8%8B%E5%8D%889.42.43.png" alt="屏幕快照 2017-06-11 下午9.42.43.png-288.1kB"></p>
<h2 id="Open"><a href="#Open" class="headerlink" title="Open"></a>Open</h2><p>sstable的打开先从footer开始，校验是否是sstable文件。读取meta_block index 和 index block handle。若无误，则根据footer中的信息来创建Rep对象。请注意，这里生成了cache_id，cache_id是采用全局递增的算法产生的，在整个系统中独一无二，后续会在cache之中使用。</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">Status Table::Open(<span class="keyword">const</span> Options&amp; options,</div><div class="line">                   RandomAccessFile* file,</div><div class="line">                   uint64_t size,</div><div class="line">                   Table** table) &#123;</div><div class="line">  *table = <span class="keyword">NULL</span>;</div><div class="line">  <span class="comment">// sstable的文件大小需要大于Footer</span></div><div class="line">  <span class="keyword">if</span> (size &lt; Footer::kEncodedLength) &#123;</div><div class="line">    <span class="keyword">return</span> Status::Corruption(<span class="string">"file is too short to be an sstable"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">char</span> footer_space[Footer::kEncodedLength];</div><div class="line">  Slice footer_input;</div><div class="line">  <span class="comment">// 读取footer</span></div><div class="line">  Status s = file-&gt;Read(size - Footer::kEncodedLength, Footer::kEncodedLength,</div><div class="line">                        &amp;footer_input, footer_space);</div><div class="line">  <span class="keyword">if</span> (!s.ok()) <span class="keyword">return</span> s;</div><div class="line"></div><div class="line">  Footer footer;</div><div class="line">  <span class="comment">// decode from footer Slice</span></div><div class="line">  s = footer.DecodeFrom(&amp;footer_input);</div><div class="line">  <span class="keyword">if</span> (!s.ok()) <span class="keyword">return</span> s;</div><div class="line"></div><div class="line">  <span class="comment">// Read the index block</span></div><div class="line">  BlockContents contents;</div><div class="line">  Block* index_block = <span class="keyword">NULL</span>;</div><div class="line">  <span class="keyword">if</span> (s.ok()) &#123;</div><div class="line">    ReadOptions opt;</div><div class="line">    <span class="comment">// 如果设置了paranoid_checks, 那么需要检查校验码</span></div><div class="line">    <span class="keyword">if</span> (options.paranoid_checks) &#123;</div><div class="line">      opt.verify_checksums = <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 读取index block</span></div><div class="line">    s = ReadBlock(file, opt, footer.index_handle(), &amp;contents);</div><div class="line">    <span class="keyword">if</span> (s.ok()) &#123;</div><div class="line">      index_block = <span class="keyword">new</span> Block(contents);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (s.ok()) &#123;</div><div class="line">    <span class="comment">// We've successfully read the footer and the index block: we're</span></div><div class="line">    <span class="comment">// ready to serve requests.</span></div><div class="line">    Rep* rep = <span class="keyword">new</span> Table::Rep;</div><div class="line">    rep-&gt;options = options;</div><div class="line">    rep-&gt;file = file;</div><div class="line">    rep-&gt;metaindex_handle = footer.metaindex_handle();</div><div class="line">    rep-&gt;index_block = index_block;</div><div class="line">    rep-&gt;cache_id = (options.block_cache ? options.block_cache-&gt;NewId() : <span class="number">0</span>);</div><div class="line">    rep-&gt;filter_data = <span class="keyword">NULL</span>;</div><div class="line">    rep-&gt;filter = <span class="keyword">NULL</span>;</div><div class="line">    *table = <span class="keyword">new</span> Table(rep);</div><div class="line">    <span class="comment">// 读取meta 元数据</span></div><div class="line">    (*table)-&gt;ReadMeta(footer);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    delete index_block;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> s;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>读取meta block会首先查找有没有filter block handle，若有的话读取filter block，创建FilterBlockReader成员。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">void Table::ReadMeta(const Footer&amp; footer) &#123;</div><div class="line">  <span class="comment">// 没有设置filter_policy, return</span></div><div class="line">  <span class="function"><span class="title">if</span> (rep_-&gt;</span>options.filter_policy == NULL</div><div class="line">      || footer.metaindex_handle().size() == <span class="number">0</span>) &#123;</div><div class="line">    return;  <span class="comment">// Do not need any metadata</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ReadOptions opt;</div><div class="line">  <span class="function"><span class="title">if</span> (rep_-&gt;</span>options.paranoid_checks) &#123;</div><div class="line">    opt.verify_checksums = <span class="literal">true</span>;</div><div class="line">  &#125;</div><div class="line">  BlockContents <span class="built_in">contents</span>;</div><div class="line">  <span class="function"><span class="title">if</span> (!ReadBlock(rep_-&gt;</span>file, opt, footer.metaindex_handle(), &amp;<span class="built_in">contents</span>).ok()) &#123;</div><div class="line">    <span class="comment">// Do not propagate errors since meta info is not needed for operation</span></div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// meta index block</span></div><div class="line">  Block* meta = new Block(<span class="built_in">contents</span>);</div><div class="line"></div><div class="line">  I<span class="function"><span class="title">terator</span>* iter = meta-&gt;</span>NewIterator(BytewiseComparator());</div><div class="line">  std::string key = <span class="string">"filter."</span>;</div><div class="line">  <span class="function"><span class="title">key</span>.append(rep_-&gt;</span><span class="function"><span class="title">options</span>.filter_policy-&gt;</span>Name());</div><div class="line">  <span class="comment">// 查找filter 策略对应的filter index block</span></div><div class="line">  <span class="function"><span class="title">iter</span>-&gt;</span>Seek(key);</div><div class="line">  <span class="function"><span class="title">if</span> (iter-&gt;</span>V<span class="function"><span class="title">alid</span>() &amp;&amp; iter-&gt;</span>key() == Slice(key)) &#123;</div><div class="line">    R<span class="function"><span class="title">eadFilter</span>(iter-&gt;</span>value());</div><div class="line">  &#125;</div><div class="line">  delete iter;</div><div class="line">  delete meta;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">void Table::ReadFilter(const Slice&amp; filter_handle_value) &#123;</div><div class="line">  Slice v = filter_handle_value;</div><div class="line">  BlockHandle filter_handle;</div><div class="line">  <span class="keyword">if</span> (!filter_handle.DecodeFrom(&amp;v).ok()) &#123;</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// We might want to unify with ReadBlock() if we start</span></div><div class="line">  <span class="comment">// requiring checksum verification in Table::Open.</span></div><div class="line">  ReadOptions opt;</div><div class="line">  <span class="function"><span class="title">if</span> (rep_-&gt;</span>options.paranoid_checks) &#123;</div><div class="line">    opt.verify_checksums = <span class="literal">true</span>;</div><div class="line">  &#125;</div><div class="line">  BlockContents <span class="keyword">block</span>;</div><div class="line">  <span class="function"><span class="title">if</span> (!ReadBlock(rep_-&gt;</span>file, opt, filter_handle, &amp;<span class="keyword">block</span>).ok()) &#123;</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">block</span>.heap_allocated) &#123;</div><div class="line">    <span class="function"><span class="title">rep_</span>-&gt;</span>filter_data = <span class="keyword">block</span>.<span class="keyword">data</span>.<span class="keyword">data</span>();     <span class="comment">// Will need to delete later</span></div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 创建filter</span></div><div class="line">  <span class="function"><span class="title">rep_</span>-&gt;</span><span class="function"><span class="title">filter</span> = new FilterBlockReader(rep_-&gt;</span>options.filter_policy, <span class="keyword">block</span>.<span class="keyword">data</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="BlockReader"><a href="#BlockReader" class="headerlink" title="BlockReader"></a>BlockReader</h2><p>BlockReader函数根据index_value指定的handle信息，首先尝试从cache中查找block。查找的key是cache_id以及块偏移的组合键。找不到就直接从文件之中读取。根据读取的块创建这个数据块上的iterator。如果是从文件中读取的数据块，在iterator析构的时候，需要将数据块释放给内存；如果是从cache中读取的数据块，在iterator被析构时，需要进行release。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Convert an index iterator value (i.e., an encoded BlockHandle)</span></div><div class="line"><span class="comment">// into an iterator over the contents of the corresponding block.</span></div><div class="line">Iterator* Table::BlockReader(void* arg,</div><div class="line">                             const ReadOptions&amp; options,</div><div class="line">                             const Slice&amp; index_value) &#123;</div><div class="line">  Table* table = reinterpret_cast&lt;Table*&gt;(arg);</div><div class="line">  C<span class="function"><span class="title">ache</span>* block_cache = table-&gt;</span><span class="function"><span class="title">rep_</span>-&gt;</span>options.block_cache;</div><div class="line">  Block* <span class="keyword">block</span> = NULL;</div><div class="line">  Cache::Handle* cache_handle = NULL;</div><div class="line"></div><div class="line">  BlockHandle handle;</div><div class="line">  Slice input = index_value;</div><div class="line">  <span class="comment">// decode block handle from input</span></div><div class="line">  Status s = handle.DecodeFrom(&amp;input);</div><div class="line">  <span class="comment">// We intentionally allow extra stuff in index_value so that we</span></div><div class="line">  <span class="comment">// can add more features in the future.</span></div><div class="line"></div><div class="line">  <span class="keyword">if</span> (s.ok()) &#123;</div><div class="line">    BlockContents <span class="built_in">contents</span>;</div><div class="line">    <span class="keyword">if</span> (block_cache != NULL) &#123;</div><div class="line">      char cache_key_buffer[<span class="number">16</span>];</div><div class="line">      <span class="comment">// cache_id + handle.offset -&gt; key</span></div><div class="line">      E<span class="function"><span class="title">ncodeFixed64</span>(cache_key_buffer, table-&gt;</span><span class="function"><span class="title">rep_</span>-&gt;</span>cache_id);</div><div class="line">      EncodeFixed64(cache_key_buffer+<span class="number">8</span>, handle.offset());</div><div class="line">      Slice key(cache_key_buffer, sizeof(cache_key_buffer));</div><div class="line">      <span class="function"><span class="title">cache_handle</span> = block_cache-&gt;</span>Lookup(key);</div><div class="line">      <span class="keyword">if</span> (cache_handle != NULL) &#123;</div><div class="line">        <span class="comment">// 尝试从缓存之中获取handle对应的block</span></div><div class="line">        <span class="function"><span class="title">block</span> = reinterpret_cast&lt;Block*&gt;(block_cache-&gt;</span>Value(cache_handle));</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// 直接从文件之中读取</span></div><div class="line">        <span class="function"><span class="title">s</span> = ReadBlock(table-&gt;</span><span class="function"><span class="title">rep_</span>-&gt;</span>file, options, handle, &amp;<span class="built_in">contents</span>);</div><div class="line">        <span class="keyword">if</span> (s.ok()) &#123;</div><div class="line">          <span class="keyword">block</span> = new Block(<span class="built_in">contents</span>);</div><div class="line">          <span class="comment">// 缓存it</span></div><div class="line">          <span class="keyword">if</span> (<span class="built_in">contents</span>.cachable &amp;&amp; options.fill_cache) &#123;</div><div class="line">            <span class="function"><span class="title">cache_handle</span> = block_cache-&gt;</span>Insert(</div><div class="line">                <span class="function"><span class="title">key</span>, <span class="keyword">block</span>, <span class="keyword">block</span>-&gt;</span>size(), &amp;DeleteCachedBlock);</div><div class="line">          &#125;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="function"><span class="title">s</span> = ReadBlock(table-&gt;</span><span class="function"><span class="title">rep_</span>-&gt;</span>file, options, handle, &amp;<span class="built_in">contents</span>);</div><div class="line">      <span class="keyword">if</span> (s.ok()) &#123;</div><div class="line">        <span class="keyword">block</span> = new Block(<span class="built_in">contents</span>);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Iterator* iter;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">block</span> != NULL) &#123;</div><div class="line">    <span class="function"><span class="title">iter</span> = <span class="keyword">block</span>-&gt;</span>N<span class="function"><span class="title">ewIterator</span>(table-&gt;</span><span class="function"><span class="title">rep_</span>-&gt;</span>options.comparator);</div><div class="line">    <span class="keyword">if</span> (cache_handle == NULL) &#123;</div><div class="line">      <span class="comment">// 注册cleanup function 为 DeleteBlock</span></div><div class="line">      <span class="function"><span class="title">iter</span>-&gt;</span>RegisterCleanup(&amp;DeleteBlock, <span class="keyword">block</span>, NULL);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// 注册cleanup function 为ReleaseBlock</span></div><div class="line">      <span class="function"><span class="title">iter</span>-&gt;</span>RegisterCleanup(&amp;ReleaseBlock, block_cache, cache_handle);</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 否则创建非法的空的iterator</span></div><div class="line">    iter = NewErrorIterator(s);</div><div class="line">  &#125;</div><div class="line">  return iter;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="NewIterator"><a href="#NewIterator" class="headerlink" title="NewIterator"></a>NewIterator</h2><p>由Table对象返回的Iterator实际上是一个TwoLevelIterator，其具体实现会在后面进行讲解，这个iterator实际上涉及到从index handle到对应data block之间的转换，转换函数就是前面的BlockReader函数。</p>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb table builder 解析]]></title>
      <url>/2017/06/11/leveldb-table-builder-%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="leveldb-table-builder解析"><a href="#leveldb-table-builder解析" class="headerlink" title="leveldb table_builder解析"></a>leveldb table_builder解析</h1><p>在leveldb之中，为了维持接口的简单，不暴露太多的实现细节，大量使用了impl机制，将具体实现定义在内部类之中，table_builder又是一例。</p>
<p>table_builder实际上对应的是sstable的建立过程，包括相关block的存储处理。首先，有必要重温一下sstable文件的具体格式。<br><img src="http://static.zybuluo.com/zhoudayang/xk8bv0ki8r2j97woipfszrc5/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-11%20%E4%B8%8B%E5%8D%889.42.43.png" alt="屏幕快照 2017-06-11 下午9.42.43.png-288.1kB"></p>
<h2 id="成员和构造函数"><a href="#成员和构造函数" class="headerlink" title="成员和构造函数"></a>成员和构造函数</h2><p>table_builder数据成员如下所示：</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">Options options;</div><div class="line">Options index_block_options;</div><div class="line">WritableFile* <span class="keyword">file</span>;</div><div class="line">uint64_t offset;</div><div class="line">Status status;</div><div class="line">BlockBuilder data_block;</div><div class="line">BlockBuilder index_block;</div><div class="line">std::<span class="built_in">string</span> last_key;</div><div class="line">int64_t num_entries;</div><div class="line">bool closed;          // Either Finish() <span class="keyword">or</span> Abandon() has been called.</div><div class="line">// FilterBlock</div><div class="line">FilterBlockBuilder* filter_block;</div><div class="line"></div><div class="line">// We do <span class="keyword">not</span> emit the index entry <span class="keyword">for</span> a <span class="keyword">block</span> <span class="keyword">until</span> we have seen the</div><div class="line">// first key <span class="keyword">for</span> the <span class="keyword">next</span> data <span class="keyword">block</span>.  This allows us <span class="keyword">to</span> <span class="keyword">use</span> shorter</div><div class="line">// keys <span class="keyword">in</span> the index <span class="keyword">block</span>.  <span class="keyword">For</span> example, consider a <span class="keyword">block</span> boundary</div><div class="line">// between the keys <span class="string">"the quick brown fox"</span> <span class="keyword">and</span> <span class="string">"the who"</span>.  We can <span class="keyword">use</span></div><div class="line">// <span class="string">"the r"</span> as the key <span class="keyword">for</span> the index <span class="keyword">block</span> entry since it <span class="keyword">is</span> &gt;= <span class="keyword">all</span></div><div class="line">// entries <span class="keyword">in</span> the first <span class="keyword">block</span> <span class="keyword">and</span> &lt; <span class="keyword">all</span> entries <span class="keyword">in</span> subsequent</div><div class="line">// blocks.</div><div class="line">//</div><div class="line">// Invariant: r-&gt;pending_index_entry <span class="keyword">is</span> <span class="literal">true</span> only <span class="keyword">if</span> data_block <span class="keyword">is</span> empty.</div><div class="line">// 是否需要更新index <span class="keyword">block</span> ?</div><div class="line">// 若data_block为空，那么pending_index_entry为<span class="literal">true</span></div><div class="line">bool pending_index_entry;</div><div class="line">// add 进入 index <span class="keyword">block</span> 的handle</div><div class="line">BlockHandle pending_handle;  // Handle <span class="keyword">to</span> add <span class="keyword">to</span> index <span class="keyword">block</span></div><div class="line"></div><div class="line">// compressed output</div><div class="line">// snappy压缩的输出存放地</div><div class="line">std::<span class="built_in">string</span> compressed_output;</div></pre></td></tr></table></figure>
<p>可见，相关数据成员和sstable文件中的各类型block基本一一对应，其他项用途由注释可知。</p>
<p>在构造函数中，根据输入的参数初始化各成员变量。注意，对于index block，restart间隔被设置为1，也就是每一个record都存储完整的record值。</p>
<p>上面说到的数据成员和构造函数都是内部类Rep的，实际上，TableBuilder通过建立Rep对象，将相关的操作转发给此对象，实现都是在Rep之中。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">TableBuilder::TableBuilder(const <span class="keyword">Options</span>&amp; <span class="keyword">options</span>, WritableFile* <span class="keyword">file</span>)</div><div class="line">    : rep_(<span class="keyword">new</span> Rep(<span class="keyword">options</span>, <span class="keyword">file</span>)) &#123;</div><div class="line">  <span class="keyword">if</span> (rep_-&gt;filter_block != <span class="keyword">NULL</span>) &#123;</div><div class="line">    <span class="comment">// 初始化filter block</span></div><div class="line">    rep_-&gt;filter_block-&gt;StartBlock(<span class="number">0</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h2><p>Add操作是TableBuilder中的重点，占据了大部分篇幅。Add操作也需要保证添加key的顺序是升序。若当前data block为空，将新的data block的handle信息保存在index block之中。请注意，这里对handle的key采用的是比last_key_大，比当前key小的字符串。</p>
<p>若制定了filter_policy，就将这个key加入filter_block，同时记录last_key，更新添加的key的总数，向data block插入这条键值对。若data block的大小超出option限定的值（默认为4K），就调用Flush，将这一数据块写入文件。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">void TableBuilder::Add(const Slice&amp; key, const Slice&amp; value) &#123;</div><div class="line">  Rep* r = rep_;</div><div class="line">  <span class="function"><span class="title">assert</span>(!r-&gt;</span>closed);</div><div class="line">  <span class="keyword">if</span> (!ok()) return;</div><div class="line">  <span class="comment">// 断言Add的key比之前的更大</span></div><div class="line">  <span class="function"><span class="title">if</span> (r-&gt;</span>num_entries &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="function"><span class="title">assert</span>(r-&gt;</span><span class="function"><span class="title">options</span>.comparator-&gt;</span>C<span class="function"><span class="title">ompare</span>(key, Slice(r-&gt;</span>last_key)) &gt; <span class="number">0</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="title">if</span> (r-&gt;</span>pending_index_entry) &#123;</div><div class="line">    <span class="function"><span class="title">assert</span>(r-&gt;</span>data_block.empty());</div><div class="line">    <span class="comment">// 找到比last_key大，比key小的key，存放在last_key之中</span></div><div class="line">    <span class="function"><span class="title">r</span>-&gt;</span><span class="function"><span class="title">options</span>.comparator-&gt;</span>F<span class="function"><span class="title">indShortestSeparator</span>(&amp;r-&gt;</span>last_key, key);</div><div class="line">    std::string handle_encoding;</div><div class="line">    <span class="comment">// 记录第一个data block，保存进入index_block之中</span></div><div class="line">    <span class="function"><span class="title">r</span>-&gt;</span>pending_handle.EncodeTo(&amp;handle_encoding);</div><div class="line">    <span class="comment">// 在index block之中添加这个block的handle信息</span></div><div class="line">    <span class="function"><span class="title">r</span>-&gt;</span><span class="function"><span class="title">index_block</span>.Add(r-&gt;</span>last_key, Slice(handle_encoding));</div><div class="line">    <span class="function"><span class="title">r</span>-&gt;</span>pending_index_entry = <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 向filter_block之中add key</span></div><div class="line">  <span class="function"><span class="title">if</span> (r-&gt;</span>filter_block != NULL) &#123;</div><div class="line">    <span class="function"><span class="title">r</span>-&gt;</span><span class="function"><span class="title">filter_block</span>-&gt;</span>AddKey(key);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 记录last key</span></div><div class="line">  <span class="function"><span class="title">r</span>-&gt;</span>last_key.assign(key.<span class="keyword">data</span>(), key.size());</div><div class="line">  <span class="comment">// 记录add key的总数</span></div><div class="line">  <span class="function"><span class="title">r</span>-&gt;</span>num_entries++;</div><div class="line">  <span class="comment">// 向data block之中添加这一条记录</span></div><div class="line">  <span class="function"><span class="title">r</span>-&gt;</span>data_block.Add(key, value);</div><div class="line"></div><div class="line">  <span class="function"><span class="title">const</span> size_t estimated_block_size = r-&gt;</span>data_block.CurrentSizeEstimate();</div><div class="line">  <span class="comment">// 若data block的大小超出设定值，Flush 4K</span></div><div class="line">  <span class="function"><span class="title">if</span> (estimated_block_size &gt;= r-&gt;</span>options.block_size) &#123;</div><div class="line">    Flush();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Flush操作如下：</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">void TableBuilder::Flush() &#123;</div><div class="line">  Rep* r = rep_;</div><div class="line">  <span class="function"><span class="title">assert</span>(!r-&gt;</span>closed);</div><div class="line">  <span class="keyword">if</span> (!ok()) return;</div><div class="line">  <span class="function"><span class="title">if</span> (r-&gt;</span>data_block.empty()) return;</div><div class="line">  <span class="comment">// data block 不为空</span></div><div class="line">  <span class="function"><span class="title">assert</span>(!r-&gt;</span>pending_index_entry);</div><div class="line">  W<span class="function"><span class="title">riteBlock</span>(&amp;r-&gt;</span><span class="function"><span class="title">data_block</span>, &amp;r-&gt;</span>pending_handle);</div><div class="line">  <span class="keyword">if</span> (ok()) &#123;</div><div class="line">    <span class="comment">// 需要写入新的数据块</span></div><div class="line">    <span class="function"><span class="title">r</span>-&gt;</span>pending_index_entry = <span class="literal">true</span>;</div><div class="line">    <span class="comment">// flush</span></div><div class="line">    <span class="function"><span class="title">r</span>-&gt;</span><span class="function"><span class="title">status</span> = r-&gt;</span><span class="function"><span class="title">file</span>-&gt;</span>Flush();</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 若filter_block不为空，那么开始对r-&gt;offset段写入滤值</span></div><div class="line">  <span class="function"><span class="title">if</span> (r-&gt;</span>filter_block != NULL) &#123;</div><div class="line">    <span class="function"><span class="title">r</span>-&gt;</span><span class="function"><span class="title">filter_block</span>-&gt;</span>S<span class="function"><span class="title">tartBlock</span>(r-&gt;</span>offset);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Flush首先写入数据块，更新新的数据块对应的handle位置，并且通知filter policy开始对新的offset生成filter。</p>
<p>在WriteBlock中，根据option设定，对data block进行可选的压缩处理。只有当压缩选项被设置，而且压缩可用，压缩减小的空间大小高于12.5%，才会进行压缩。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">void TableBuilder::WriteBlock(BlockBuilder* <span class="keyword">block</span>, BlockHandle* handle) &#123;</div><div class="line">  <span class="comment">// File format contains a sequence of blocks where each block has:</span></div><div class="line">  <span class="comment">//    block_data: uint8[n]</span></div><div class="line">  <span class="comment">//    type: uint8</span></div><div class="line">  <span class="comment">//    crc: uint32</span></div><div class="line">  assert(ok());</div><div class="line">  Rep* r = rep_;</div><div class="line">  S<span class="function"><span class="title">lice</span> raw = <span class="keyword">block</span>-&gt;</span>Finish();</div><div class="line"></div><div class="line">  Slice block_contents;</div><div class="line">  C<span class="function"><span class="title">ompressionType</span> type = r-&gt;</span>options.compression;</div><div class="line">  <span class="comment">// TODO(postrelease): Support more compression options: zlib?</span></div><div class="line">  switch (type) &#123;</div><div class="line">    case kNoCompression:</div><div class="line">      block_contents = raw;</div><div class="line">      break;</div><div class="line"></div><div class="line">    case kSnappyCompression: &#123;</div><div class="line">      <span class="function"><span class="title">std</span>::string* compressed = &amp;r-&gt;</span>compressed_output;</div><div class="line">      <span class="comment">// 使用snappy压缩成功，并且压缩的空间大于12.5%</span></div><div class="line">      <span class="keyword">if</span> (port::Snappy_Compress(raw.<span class="keyword">data</span>(), raw.size(), compressed) &amp;&amp;</div><div class="line">          <span class="function"><span class="title">compressed</span>-&gt;</span>size() &lt; raw.size() - (raw.size() / <span class="number">8</span>u)) &#123;</div><div class="line">        block_contents = *compressed;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// Snappy not supported, or compressed less than 12.5%, so just</span></div><div class="line">        <span class="comment">// store uncompressed form</span></div><div class="line">        block_contents = raw;</div><div class="line">        type = kNoCompression;</div><div class="line">      &#125;</div><div class="line">      break;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  WriteRawBlock(block_contents, type, handle);</div><div class="line">  <span class="function"><span class="title">r</span>-&gt;</span>compressed_output.clear();</div><div class="line">  <span class="function"><span class="title">block</span>-&gt;</span>Reset();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>WriteRawBlock中，还为写入的data block添加了crc校验码以及type信息。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">void TableBuilder::WriteRawBlock(const Slice&amp; block_contents,</div><div class="line">                                 CompressionType type,</div><div class="line">                                 BlockHandle* handle) &#123;</div><div class="line">  Rep* r = rep_;</div><div class="line">  <span class="comment">// 设置offset和size, 其实设置在r-&gt;pending_handle之中</span></div><div class="line">  <span class="function"><span class="title">handle</span>-&gt;</span><span class="function"><span class="title">set_offset</span>(r-&gt;</span>offset);</div><div class="line">  <span class="function"><span class="title">handle</span>-&gt;</span>set_size(block_contents.size());</div><div class="line">  <span class="comment">// 向file中写入block</span></div><div class="line">  <span class="function"><span class="title">r</span>-&gt;</span><span class="function"><span class="title">status</span> = r-&gt;</span><span class="function"><span class="title">file</span>-&gt;</span>Append(block_contents);</div><div class="line">  <span class="function"><span class="title">if</span> (r-&gt;</span>status.ok()) &#123;</div><div class="line">    char trailer[kBlockTrailerSize];</div><div class="line">    trailer[<span class="number">0</span>] = type;</div><div class="line">    uint32_t crc = crc32c::Value(block_contents.<span class="keyword">data</span>(), block_contents.size());</div><div class="line">    crc = crc32c::Extend(crc, trailer, <span class="number">1</span>);  <span class="comment">// Extend crc to cover block type</span></div><div class="line">    EncodeFixed32(trailer+<span class="number">1</span>, crc32c::Mask(crc));</div><div class="line">    <span class="comment">// 写入trailer</span></div><div class="line">    <span class="function"><span class="title">r</span>-&gt;</span><span class="function"><span class="title">status</span> = r-&gt;</span><span class="function"><span class="title">file</span>-&gt;</span>Append(Slice(trailer, kBlockTrailerSize));</div><div class="line">    <span class="function"><span class="title">if</span> (r-&gt;</span>status.ok()) &#123;</div><div class="line">      <span class="function"><span class="title">r</span>-&gt;</span>offset += block_contents.size() + kBlockTrailerSize;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Finish"><a href="#Finish" class="headerlink" title="Finish"></a>Finish</h2><p><img src="http://static.zybuluo.com/zhoudayang/xk8bv0ki8r2j97woipfszrc5/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-11%20%E4%B8%8B%E5%8D%889.42.43.png" alt="屏幕快照 2017-06-11 下午9.42.43.png-288.1kB"></p>
<p>finish操作会将数据块都写入到文件，并且依照sstable文件格式，依次写入filter block，filter index block，index block，footer，完成收尾工作。</p>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">Status TableBuilder::Finish() &#123;</div><div class="line">  Rep* r = rep_;</div><div class="line">  Flush();</div><div class="line">  <span class="function"><span class="title">assert</span>(!r-&gt;</span>closed);</div><div class="line">  <span class="function"><span class="title">r</span>-&gt;</span>closed = <span class="literal">true</span>;</div><div class="line"></div><div class="line">  BlockHandle filter_block_handle, metaindex_block_handle, index_block_handle;</div><div class="line"></div><div class="line">  <span class="comment">// Write filter block</span></div><div class="line">  <span class="comment">// 记录filter block 的handle</span></div><div class="line">  <span class="function"><span class="title">if</span> (ok() &amp;&amp; r-&gt;</span>filter_block != NULL) &#123;</div><div class="line">    W<span class="function"><span class="title">riteRawBlock</span>(r-&gt;</span><span class="function"><span class="title">filter_block</span>-&gt;</span>Finish(), kNoCompression,</div><div class="line">                  &amp;filter_block_handle);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Write metaindex block</span></div><div class="line">  <span class="keyword">if</span> (ok()) &#123;</div><div class="line">    B<span class="function"><span class="title">lockBuilder</span> meta_index_block(&amp;r-&gt;</span>options);</div><div class="line">    <span class="function"><span class="title">if</span> (r-&gt;</span>filter_block != NULL) &#123;</div><div class="line">      <span class="comment">// Add mapping from "filter.Name" to location of filter data</span></div><div class="line">      std::string key = <span class="string">"filter."</span>;</div><div class="line">      <span class="function"><span class="title">key</span>.append(r-&gt;</span><span class="function"><span class="title">options</span>.filter_policy-&gt;</span>Name());</div><div class="line">      std::string handle_encoding;</div><div class="line">      filter_block_handle.EncodeTo(&amp;handle_encoding);</div><div class="line">      <span class="comment">// 将filter block的信息加入mata_index_block</span></div><div class="line">      meta_index_block.Add(key, handle_encoding);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// TODO(postrelease): Add stats and other meta blocks</span></div><div class="line">    WriteBlock(&amp;meta_index_block, &amp;metaindex_block_handle);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Write index block</span></div><div class="line">  <span class="keyword">if</span> (ok()) &#123;</div><div class="line">    <span class="function"><span class="title">if</span> (r-&gt;</span>pending_index_entry) &#123;</div><div class="line">      <span class="function"><span class="title">r</span>-&gt;</span><span class="function"><span class="title">options</span>.comparator-&gt;</span>F<span class="function"><span class="title">indShortSuccessor</span>(&amp;r-&gt;</span>last_key);</div><div class="line">      std::string handle_encoding;</div><div class="line">      <span class="function"><span class="title">r</span>-&gt;</span>pending_handle.EncodeTo(&amp;handle_encoding);</div><div class="line">      <span class="comment">// 添加最后一个data block的handle信息</span></div><div class="line">      <span class="function"><span class="title">r</span>-&gt;</span><span class="function"><span class="title">index_block</span>.Add(r-&gt;</span>last_key, Slice(handle_encoding));</div><div class="line">      <span class="function"><span class="title">r</span>-&gt;</span>pending_index_entry = <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 写入index block</span></div><div class="line">    W<span class="function"><span class="title">riteBlock</span>(&amp;r-&gt;</span>index_block, &amp;index_block_handle);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Write footer</span></div><div class="line">  <span class="keyword">if</span> (ok()) &#123;</div><div class="line">    Footer footer;</div><div class="line">    footer.set_metaindex_handle(metaindex_block_handle);</div><div class="line">    footer.set_index_handle(index_block_handle);</div><div class="line">    std::string footer_encoding;</div><div class="line">    footer.EncodeTo(&amp;footer_encoding);</div><div class="line">    <span class="function"><span class="title">r</span>-&gt;</span><span class="function"><span class="title">status</span> = r-&gt;</span><span class="function"><span class="title">file</span>-&gt;</span>Append(footer_encoding);</div><div class="line">    <span class="function"><span class="title">if</span> (r-&gt;</span>status.ok()) &#123;</div><div class="line">      <span class="function"><span class="title">r</span>-&gt;</span>offset += footer_encoding.size();</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="title">return</span> r-&gt;</span>status;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb format解析]]></title>
      <url>/2017/06/11/leveldb-format%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="leveldb-format-解析"><a href="#leveldb-format-解析" class="headerlink" title="leveldb format 解析"></a>leveldb format 解析</h1><p>下面解析的是leveldb中的源文件<code>format.h</code>和<code>format.cc</code>，这一节代码主要围绕handle的存储和解析，footer的存储和解析，以及block的读取。</p>
<h2 id="handle"><a href="#handle" class="headerlink" title="handle"></a>handle</h2><p>handle 是对block文件之中位移和大小封装的数据结构，有了它，就能迅速对block进行定位。因为采取varint64存储这两个值，所以占据的大小最大为10bytes。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockHandle</span> &#123;</span></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  BlockHandle();</div><div class="line"></div><div class="line">  <span class="comment">// The offset of the block in the file.</span></div><div class="line">  <span class="keyword">uint64_t</span> offset() <span class="keyword">const</span> &#123; <span class="keyword">return</span> offset_; &#125;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_offset</span><span class="params">(<span class="keyword">uint64_t</span> offset)</span> </span>&#123; offset_ = offset; &#125;</div><div class="line"></div><div class="line">  <span class="comment">// The size of the stored block</span></div><div class="line">  <span class="keyword">uint64_t</span> size() <span class="keyword">const</span> &#123; <span class="keyword">return</span> size_; &#125;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_size</span><span class="params">(<span class="keyword">uint64_t</span> size)</span> </span>&#123; size_ = size; &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 向dst指定的地址位置存入offset和size</span></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">EncodeTo</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* dst)</span> <span class="keyword">const</span></span>;</div><div class="line">  <span class="comment">// 从input指定的地址位置获取offset和size</span></div><div class="line">  <span class="function">Status <span class="title">DecodeFrom</span><span class="params">(Slice* input)</span></span>;</div><div class="line"></div><div class="line">  <span class="comment">// Maximum encoding length of a BlockHandle</span></div><div class="line">  <span class="comment">// 两个varint64数占用的空间最大为20bytes</span></div><div class="line">  <span class="keyword">enum</span> &#123; kMaxEncodedLength = <span class="number">10</span> + <span class="number">10</span> &#125;;</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="keyword">uint64_t</span> offset_;</div><div class="line">  <span class="keyword">uint64_t</span> size_;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h2><p>Footer位于整个sstable文件的底部，由footer可以快速获取sstable中的metaindex block，index block的位置信息，通过比较魔数，能够快速判断是否是leveldb之中使用的sstable文件。</p>
<p><img src="http://static.zybuluo.com/zhoudayang/k31lp9l5et3zbylhmqfd01r3/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-11%20%E4%B8%8B%E5%8D%889.06.42.png" alt="屏幕快照 2017-06-11 下午9.06.42.png-200.9kB"></p>
<p>在Footer之中，前面40bytes存储Metaindex_handle和Index_handle，若空间不足40bytes就用0补齐。之后存放leveldb中定义的魔数<code>0xdb4775248b80fb57ull</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// footer</span></div><div class="line"><span class="comment">// metaindex_handle</span></div><div class="line"><span class="comment">// index_handle</span></div><div class="line"><span class="comment">// padding</span></div><div class="line"><span class="comment">// magic number</span></div><div class="line"><span class="keyword">void</span> Footer::EncodeTo(<span class="built_in">std</span>::<span class="built_in">string</span>* dst) <span class="keyword">const</span> &#123;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> original_size = dst-&gt;size();</div><div class="line">  <span class="comment">// 此处存放的是varint64</span></div><div class="line">  metaindex_handle_.EncodeTo(dst);</div><div class="line">  index_handle_.EncodeTo(dst);</div><div class="line">  dst-&gt;resize(<span class="number">2</span> * BlockHandle::kMaxEncodedLength);  <span class="comment">// Padding</span></div><div class="line">  <span class="comment">// 加上padding，为 40 bytes</span></div><div class="line">  <span class="comment">// 再加上8bytes对应的魔数</span></div><div class="line">  <span class="comment">// 先存低 4bytes</span></div><div class="line">  PutFixed32(dst, <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(kTableMagicNumber &amp; <span class="number">0xffffffff</span>u));</div><div class="line">  <span class="comment">// 再存高 4 bytes</span></div><div class="line">  PutFixed32(dst, <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(kTableMagicNumber &gt;&gt; <span class="number">32</span>));</div><div class="line">  assert(dst-&gt;size() == original_size + kEncodedLength);</div><div class="line">  (<span class="keyword">void</span>)original_size;  <span class="comment">// Disable unused variable warning.</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在读取footer时，首先读取魔数，没有问题才继续读取meta index handle和index handle。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// input输入的是整个footer</span></div><div class="line">Status Footer::DecodeFrom(Slice* input) &#123;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* magic_ptr = input-&gt;data() + kEncodedLength - <span class="number">8</span>;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> magic_lo = DecodeFixed32(magic_ptr);</div><div class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> magic_hi = DecodeFixed32(magic_ptr + <span class="number">4</span>);</div><div class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> magic = ((<span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(magic_hi) &lt;&lt; <span class="number">32</span>) |</div><div class="line">                          (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(magic_lo)));</div><div class="line">  <span class="comment">// 魔数不匹配</span></div><div class="line">  <span class="keyword">if</span> (magic != kTableMagicNumber) &#123;</div><div class="line">    <span class="keyword">return</span> Status::Corruption(<span class="string">"not an sstable (bad magic number)"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Status result = metaindex_handle_.DecodeFrom(input);</div><div class="line">  <span class="keyword">if</span> (result.ok()) &#123;</div><div class="line">    result = index_handle_.DecodeFrom(input);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (result.ok()) &#123;</div><div class="line">    <span class="comment">// We skip over any leftover data (just padding for now) in "input"</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* end = magic_ptr + <span class="number">8</span>;</div><div class="line">    *input = Slice(end, input-&gt;data() + input-&gt;size() - end);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="block"><a href="#block" class="headerlink" title="block"></a>block</h2><p>leveldb在存储block的时候，实际上还要记录block的类型和当前block的CRC校验值在后面进行校验。block格式如下所示：</p>
<p><img src="http://static.zybuluo.com/zhoudayang/1mxx9gsxgrd6fooqe3anqdu8/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-11%20%E4%B8%8B%E5%8D%889.14.06.png" alt="屏幕快照 2017-06-11 下午9.14.06.png-569.7kB"></p>
<p>读取block时，首先根据option要求进行可选的crc校验，再根据type查看是压缩数据块还是raw block，对压缩数据块进行解压缩。若成功读取将读取处理之后的block记录在result之中，失败了就返回相应的状态码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// block - type - crc</span></div><div class="line"><span class="function">Status <span class="title">ReadBlock</span><span class="params">(RandomAccessFile* file,</span></span></div><div class="line">                 <span class="keyword">const</span> ReadOptions&amp; options,</div><div class="line">                 <span class="keyword">const</span> BlockHandle&amp; handle,</div><div class="line">                 BlockContents* result) &#123;</div><div class="line">  result-&gt;data = Slice();</div><div class="line">  result-&gt;cachable = <span class="literal">false</span>;</div><div class="line">  result-&gt;heap_allocated = <span class="literal">false</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Read the block contents as well as the type/crc footer.</span></div><div class="line">  <span class="comment">// See table_builder.cc for the code that built this structure.</span></div><div class="line">  <span class="keyword">size_t</span> n = <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(handle.size());</div><div class="line">  <span class="keyword">char</span>* buf = <span class="keyword">new</span> <span class="keyword">char</span>[n + kBlockTrailerSize];</div><div class="line">  Slice contents;</div><div class="line">  Status s = file-&gt;Read(handle.offset(), n + kBlockTrailerSize, &amp;contents, buf);</div><div class="line">  <span class="comment">// 读取失败</span></div><div class="line">  <span class="keyword">if</span> (!s.ok()) &#123;</div><div class="line">    <span class="keyword">delete</span>[] buf;</div><div class="line">    <span class="keyword">return</span> s;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 读取的block大小和handle不一致</span></div><div class="line">  <span class="keyword">if</span> (contents.size() != n + kBlockTrailerSize) &#123;</div><div class="line">    <span class="keyword">delete</span>[] buf;</div><div class="line">    <span class="keyword">return</span> Status::Corruption(<span class="string">"truncated block read"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 检查block+type计算得到的crc值是否和记录的所一致</span></div><div class="line">  <span class="comment">// Check the crc of the type and the block contents</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* data = contents.data();    <span class="comment">// Pointer to where Read put the data</span></div><div class="line">  <span class="keyword">if</span> (options.verify_checksums) &#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> crc = crc32c::Unmask(DecodeFixed32(data + n + <span class="number">1</span>));</div><div class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> actual = crc32c::Value(data, n + <span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (actual != crc) &#123;</div><div class="line">      <span class="keyword">delete</span>[] buf;</div><div class="line">      s = Status::Corruption(<span class="string">"block checksum mismatch"</span>);</div><div class="line">      <span class="keyword">return</span> s;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 针对block的不同类型，采取不同的操作</span></div><div class="line">  <span class="keyword">switch</span> (data[n]) &#123;</div><div class="line">    <span class="keyword">case</span> kNoCompression:</div><div class="line">      <span class="keyword">if</span> (data != buf) &#123;</div><div class="line">        <span class="comment">// File implementation gave us pointer to some other data.</span></div><div class="line">        <span class="comment">// Use it directly under the assumption that it will be live</span></div><div class="line">        <span class="comment">// while the file is open.</span></div><div class="line">        <span class="comment">// 内部文件操作返回的buf不是之前分配的</span></div><div class="line">        <span class="keyword">delete</span>[] buf;</div><div class="line">        result-&gt;data = Slice(data, n);</div><div class="line">        result-&gt;heap_allocated = <span class="literal">false</span>;</div><div class="line">        result-&gt;cachable = <span class="literal">false</span>;  <span class="comment">// Do not double-cache</span></div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        result-&gt;data = Slice(buf, n);</div><div class="line">        result-&gt;heap_allocated = <span class="literal">true</span>;</div><div class="line">        result-&gt;cachable = <span class="literal">true</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// Ok</span></div><div class="line">      <span class="keyword">break</span>;</div><div class="line">      <span class="comment">// 是压缩的类型，获取解压的长度，解压block</span></div><div class="line">    <span class="keyword">case</span> kSnappyCompression: &#123;</div><div class="line">      <span class="keyword">size_t</span> ulength = <span class="number">0</span>;</div><div class="line">      <span class="keyword">if</span> (!port::Snappy_GetUncompressedLength(data, n, &amp;ulength)) &#123;</div><div class="line">        <span class="keyword">delete</span>[] buf;</div><div class="line">        <span class="keyword">return</span> Status::Corruption(<span class="string">"corrupted compressed block contents"</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">char</span>* ubuf = <span class="keyword">new</span> <span class="keyword">char</span>[ulength];</div><div class="line">      <span class="keyword">if</span> (!port::Snappy_Uncompress(data, n, ubuf)) &#123;</div><div class="line">        <span class="keyword">delete</span>[] buf;</div><div class="line">        <span class="keyword">delete</span>[] ubuf;</div><div class="line">        <span class="keyword">return</span> Status::Corruption(<span class="string">"corrupted compressed block contents"</span>);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">delete</span>[] buf;</div><div class="line">      result-&gt;data = Slice(ubuf, ulength);</div><div class="line">      result-&gt;heap_allocated = <span class="literal">true</span>;</div><div class="line">      result-&gt;cachable = <span class="literal">true</span>;</div><div class="line">      <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">default</span>:</div><div class="line">      <span class="keyword">delete</span>[] buf;</div><div class="line">      <span class="keyword">return</span> Status::Corruption(<span class="string">"bad block type"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> Status::OK();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb data block 建立]]></title>
      <url>/2017/06/11/leveldb-data-block-%E5%BB%BA%E7%AB%8B/</url>
      <content type="html"><![CDATA[<h1 id="leveldb-data-block-建立"><a href="#leveldb-data-block-建立" class="headerlink" title="leveldb data block 建立"></a>leveldb data block 建立</h1><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>相比data block的读取来说，data block的建立比较简单，因为不涉及到查找的操作。下面的所有操作都是根据data block 内部的组织格式进行的，如下图所示。</p>
<p>data block</p>
<p><img src="http://static.zybuluo.com/zhoudayang/vrb731ujpwkkkqntl165t80y/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-11%20%E4%B8%8B%E5%8D%887.35.06.png" alt="屏幕快照 2017-06-11 下午7.35.06.png-387.6kB"></p>
<p>record </p>
<p><img src="http://static.zybuluo.com/zhoudayang/rirmd5ijemot7tj0v817wh2k/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-11%20%E4%B8%8B%E5%8D%887.40.37.png" alt="屏幕快照 2017-06-11 下午7.40.37.png-112.6kB"></p>
<p>leveldb data block 建立相关的代码是<code>data_block.h</code>和<code>data_block.c</code>。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h3><p>类成员如下所示，buffers<em>存放最终生成的data block，restarts\</em>对应restarts数组，counter是自从上一次restart以来添加的key的计数，last_key_记录了上一次add的key。Options对应传入的参数，其中定义了restart的间隔大小限制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Options*        options_;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span>           buffer_;      <span class="comment">// Destination buffer</span></div><div class="line"><span class="comment">// 所有的restart数组的元素</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint32_t</span>&gt; restarts_;    <span class="comment">// Restart points</span></div><div class="line"><span class="comment">// restart之后已经加入的entry的数目</span></div><div class="line"><span class="keyword">int</span>                   counter_;     <span class="comment">// Number of entries emitted since restart</span></div><div class="line"><span class="keyword">bool</span>                  finished_;    <span class="comment">// Has Finish() been called?</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">string</span>           last_key_;</div></pre></td></tr></table></figure>
<h3 id="辅助类成员函数"><a href="#辅助类成员函数" class="headerlink" title="辅助类成员函数"></a>辅助类成员函数</h3><p>CurrentSizeEstimate() 返回当前估计的data block的大小，empty判断当前数据块是否为空，Reset重置所有状态，丢弃所有添加的key。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Reset the contents as if the BlockBuilder was just constructed.</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"><span class="comment">// Returns an estimate of the current (uncompressed) size of the block</span></div><div class="line"><span class="comment">// we are building.</span></div><div class="line"><span class="keyword">size_t</span> CurrentSizeEstimate() <span class="keyword">const</span>;</div><div class="line"></div><div class="line"><span class="comment">// Return true iff no entries have been added since the last Reset()</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> buffer_.empty();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Add和Finish操作"><a href="#Add和Finish操作" class="headerlink" title="Add和Finish操作"></a>Add和Finish操作</h3><p>data block在BlockBuilder类对象初始化之后，通过Add方法向block中添加键值对记录，数据块建立完成之后，调用Finish返回完整的数据块数据。</p>
<p>Add操作要求添加的key的顺序应该是升序的。在Add中，首先检查是否达到restart间隔。若达到了，那么shared key的长度为0，否则和last key比较得到shared key的长度。之后则将共享key，非共享key，value的长度值写入buffer之中，同时也将非共享key和value的值写入buffer，更新last key。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> BlockBuilder::Add(<span class="keyword">const</span> Slice&amp; <span class="built_in">key</span>, <span class="keyword">const</span> Slice&amp; value) &#123;</div><div class="line">  Slice last_key_piece(last_key_);</div><div class="line">  <span class="keyword">assert</span>(!finished_);</div><div class="line">  <span class="keyword">assert</span>(counter_ &lt;= options_-&gt;block_restart_interval);</div><div class="line">  <span class="comment">// 要求key比last_key要大</span></div><div class="line">  <span class="keyword">assert</span>(buffer_.empty() <span class="comment">// No values yet?</span></div><div class="line">         || options_-&gt;comparator-&gt;Compare(<span class="built_in">key</span>, last_key_piece) &gt; <span class="number">0</span>);</div><div class="line">  size_t shared = <span class="number">0</span>;</div><div class="line">  <span class="keyword">if</span> (counter_ &lt; options_-&gt;block_restart_interval) &#123;</div><div class="line">    <span class="comment">// See how much sharing to do with previous string</span></div><div class="line">    <span class="keyword">const</span> size_t min_length = std::<span class="built_in">min</span>(last_key_piece.<span class="built_in">size</span>(), <span class="built_in">key</span>.<span class="built_in">size</span>());</div><div class="line">    <span class="comment">// 计算shared 的key的长度</span></div><div class="line">    <span class="keyword">while</span> ((shared &lt; min_length) &amp;&amp; (last_key_piece[shared] == <span class="built_in">key</span>[shared])) &#123;</div><div class="line">      shared++;</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// Restart compression</span></div><div class="line">    restarts_.push_back(buffer_.<span class="built_in">size</span>());</div><div class="line">    counter_ = <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 不共享的key的长度</span></div><div class="line">  <span class="keyword">const</span> size_t non_shared = <span class="built_in">key</span>.<span class="built_in">size</span>() - shared;</div><div class="line"></div><div class="line">  <span class="comment">// Add "&lt;shared&gt;&lt;non_shared&gt;&lt;value_size&gt;" to buffer_</span></div><div class="line">  PutVarint32(&amp;buffer_, shared);</div><div class="line">  PutVarint32(&amp;buffer_, non_shared);</div><div class="line">  PutVarint32(&amp;buffer_, value.<span class="built_in">size</span>());</div><div class="line"></div><div class="line">  <span class="comment">// Add string delta to buffer_ followed by value</span></div><div class="line">  buffer_.<span class="built_in">append</span>(<span class="built_in">key</span>.data() + shared, non_shared);</div><div class="line">  buffer_.<span class="built_in">append</span>(value.data(), value.<span class="built_in">size</span>());</div><div class="line"></div><div class="line">  <span class="comment">// Update state</span></div><div class="line">  <span class="comment">// 设置last key</span></div><div class="line">  last_key_.resize(shared);</div><div class="line">  last_key_.<span class="built_in">append</span>(<span class="built_in">key</span>.data() + shared, non_shared);</div><div class="line">  <span class="keyword">assert</span>(Slice(last_key_) == <span class="built_in">key</span>);</div><div class="line">  counter_++;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Finish操作则是将所有的restarts数组元素写入到block之中，同时在block之中写入数组的size信息，返回整个block对应的Slice。</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 调用finish，设置restarts数组和restarts数组的个数，返回此data block</div><div class="line">Slice BlockBuilder::Finish() &#123;</div><div class="line">  // Append restart<span class="built_in"> array</span></div><div class="line">  for (size_t i = 0; i &lt; restarts_.size(); i++) &#123;</div><div class="line">    PutFixed32(&amp;buffer_, restarts_[i]);</div><div class="line">  &#125;</div><div class="line">  // put restarts_.size()</div><div class="line">  PutFixed32(&amp;buffer_, restarts_.size());</div><div class="line">  finished_ = true;</div><div class="line"> <span class="built_in"> return </span>Slice(buffer_);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb data block 读取解析]]></title>
      <url>/2017/06/11/leveldb-data-block-%E8%AF%BB%E5%8F%96%E8%A7%A3%E6%9E%90/</url>
      <content type="html"><![CDATA[<h1 id="leveldb-data-block-读取解析"><a href="#leveldb-data-block-读取解析" class="headerlink" title="leveldb data block 读取解析"></a>leveldb data block 读取解析</h1><p>下面解析的代码是<code>block.h</code>和<code>block.cc</code>，这一部分代码的功能是读取data block，并且提供一个基于data block中存储数据之上的迭代器。这一部分代码的实现首先基于data block内部存储格式，并且借助了data block数据有序的特性。</p>
<p>data block 内部格式<br><img src="http://static.zybuluo.com/zhoudayang/szkqrrzdn35g22vr09vtn33y/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-11%20%E4%B8%8B%E5%8D%887.35.06.png" alt="data block"></p>
<p>record 格式<br><img src="http://static.zybuluo.com/zhoudayang/hyw0u7ftkyxfbbzmnwj5po0p/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-11%20%E4%B8%8B%E5%8D%887.40.37.png" alt="record"></p>
<h2 id="Block"><a href="#Block" class="headerlink" title="Block"></a>Block</h2><p>Block的基本第一很简单，主要逻辑是一个迭代器的实现，定义在在内部类Iter中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Block</span> &#123;</span></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="comment">// Initialize the block with the specified contents.</span></div><div class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Block</span><span class="params">(<span class="keyword">const</span> BlockContents&amp; contents)</span></span>;</div><div class="line"></div><div class="line">  ~Block();</div><div class="line"></div><div class="line">  <span class="keyword">size_t</span> size() <span class="keyword">const</span> &#123; <span class="keyword">return</span> size_; &#125;</div><div class="line">  <span class="comment">// Return new Iterator of given comparator</span></div><div class="line">  <span class="function">Iterator* <span class="title">NewIterator</span><span class="params">(<span class="keyword">const</span> Comparator* comparator)</span></span>;</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="keyword">uint32_t</span> NumRestarts() <span class="keyword">const</span>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* data_; <span class="comment">// 指向data block 开始处</span></div><div class="line">  <span class="keyword">size_t</span> size_;   <span class="comment">// data block的大小</span></div><div class="line">  <span class="keyword">uint32_t</span> restart_offset_;     <span class="comment">// Offset in data_ of restart array</span></div><div class="line">  <span class="keyword">bool</span> owned_;                  <span class="comment">// Block owns data_[], if own need to call free when destruction</span></div><div class="line"></div><div class="line">  <span class="comment">// No copying allowed</span></div><div class="line">  Block(<span class="keyword">const</span> Block&amp;);</div><div class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> Block&amp;);</div><div class="line">  <span class="comment">// 内部实现实际定义在Iter中</span></div><div class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Iter</span>;</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在构造函数中，读取restarts数组的数目，判断是否合理，即存储的数组大小不可超出<code>max_restarts_allowed</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 读取contents对应的block</span></div><div class="line"><span class="comment">// 实际上读取的是data block</span></div><div class="line">Block::Block(<span class="keyword">const</span> BlockContents&amp; contents)</div><div class="line">    : data_(contents.data.data()),</div><div class="line">      size_(contents.data.size()),</div><div class="line">      owned_(contents.heap_allocated) &#123;</div><div class="line">  <span class="keyword">if</span> (size_ &lt; <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>)) &#123;</div><div class="line">    size_ = <span class="number">0</span>;  <span class="comment">// Error marker</span></div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 最大允许的restarts的数目</span></div><div class="line">    <span class="keyword">size_t</span> max_restarts_allowed = (size_-<span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>)) / <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</div><div class="line">    <span class="keyword">if</span> (NumRestarts() &gt; max_restarts_allowed) &#123;</div><div class="line">      <span class="comment">// The size is too small for NumRestarts()</span></div><div class="line">      size_ = <span class="number">0</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// 指向restart数组开始的位置</span></div><div class="line">      restart_offset_ = size_ - (<span class="number">1</span> + NumRestarts()) * <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果输入块的大小不足以容纳存放restarts数组大小的数，那么返回空的Error Iterator，若restarts数组数目为0，返回空的Iterator，否则返回内部类Iter中实现的Iterator。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Iterator* Block::NewIterator(<span class="keyword">const</span> Comparator* cmp) &#123;</div><div class="line">  <span class="comment">// 块的大小无法存储restarts数组的数目</span></div><div class="line">  <span class="keyword">if</span> (size_ &lt; <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>)) &#123;</div><div class="line">    <span class="keyword">return</span> NewErrorIterator(Status::Corruption(<span class="string">"bad block contents"</span>));</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// restarts数组的元素数目</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> num_restarts = NumRestarts();</div><div class="line">  <span class="comment">// 返回一个空的iterator</span></div><div class="line">  <span class="keyword">if</span> (num_restarts == <span class="number">0</span>) &#123;</div><div class="line">    <span class="keyword">return</span> NewEmptyIterator();</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 返回iterator</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Iter(cmp, data_, restart_offset_, num_restarts);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Iter"><a href="#Iter" class="headerlink" title="Iter"></a>Iter</h2><p>内部类Iter的成员如下所示：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">const Comparator*<span class="built_in"> const </span>comparator_;</div><div class="line"><span class="built_in"> const </span>char*<span class="built_in"> const </span>data_;      // underlying block contents</div><div class="line"> // 指向restart数组的第一个元素</div><div class="line"> uint32_t<span class="built_in"> const </span>restarts_;     // Offset of restart<span class="built_in"> array </span>(list of fixed32)</div><div class="line"> uint32_t<span class="built_in"> const </span>num_restarts_; // Number of uint32_t entries in restart<span class="built_in"> array</span></div><div class="line"></div><div class="line"> // current_ is offset in data_ of current entry.  &gt;= restarts_<span class="built_in"> if </span>!Valid</div><div class="line"> uint32_t current_;</div><div class="line"> // 当前current_位置对应的restart数组的index</div><div class="line"> uint32_t restart_index_;  // Index of restart block in which current_ falls</div><div class="line"> std::string key_;</div><div class="line"> Slice value_;</div><div class="line"> Status status_;</div></pre></td></tr></table></figure>
<p>在构造函数之中，根据输入参数对类内部成员进行初始化，并且断言restarts数组的数目不为0。current_指向当前遍历到的record的开头位置。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">Iter</span>(const Comparator* comparator,</div><div class="line">      const char* data,</div><div class="line">      uint32_t restarts,</div><div class="line">      uint32_t num_restarts)</div><div class="line">     : <span class="selector-tag">comparator_</span>(comparator), <span class="comment">// 比较器</span></div><div class="line">       <span class="selector-tag">data_</span>(data), <span class="comment">// data</span></div><div class="line">       <span class="selector-tag">restarts_</span>(restarts), <span class="comment">// 指向restart数组的开头位置</span></div><div class="line">       <span class="selector-tag">num_restarts_</span>(num_restarts), <span class="comment">// restart数组的元素个数</span></div><div class="line">       <span class="selector-tag">current_</span>(restarts_), <span class="comment">// current_ is offset in data_ of current entry.</span></div><div class="line">       <span class="selector-tag">restart_index_</span>(num_restarts_) &#123; <span class="comment">// restart index</span></div><div class="line">   <span class="comment">// 断言restarts数组中的元素个数大于0</span></div><div class="line">   <span class="selector-tag">assert</span>(num_restarts_ &gt; <span class="number">0</span>);</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>解析record的时候，调用ParseNextKey，首先判断当前record的位置是否有效，然后获取共享，不共享key的长度，value的长度，设置当前entry对应的key和value，并且设置下一个key对应的restart_index。</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 解析下一个值的实现</span></div><div class="line">  bool ParseNextKey() &#123;</div><div class="line">    <span class="comment">// 下一个entry的offset</span></div><div class="line">    current<span class="number">_</span> = NextEntryOffset();</div><div class="line">    const char* p = data<span class="number">_</span> + current<span class="number">_</span>;</div><div class="line">    <span class="comment">// 不可能越过restarts数组</span></div><div class="line">    const char* limit = data<span class="number">_</span> + restarts<span class="number">_</span>;  <span class="comment">// Restarts come right after data</span></div><div class="line">    <span class="comment">// 没有更多的entry，设置current和restart_index_，并且返回</span></div><div class="line">    <span class="keyword">if</span> (p &gt;= limit) &#123;</div><div class="line">      <span class="comment">// No more entries to return.  Mark as invalid.</span></div><div class="line">      current<span class="number">_</span> = restarts<span class="number">_</span>;</div><div class="line">      restart<span class="number">_</span>index<span class="number">_</span> = num<span class="number">_</span>restarts<span class="number">_</span>;</div><div class="line">      <span class="keyword">return</span> false;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Decode next entry</span></div><div class="line">    uint<span class="number">32_</span>t <span class="keyword">shared</span>, non<span class="number">_</span><span class="keyword">shared</span>, <span class="keyword">value</span><span class="number">_</span>length;</div><div class="line">    <span class="comment">// 现在p指向non_shared key</span></div><div class="line">    p = DecodeEntry(p, limit, &amp;<span class="keyword">shared</span>, &amp;non<span class="number">_</span><span class="keyword">shared</span>, &amp;<span class="keyword">value</span><span class="number">_</span>length);</div><div class="line">    <span class="comment">// 解析失败，或者key的长度小于共享key的长度</span></div><div class="line">    <span class="comment">// 产生了崩溃错误，返回失败</span></div><div class="line">    <span class="keyword">if</span> (p == NULL || key<span class="number">_</span>.size() &lt; <span class="keyword">shared</span>) &#123;</div><div class="line">      CorruptionError();</div><div class="line">      <span class="keyword">return</span> false;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="comment">// 设置key_和value_</span></div><div class="line">      key<span class="number">_</span>.resize(<span class="keyword">shared</span>);</div><div class="line">      key<span class="number">_</span>.append(p, non<span class="number">_</span><span class="keyword">shared</span>);</div><div class="line">      <span class="comment">// 这里的value_存放的是对应的value值</span></div><div class="line">      <span class="keyword">value</span><span class="number">_</span> = Slice(p + non<span class="number">_</span><span class="keyword">shared</span>, <span class="keyword">value</span><span class="number">_</span>length);</div><div class="line">      <span class="comment">// 跳过无效的restart数组元素，下一个restart数组元素指向的offset需要大于当前current_对应的偏移</span></div><div class="line">      <span class="keyword">while</span> (restart<span class="number">_</span>index<span class="number">_</span> + <span class="number">1</span> &lt; num<span class="number">_</span>restarts<span class="number">_</span> &amp;&amp;</div><div class="line">             GetRestartPoint(restart<span class="number">_</span>index<span class="number">_</span> + <span class="number">1</span>) &lt; current<span class="number">_</span>) &#123;</div><div class="line">        ++restart<span class="number">_</span>index<span class="number">_</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> true;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>结合record格式，对于DecodeEntry的实现可以有清晰的认识：</p>
<p><img src="http://static.zybuluo.com/zhoudayang/hyw0u7ftkyxfbbzmnwj5po0p/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-11%20%E4%B8%8B%E5%8D%887.40.37.png" alt="record"></p>
<p>DecodeEntry实际上是解析出共享key，非共享key和value的长度，使得p指向value开头的位置。因为key的长度一般不超过128，而且存储长度使用了varint32格式，所以这里首先尝试fast path。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">DecodeEntry</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* p, <span class="keyword">const</span> <span class="keyword">char</span>* limit,</span></span></div><div class="line">                                      <span class="keyword">uint32_t</span>* shared,</div><div class="line">                                      <span class="keyword">uint32_t</span>* non_shared,</div><div class="line">                                      <span class="keyword">uint32_t</span>* value_length) &#123;</div><div class="line">  <span class="comment">// 不够存放key共享长度，key非共享长度和value长度</span></div><div class="line">  <span class="comment">// 3个varint32数，最少需要的空间是3byte</span></div><div class="line">  <span class="keyword">if</span> (limit - p &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">  <span class="comment">// 取出key共享长度，非共享长度以及value的长度</span></div><div class="line">  <span class="comment">// 这几个长度都是使用varint32进行存放</span></div><div class="line">  *shared = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>*&gt;(p)[<span class="number">0</span>];</div><div class="line">  *non_shared = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>*&gt;(p)[<span class="number">1</span>];</div><div class="line">  *value_length = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>*&gt;(p)[<span class="number">2</span>];</div><div class="line">  <span class="keyword">if</span> ((*shared | *non_shared | *value_length) &lt; <span class="number">128</span>) &#123;</div><div class="line">    <span class="comment">// Fast path: all three values are encoded in one byte each</span></div><div class="line">    p += <span class="number">3</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">if</span> ((p = GetVarint32Ptr(p, limit, shared)) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">if</span> ((p = GetVarint32Ptr(p, limit, non_shared)) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">if</span> ((p = GetVarint32Ptr(p, limit, value_length)) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 若剩余的字符串长度不足以存放non_shared key和value，返回 NULL</span></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(limit - p) &lt; (*non_shared + *value_length)) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 返回指向non_shared key字符串开始位置对应的指针</span></div><div class="line">  <span class="keyword">return</span> p;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相比而言，Prev的实现稍微复杂一点。首先获取上一个entry对应的restarts数组的index值，然后调整到对应的offset，遍历entry，直到entry的右边界和Prev操作之前的entry的offset重合，就找到了上一个entry。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// iterator 往前移动一位</span></div><div class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Prev</span><span class="params">()</span> </span>&#123;</div><div class="line">    assert(Valid());</div><div class="line"></div><div class="line">    <span class="comment">// Scan backwards to a restart point before current_</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">uint32_t</span> original = current_;</div><div class="line">    <span class="comment">// 设置正确的restart_index_</span></div><div class="line">    <span class="comment">// 若越过了，就轮转</span></div><div class="line">    <span class="keyword">while</span> (GetRestartPoint(restart_index_) &gt;= original) &#123;</div><div class="line">      <span class="keyword">if</span> (restart_index_ == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// No more entries</span></div><div class="line">        current_ = restarts_;</div><div class="line">        restart_index_ = num_restarts_;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">      restart_index_--;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 调整到正确的restart_index_对应的位置</span></div><div class="line">    SeekToRestartPoint(restart_index_);</div><div class="line">    <span class="comment">// 循环直到当前entry结束的位置和original entry对应的位置相同</span></div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">      <span class="comment">// Loop until end of current entry hits the start of original entry</span></div><div class="line">    &#125; <span class="keyword">while</span> (ParseNextKey() &amp;&amp; NextEntryOffset() &lt; original);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>Seek操作利用了data block中的record有序的特性，首先利用二分查找找到小于target但是最接近target的restarts数组的偏移位置。在此偏移位置的基础之上，往后遍历直到对应entry的key大于等于target，迭代器就移动到了第一个大于或等于target的位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Seek</span><span class="params">(<span class="keyword">const</span> Slice&amp; target)</span> </span>&#123;</div><div class="line">    <span class="comment">// Binary search in restart array to find the last restart point</span></div><div class="line">    <span class="comment">// with a key &lt; target</span></div><div class="line">    <span class="comment">// 进行二分查找，找到最后的restart point, key &lt; target</span></div><div class="line">    <span class="keyword">uint32_t</span> left = <span class="number">0</span>;</div><div class="line">    <span class="keyword">uint32_t</span> right = num_restarts_ - <span class="number">1</span>;</div><div class="line">    <span class="comment">// loop until left hit right</span></div><div class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</div><div class="line">      <span class="comment">// middle</span></div><div class="line">      <span class="keyword">uint32_t</span> mid = (left + right + <span class="number">1</span>) / <span class="number">2</span>;</div><div class="line">      <span class="keyword">uint32_t</span> region_offset = GetRestartPoint(mid);</div><div class="line">      <span class="keyword">uint32_t</span> shared, non_shared, value_length;</div><div class="line">      <span class="comment">// 解析middle restart的第一个key</span></div><div class="line">      <span class="keyword">const</span> <span class="keyword">char</span>* key_ptr = DecodeEntry(data_ + region_offset,</div><div class="line">                                        data_ + restarts_,</div><div class="line">                                        &amp;shared, &amp;non_shared, &amp;value_length);</div><div class="line">      <span class="comment">// 发生错误，或者第一个key shared的长度不为0</span></div><div class="line">      <span class="keyword">if</span> (key_ptr == <span class="literal">NULL</span> || (shared != <span class="number">0</span>)) &#123;</div><div class="line">        CorruptionError();</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="function">Slice <span class="title">mid_key</span><span class="params">(key_ptr, non_shared)</span></span>;</div><div class="line">      <span class="comment">// 在右半部分</span></div><div class="line">      <span class="keyword">if</span> (Compare(mid_key, target) &lt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// Key at "mid" is smaller than "target".  Therefore all</span></div><div class="line">        <span class="comment">// blocks before "mid" are uninteresting.</span></div><div class="line">        left = mid;</div><div class="line">      &#125;</div><div class="line">        <span class="comment">// 在左半部分</span></div><div class="line">      <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// Key at "mid" is &gt;= "target".  Therefore all blocks at or</span></div><div class="line">        <span class="comment">// after "mid" are uninteresting.</span></div><div class="line">        right = mid - <span class="number">1</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Linear search (within restart block) for first key &gt;= target</span></div><div class="line">    SeekToRestartPoint(left);</div><div class="line">    <span class="comment">// 找到第一个 &gt;= target的key</span></div><div class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (!ParseNextKey()) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (Compare(key_, target) &gt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>相比而言SeekToFirst和SeekToLast的实现比较简单，如代码所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 指向第一个restarts数组元素对应的offset，然后解析获取值</span></div><div class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SeekToFirst</span><span class="params">()</span> </span>&#123;</div><div class="line">  SeekToRestartPoint(<span class="number">0</span>);</div><div class="line">  ParseNextKey();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 指向最后一个restarts数组元素对应的offset，然后解析所有剩余的key</span></div><div class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SeekToLast</span><span class="params">()</span> </span>&#123;</div><div class="line">  SeekToRestartPoint(num_restarts_ - <span class="number">1</span>);</div><div class="line">  <span class="keyword">while</span> (ParseNextKey() &amp;&amp; NextEntryOffset() &lt; restarts_) &#123;</div><div class="line">    <span class="comment">// Keep skipping</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++运行时类型识别]]></title>
      <url>/2017/06/11/C-%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%9E%8B%E8%AF%86%E5%88%AB/</url>
      <content type="html"><![CDATA[<h1 id="C-运行时类型识别"><a href="#C-运行时类型识别" class="headerlink" title="C++ 运行时类型识别"></a>C++ 运行时类型识别</h1><p>C++中运行时类型识别(run-time type identification, <strong>RTTI</strong>)的功能由两个运算符实现。</p>
<ol>
<li>typeid运算符，用于返回表达式的类型。</li>
<li>dynamic_cast运算符，用于将基类的指针或引用安全地转换成派生类的指针或者引用。</li>
</ol>
<p>这两个运算符特别适用于以下情况：我们想使用基类对象的指针或引用执行某个派生类操作并且该操作不是虚函数。一般来说，只要有可能我们应该尽量使用虚函数。当操作被定义成为虚函数时，编译器将根据对象的动态类型根据对象的动态类型自动选择正确的函数版本。</p>
<h2 id="dynamic-cast运算符"><a href="#dynamic-cast运算符" class="headerlink" title="dynamic_cast运算符"></a>dynamic_cast运算符</h2><p>dynamic_cast运算符的使用形式如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">dynamic_cast</span>&lt;type*&gt;(e);</div><div class="line"><span class="keyword">dynamic_cast</span>&lt;type&amp;&gt;(e);</div><div class="line"><span class="keyword">dynamic_cast</span>&lt;type&amp;&amp;&gt;(e);</div></pre></td></tr></table></figure>
<p>type必须是一个类类型，并且通常情况下该类型应该含有虚函数。</p>
<p>在上面的所有形式之中，e的类型必须符合下面3个条件之中的任意一个：</p>
<ol>
<li>e的类型是目标type的公有派生类</li>
<li>e的类型是目标type的公有基类</li>
<li>e的类型就是目标type的类型。</li>
</ol>
<p>如果符合，则类型转换就可以成功。否则，转换失败。如果一条dynamica_cast语句的转换目标是指针类型并且失败了，则结果为0。如果转换目标是引用类型并且失败了，则dynamic_cast运算符将抛出一个bad_cast的异常。</p>
<p>使用举例：</p>
<ul>
<li>指针类型的dynamic_cast</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (Derived* dp = <span class="keyword">dynamic_cast</span>&lt;Derived*&gt;(bp))</div><div class="line">&#123;</div><div class="line">	<span class="comment">// 使用dp指向的Derived对象	</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span></div><div class="line">&#123;</div><div class="line">	<span class="comment">// 转换失败，使用bp指向的Base对象</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>引用类型的dynamic_cast</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> Base&amp; b)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">try</span></div><div class="line">	&#123;</div><div class="line">		<span class="keyword">const</span> Derived&amp; d = <span class="keyword">dynamic_cast</span>&lt;<span class="keyword">const</span> Derived&amp;&gt;(b);</div><div class="line">		<span class="comment">// 使用b引用的Derived对象</span></div><div class="line">	&#125; <span class="keyword">catch</span>(bad_cast)</div><div class="line">	&#123;</div><div class="line">		<span class="comment">// 处理类型转换失败的情况</span></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="typeid运算符"><a href="#typeid运算符" class="headerlink" title="typeid运算符"></a>typeid运算符</h2><p>为RTTI提供的第二个运算符是typeid运算符，它允许程序向表达式提问，你是什么类型？</p>
<p>typeid表达式的形式是<code>typeid(e)</code>，其中e可以是任意表达式或者类型的名字。typeid操作的结果是一个常量对象的引用，该对象的类型是标准库类型type_info或者type_info的公有派生类型。</p>
<p>可以通过下述方式比较两条表达式的类型是否相同，或者比较一条表达式的类型是否与指定类型相同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Derived* dp = <span class="keyword">new</span> Derived;</div><div class="line">Base* bp = dp;</div><div class="line"><span class="keyword">if</span>(<span class="keyword">typeid</span>(*bp) == <span class="keyword">typeid</span>(*dp))</div><div class="line">&#123;</div><div class="line">	<span class="comment">// bp和dp指向同一类型的对象</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 检查运行时类型是否是某种指定的类型</span></div><div class="line"><span class="comment">// 请注意，typeid应该作用于对象而不是指针。</span></div><div class="line"><span class="keyword">if</span>(<span class="keyword">typeid</span>(*bp) == <span class="keyword">typeid</span>(Derived))</div><div class="line">&#123;	</div><div class="line">	<span class="comment">// bp 实际指向Derived对象</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="type-info类"><a href="#type-info类" class="headerlink" title="type_info类"></a>type_info类</h2><p>type_info类的精确定义和编译器的实现有关。C++标准规定type_info类必须定义在typeinfo头文件中，并且至少提供以下操作：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>t1 == t2</td>
<td>若type_info对象t1和t2表示同一类型，返回true，否则返回false</td>
</tr>
<tr>
<td>t1 != t2</td>
<td>如果type_info对象t1和t2表示不同的类型，返回true，否则返回false</td>
</tr>
<tr>
<td>t.name()</td>
<td>返回一个C风格字符串，表示类型名字的可打印形式。类型名字的生成方式因系统而定</td>
</tr>
<tr>
<td>t1.before(t2)</td>
<td>返回一个bool值，表示t1是否位于t2之前。before所采用的顺序关系是依赖于编译器的</td>
</tr>
</tbody>
</table>
<p>示例程序：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> arr[<span class="number">10</span>];</div><div class="line">  <span class="built_in">string</span> str;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(<span class="number">42</span>).name() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(arr).name() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(str).name() &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出(macos, clang)：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">i</div><div class="line">A<span class="number">10</span>_i</div><div class="line"><span class="symbol">NSt3</span>__<span class="number">112</span>basic_stri<span class="symbol">ngIcNS_11</span>char_traitsIcEE<span class="symbol">NS_9</span>allocatorIcEEEE</div><div class="line"><span class="number">4</span>test</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++内存模型]]></title>
      <url>/2017/06/11/C-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<h2 id="C-std-atomic-原子类型"><a href="#C-std-atomic-原子类型" class="headerlink" title="C++ std::atomic 原子类型"></a>C++ <code>std::atomic</code> 原子类型</h2><p>原子操作：一个不可分割的操作。<br>标准原子类型可以在<atomic>头文件之中找到，在这种类型上的所有操作都是原子的。它们都有一个<code>is_lock_free()</code>的成员函数，让用户决定在给定类型上的操作是否用原子指令完成。唯一不提供<code>is_lock_free()</code>成员函数的类型是<code>std::atomic_flag</code>,在此类型上的操作要求是无锁的。可以利用<code>std::atomic_flag</code>实现一个简单的锁。</atomic></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">spinlock_mutex</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    spinlock_mutex() : flag_(ATOMIC_FLAG_INIT) &#123; &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">      <span class="keyword">while</span>(flag_.test_and_set(<span class="built_in">std</span>::memory_order_acquire)) ;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span></div><div class="line">    &#123;</div><div class="line">      flag_.clear(<span class="built_in">std</span>::memory_order_release);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="built_in">std</span>::atomic_flag flag_;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">int</span> value = <span class="number">0</span>;</div><div class="line">spinlock_mutex mutex;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_function</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</div><div class="line">  &#123;</div><div class="line">    <span class="built_in">std</span>::unique_lock&lt;spinlock_mutex&gt; lock(mutex);</div><div class="line">    ++ value;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(test_function)</span></span>;</div><div class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(test_function)</span></span>;</div><div class="line">  t1.join();</div><div class="line">  t2.join();</div><div class="line"></div><div class="line">  assert(value == <span class="number">200000</span>);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>C++ 11中的内存模型都是围绕<code>std::atomic</code>展开的，下面依次介绍C++ 11中引入的内存顺序。<br><a href="https://stackoverflow.com/questions/6319146/c11-introduced-a-standardized-memory-model-what-does-it-mean-and-how-is-it-g#" target="_blank" rel="external">参考: Memory Model</a></p>
<h2 id="顺序一致顺序"><a href="#顺序一致顺序" class="headerlink" title="顺序一致顺序"></a>顺序一致顺序</h2><p>默认的的顺序被命名为顺序一致，因为这意味着程序的行为和一个简单的世界观是一致的。如果所有原子类型实例上的操作是顺序一致的，多线程的行为就好像是所有这些操作由单个线程以某种特定的顺序进行执行的一样。<br>在一个带有多处理器的弱顺序的机器上，它可能导致显著的性能惩罚，因为操作的整体顺序必须与处理器之间保持一致，可能需要处理器之间进行密集的同步操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; x, y;</div><div class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; z;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  x.store(<span class="literal">true</span>, <span class="built_in">std</span>::memory_order_seq_cst);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_y</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  y.store(<span class="literal">true</span>, <span class="built_in">std</span>::memory_order_seq_cst);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_x_then_y</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">while</span>(!x.load(<span class="built_in">std</span>::memory_order_seq_cst)) ;</div><div class="line">  <span class="keyword">if</span>(y.load(<span class="built_in">std</span>::memory_order_seq_cst))</div><div class="line">  &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"x,y\n"</span>);</div><div class="line">    ++ z;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_y_then_x</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">while</span>(!y.load(<span class="built_in">std</span>::memory_order_seq_cst)) ;</div><div class="line">  <span class="keyword">if</span>(x.load(<span class="built_in">std</span>::memory_order_seq_cst))</div><div class="line">  &#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"y,x\n"</span>);</div><div class="line">    ++ z;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  x = <span class="literal">false</span>;</div><div class="line">  y = <span class="literal">false</span>;</div><div class="line">  z = <span class="number">0</span>;</div><div class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">a</span><span class="params">(write_x)</span></span>;</div><div class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">b</span><span class="params">(write_y)</span></span>;</div><div class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">c</span><span class="params">(read_x_then_y)</span></span>;</div><div class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">d</span><span class="params">(read_y_then_x)</span></span>;</div><div class="line"></div><div class="line">  a.join();</div><div class="line">  b.join();</div><div class="line">  c.join();</div><div class="line">  d.join();</div><div class="line"></div><div class="line">  assert(z.load() != <span class="number">0</span>);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码中的assert永远不会触发，因为while循环总能保证x或者y的值已经修改为true，如果线程c或d中有一个线程if条件不满足，那么另一个线程的if条件总能保障，所以最后z的值一定不为0。请注意<code>memory_order_seq_cst</code>的语义需要在所有标记<code>memory_order_seq_cst</code>的操作上有单一的总体顺序。</p>
<p>顺序一致是最直观的顺序，但是也是最为昂贵的内存顺序，因为它要求所有线程之间的全局同步。在多处理器系统中，这可能需要处理器之间相当密集和耗时的通信。</p>
<h2 id="松散顺序"><a href="#松散顺序" class="headerlink" title="松散顺序"></a>松散顺序</h2><p>以松散顺序执行的原子类型上的操作不参与<code>synchronizes-with</code>关系。单线程中的同一变量的操作仍然服从<code>happens-before</code>的关系，但相对于其他线程的顺序几乎没有任何要求。唯一的要求是，从同一线程对单个原子变量的访问不能重排，一旦给定的线程已经看到了原子变量的特定值，该线程之后的读取就不能获取该变量更早的值。以下程序展现了这种松散性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; x, y;</div><div class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; z;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x_then_y</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  x.store(<span class="literal">true</span>, <span class="built_in">std</span>::memory_order_relaxed);</div><div class="line">  y.store(<span class="literal">true</span>, <span class="built_in">std</span>::memory_order_relaxed);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_x_then_y</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">while</span>(!y.load(<span class="built_in">std</span>::memory_order_relaxed)) ;</div><div class="line">  <span class="keyword">if</span>(x.load(<span class="built_in">std</span>::memory_order_relaxed))</div><div class="line">    ++ z;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  x = <span class="literal">false</span>;</div><div class="line">  y = <span class="literal">false</span>;</div><div class="line">  z = <span class="number">0</span>;</div><div class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">a</span><span class="params">(write_x_then_y)</span></span>;</div><div class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">b</span><span class="params">(read_x_then_y)</span></span>;</div><div class="line"></div><div class="line">  a.join();</div><div class="line">  b.join();</div><div class="line">  assert(z.load() != <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这一次，assert可能会触发。因为x和y是不同的变量，每个操作所产生的值的可见性没有顺序的保证。</p>
<p>为了理解松散顺序是如何工作的，可以想象每个变量是一个小隔间里使用记事本的人。在他的记事本上有一列值。你可以打电话给他，要求他给你一个值，或者你可以告诉他写下了一个新值。如果你告诉他写下新值，他就将其写在列表的底部。如果你向他要一个值，他就为你从列表之中读取一个数字。第一次你和这个人交谈，如果你向他要一个值，此时他可能从他的记事本上的列表里<strong>任意</strong>选一个给你。如果你接着向他要另一个值，他可能会再给你同一个值，或者从列表的下方给一个给你。<strong>他永远不会给你一个在列表上更上面的值</strong>。</p>
<h2 id="获取释放顺序"><a href="#获取释放顺序" class="headerlink" title="获取释放顺序"></a>获取释放顺序</h2><p>获取释放顺序是松散顺序的进步，操作仍然没有总的顺序，但是引入了一些同步。在这个顺序模型下，原子载入是acquire操作<code>memory_order_acquire</code>，原子存储是release操作<code>memory_order_release</code>，原子的读，修改，写操作是获取，释放或者两者兼有<code>memory_order_acq_rel</code>。不同的线程仍然可以看到不同的顺序，但是这些顺序受到了限制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; x, y;</div><div class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; z;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  x.store(<span class="literal">true</span>, <span class="built_in">std</span>::memory_order_release);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_y</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  y.store(<span class="literal">true</span>, <span class="built_in">std</span>::memory_order_release);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_x_then_y</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">while</span>(!x.load(<span class="built_in">std</span>::memory_order_acquire)) ;</div><div class="line">  <span class="keyword">if</span>(y.load(<span class="built_in">std</span>::memory_order_acquire))</div><div class="line">  &#123;</div><div class="line">    ++ z;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_y_then_x</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">while</span>(!y.load(<span class="built_in">std</span>::memory_order_seq_cst)) ;</div><div class="line">  <span class="keyword">if</span>(x.load(<span class="built_in">std</span>::memory_order_seq_cst))</div><div class="line">  &#123;</div><div class="line">    ++ z;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  x = <span class="literal">false</span>;</div><div class="line">  y = <span class="literal">false</span>;</div><div class="line">  z = <span class="number">0</span>;</div><div class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">a</span><span class="params">(write_x)</span></span>;</div><div class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">b</span><span class="params">(write_y)</span></span>;</div><div class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">c</span><span class="params">(read_x_then_y)</span></span>;</div><div class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">d</span><span class="params">(read_y_then_x)</span></span>;</div><div class="line"></div><div class="line">  a.join();</div><div class="line">  b.join();</div><div class="line">  c.join();</div><div class="line">  d.join();</div><div class="line"></div><div class="line">  assert(z.load() != <span class="number">0</span>);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码中的断言仍然可能触发，因为对x的载入和对y的载入都读取false也是有可能的。x与y由不同的线程写入，所以每种情况从释放到获取的顺序对另一个线程的操作是没有影响的。</p>
<p>但是对于同一个线程来说，使用获取-释放操作可以在松散操作之中施加顺序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; x, y;</div><div class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; z;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x_then_y</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  x.store(<span class="literal">true</span>, <span class="built_in">std</span>::memory_order_relaxed);</div><div class="line">  y.store(<span class="literal">true</span>, <span class="built_in">std</span>::memory_order_release);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_y_then_x</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">while</span>(!y.load(<span class="built_in">std</span>::memory_order_acquire));</div><div class="line">  <span class="keyword">if</span>(x.load(<span class="built_in">std</span>::memory_order_relaxed))</div><div class="line">    ++ z;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  x = <span class="literal">false</span>;</div><div class="line">  y = <span class="literal">false</span>;</div><div class="line">  z = <span class="number">0</span>;</div><div class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">a</span><span class="params">(write_x_then_y)</span></span>;</div><div class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">b</span><span class="params">(read_y_then_x)</span></span>;</div><div class="line">  a.join();</div><div class="line">  b.join();</div><div class="line"></div><div class="line">  assert(z.load() != <span class="number">0</span>);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>因为存储使用<code>memory_order_release</code>并且载入使用<code>memory_order_acquire</code>，存储与载入同步。对x的存储发生在y的存储之前，因为它们在同一个线程之中。因为对y的存储与对y的载入同步，对x的载入必然读到true，所以断言并不会触发。配合使用release和acquire可以达到跨线程同步的功能，如下代码所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></div><div class="line"></div><div class="line"></div><div class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; data[<span class="number">5</span>];</div><div class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; sync1(<span class="literal">false</span>), sync2(<span class="literal">false</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_1</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  data[<span class="number">0</span>].store(<span class="number">42</span>, <span class="built_in">std</span>::memory_order_relaxed);</div><div class="line">  data[<span class="number">1</span>].store(<span class="number">97</span>, <span class="built_in">std</span>::memory_order_relaxed);</div><div class="line">  data[<span class="number">2</span>].store(<span class="number">17</span>, <span class="built_in">std</span>::memory_order_relaxed);</div><div class="line">  data[<span class="number">3</span>].store(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_relaxed);</div><div class="line">  data[<span class="number">4</span>].store(<span class="number">2</span>, <span class="built_in">std</span>::memory_order_relaxed);</div><div class="line">  sync1.store(<span class="literal">true</span>, <span class="built_in">std</span>::memory_order_release);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_2</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">while</span>(!sync1.load(<span class="built_in">std</span>::memory_order_acquire)) ;</div><div class="line">  sync2.store(<span class="literal">true</span>, <span class="built_in">std</span>::memory_order_release);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_3</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">while</span>(!sync2.load(<span class="built_in">std</span>::memory_order_acquire));</div><div class="line">  assert(data[<span class="number">0</span>].load(<span class="built_in">std</span>::memory_order_relaxed) == <span class="number">42</span>);</div><div class="line">  assert(data[<span class="number">1</span>].load(<span class="built_in">std</span>::memory_order_relaxed) == <span class="number">97</span>);</div><div class="line">  assert(data[<span class="number">2</span>].load(<span class="built_in">std</span>::memory_order_relaxed) == <span class="number">17</span>);</div><div class="line">  assert(data[<span class="number">3</span>].load(<span class="built_in">std</span>::memory_order_relaxed) == <span class="number">1</span>);</div><div class="line">  assert(data[<span class="number">4</span>].load(<span class="built_in">std</span>::memory_order_relaxed) == <span class="number">2</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">a</span><span class="params">(thread_1)</span></span>;</div><div class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">b</span><span class="params">(thread_2)</span></span>;</div><div class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">c</span><span class="params">(thread_3)</span></span>;</div><div class="line"></div><div class="line">  a.join();</div><div class="line">  b.join();</div><div class="line">  c.join();</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="获取释放顺序与MEMORY-ORDER-CONSUME的数据依赖"><a href="#获取释放顺序与MEMORY-ORDER-CONSUME的数据依赖" class="headerlink" title="获取释放顺序与MEMORY_ORDER_CONSUME的数据依赖"></a>获取释放顺序与MEMORY_ORDER_CONSUME的数据依赖</h2><p>通过在载入上使用<code>memory_order_consume</code>以及在之前的存储上使用<code>memory_order_release</code>，你可以确保所指向的数据得到正确的同步，并且<strong>无需再其他非依赖的数据上强制任何同步需求</strong>。以下代码展示了这种用途:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> i;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> s;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">std</span>::atomic&lt;X*&gt; p;</div><div class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; a;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_x</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  X* x = <span class="keyword">new</span> X;</div><div class="line">  x-&gt;i = <span class="number">42</span>;</div><div class="line">  x-&gt;s = <span class="string">"hello world"</span>;</div><div class="line">  a.store(<span class="number">99</span>, <span class="built_in">std</span>::memory_order_relaxed);</div><div class="line">  <span class="comment">// 因为这里依赖了x，所以这一句代码执行时保证了x已经初始化完毕，并且已经完成赋值。</span></div><div class="line">  <span class="comment">// 要点，有依赖关系的都已赋值完毕</span></div><div class="line">  p.store(x, <span class="built_in">std</span>::memory_order_release);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">use_x</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  X * x;</div><div class="line">  <span class="keyword">while</span>(!(x=p.load(<span class="built_in">std</span>::memory_order_consume)))</div><div class="line">    sleep(<span class="number">1</span>);</div><div class="line">  assert(x-&gt;i == <span class="number">42</span>);</div><div class="line">  assert(x-&gt;s == <span class="string">"hello world"</span>);</div><div class="line">  <span class="comment">// 可能断言出错</span></div><div class="line">  assert(a.load(<span class="built_in">std</span>::memory_order_relaxed) == <span class="number">99</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(create_x)</span></span>;</div><div class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(use_x)</span></span>;</div><div class="line">  t1.join();</div><div class="line">  t2.join();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码中的前两个断言不会出错，因为p的载入带有对那些通过变量x的表达式的依赖。另一方面，在a的值上的断言或许会被触发。此操作并不依赖从p载入的值，因而对读到的值就没有保证。</p>
<h2 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h2><p>内存屏障分为写内存屏障和读内存屏障。写内存屏障保证所有在屏障之前的写入操作都会在屏障之后的写入操作之前完成，而读内存屏障确保所有屏障之前的读取操作都会在屏障之后的读取操作前执行。内存屏障使得特定的操作无法穿越。以下代码演示了内存屏障的用法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt; x, y;</div><div class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; z;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x_then_y</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  x.store(<span class="literal">true</span>, <span class="built_in">std</span>::memory_order_relaxed);</div><div class="line">  <span class="comment">// 写内存屏障</span></div><div class="line">  <span class="built_in">std</span>::atomic_thread_fence(<span class="built_in">std</span>::memory_order_release);</div><div class="line">  y.store(<span class="literal">true</span>, <span class="built_in">std</span>::memory_order_release);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_y_then_x</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">while</span>(!y.load(<span class="built_in">std</span>::memory_order_acquire));</div><div class="line">  <span class="comment">// 读内存屏障</span></div><div class="line">  <span class="built_in">std</span>::atomic_thread_fence(<span class="built_in">std</span>::memory_order_acquire);</div><div class="line">  <span class="keyword">if</span>(x.load(<span class="built_in">std</span>::memory_order_relaxed))</div><div class="line">    ++ z;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  x = <span class="literal">false</span>;</div><div class="line">  y = <span class="literal">false</span>;</div><div class="line">  z = <span class="number">0</span>;</div><div class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">a</span><span class="params">(write_x_then_y)</span></span>;</div><div class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">b</span><span class="params">(read_y_then_x)</span></span>;</div><div class="line">  a.join();</div><div class="line">  b.join();</div><div class="line"></div><div class="line">  assert(z.load() != <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>释放屏障与获取屏障同步，因为线程b中从y载入在线程a中存储的值，这意味着线程a对x的存储发生在线程b从x的load之前，所以读取的值一定为true，断言永远不会触发。</p>
<blockquote>
<p>参考: 《 C++并发编程实战 》</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[muduo EPollPoller]]></title>
      <url>/2017/06/11/muduo-EPollPoller/</url>
      <content type="html"><![CDATA[<h2 id="默认使用什么io复用模型？"><a href="#默认使用什么io复用模型？" class="headerlink" title="默认使用什么io复用模型？"></a>默认使用什么io复用模型？</h2><p>在Poller的接口类中定义了一个static函数，如下所示：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> Poller* <span class="keyword">new</span><span class="type">DefaultPoller</span>(EventLoop* loop);</div></pre></td></tr></table></figure>
<p>其实现是在DefaultPoller.cc文件之中，如下所示：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Poller* Poller<span class="type">::newDefaultPoller</span>(EventLoop* <span class="keyword">loop</span>)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="type">::getenv</span>(<span class="string">"MUDUO_USE_POLL"</span>))</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">new</span> PollPoller(<span class="keyword">loop</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">  &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">new</span> EPollPoller(<span class="keyword">loop</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可见除非定义了<code>MUDUO_USE_POLL</code>环境变量，否则muduo会使用epoll作为io复用的方式。</p>
<h2 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h2><p>因为epoll返回的io事件对应的结构体 epoll_event中，有一个data成员可以记录相关信息，可以方便我们找到对应的Channel，因而epoll的实现较poll比较更为简单。</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span></span></div><div class="line">&#123;</div><div class="line">  void* ptr;</div><div class="line">  int fd;</div><div class="line">  uint32_t u32;</div><div class="line">  uint64_t u64;</div><div class="line">&#125;epoll_data_t;</div></pre></td></tr></table></figure>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Timestamp EPollPoller::poll(<span class="keyword">int</span> timeoutMs, ChannelList* activeChannels)</div><div class="line">&#123;</div><div class="line">  LOG_TRACE &lt;&lt; <span class="string">"fd total count "</span> &lt;&lt; channels_.<span class="built_in">size</span>();</div><div class="line">  <span class="keyword">int</span> numEvents = ::epoll_wait(epollfd_,</div><div class="line">                               &amp;*events_.<span class="built_in">begin</span>(),</div><div class="line">                               <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(events_.<span class="built_in">size</span>()),</div><div class="line">                               timeoutMs);</div><div class="line">  <span class="keyword">int</span> savedErrno = errno;</div><div class="line">  Timestamp now(Timestamp::now());</div><div class="line">  <span class="built_in">if</span> (numEvents &gt; <span class="number">0</span>)</div><div class="line">  &#123;</div><div class="line">    LOG_TRACE &lt;&lt; numEvents &lt;&lt; <span class="string">" events happended"</span>;</div><div class="line">    fillActiveChannels(numEvents, activeChannels);</div><div class="line">    <span class="built_in">if</span> (implicit_cast&lt;size_t&gt;(numEvents) == events_.<span class="built_in">size</span>())</div><div class="line">    &#123;</div><div class="line">      events_.resize(events_.<span class="built_in">size</span>()*<span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">else</span> <span class="built_in">if</span> (numEvents == <span class="number">0</span>)</div><div class="line">  &#123;</div><div class="line">    LOG_TRACE &lt;&lt; <span class="string">"nothing happended"</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">else</span></div><div class="line">  &#123;</div><div class="line">    <span class="comment">// error happens, log uncommon ones</span></div><div class="line">    <span class="built_in">if</span> (savedErrno != EINTR)</div><div class="line">    &#123;</div><div class="line">      errno = savedErrno;</div><div class="line">      LOG_SYSERR &lt;&lt; <span class="string">"EPollPoller::poll()"</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">return</span> now;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>拿到epoll返回的事件列表之后，就可以调用fillActiveChannels来将当前active的Channel填充进入EventLoop之中的activeChannels之中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> EPollPoller::fillActiveChannels(<span class="keyword">int</span> numEvents,</div><div class="line">                                     ChannelList* activeChannels) <span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">  assert(implicit_cast&lt;<span class="keyword">size_t</span>&gt;(numEvents) &lt;= events_.size());</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numEvents; ++i)</div><div class="line">  &#123;</div><div class="line">    Channel* channel = <span class="keyword">static_cast</span>&lt;Channel*&gt;(events_[i].data.ptr);</div><div class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></div><div class="line">    <span class="keyword">int</span> fd = channel-&gt;fd();</div><div class="line">    ChannelMap::const_iterator it = channels_.find(fd);</div><div class="line">    assert(it != channels_.end());</div><div class="line">    assert(it-&gt;second == channel);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    <span class="comment">// set revents</span></div><div class="line">    channel-&gt;set_revents(events_[i].events);</div><div class="line">    activeChannels-&gt;push_back(channel);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="update-Channel"><a href="#update-Channel" class="headerlink" title="update Channel"></a>update Channel</h2><p>在Poller中使用<code>std::map&lt;int, Channel*&gt;</code> 来存放fd和对应channel之间的对应关系。需要保证channel和fd的一一对应，不能存在一个fd由两个不同的channel来管理。</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">void EPollPoller::updateChannel(Channel* channel)</div><div class="line">&#123;</div><div class="line">  Poller::assertInLoopThread();</div><div class="line">  const int index = channel-&gt;index();</div><div class="line">  LOG_TRACE &lt;&lt; <span class="string">"fd = "</span> &lt;&lt; channel-&gt;fd()</div><div class="line">    &lt;&lt; <span class="string">" events = "</span> &lt;&lt; channel-&gt;events() &lt;&lt; <span class="string">" index = "</span> &lt;&lt; index;</div><div class="line">  <span class="keyword">if</span> (index == kNew |<span class="type">| index</span> == kDeleted)</div><div class="line">  &#123;</div><div class="line">    // a new one, add <span class="built_in">with</span> EPOLL_CTL_ADD</div><div class="line">    int fd = channel-&gt;fd();</div><div class="line">    <span class="keyword">if</span> (index == kNew)</div><div class="line">    &#123;</div><div class="line">      <span class="built_in">assert</span>(channels_.find(fd) == channels_.<span class="keyword">end</span>());</div><div class="line">      channels_[fd] = channel;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> // index == kDeleted</div><div class="line">    &#123;</div><div class="line">      <span class="built_in">assert</span>(channels_.find(fd) != channels_.<span class="keyword">end</span>());</div><div class="line">      <span class="built_in">assert</span>(channels_[fd] == channel);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    channel-&gt;set_index(kAdded);</div><div class="line">    update(EPOLL_CTL_ADD, channel);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">  &#123;</div><div class="line">    // update existing one <span class="built_in">with</span> EPOLL_CTL_MOD/DEL</div><div class="line">    int fd = channel-&gt;fd();</div><div class="line">    (void)fd;</div><div class="line">    <span class="built_in">assert</span>(channels_.find(fd) != channels_.<span class="keyword">end</span>());</div><div class="line">    <span class="built_in">assert</span>(channels_[fd] == channel);</div><div class="line">    <span class="built_in">assert</span>(index == kAdded);</div><div class="line">    <span class="keyword">if</span> (channel-&gt;isNoneEvent())</div><div class="line">    &#123;</div><div class="line">      update(EPOLL_CTL_DEL, channel);</div><div class="line">      channel-&gt;set_index(kDeleted);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">      update(EPOLL_CTL_MOD, channel);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Channel默认的index被设为-1，在epoll之中，index被用作标明类别，有以下3种类型，故而新创建的Channel其index代表新增的Channel。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span></div><div class="line">&#123;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> kNew = <span class="number">-1</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> kAdded = <span class="number">1</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> kDeleted = <span class="number">2</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>updateChannel会根据Channel的revent来调用update方法。注意到对于没有关注任何io事件的Channel，EPollPoller采取的方式是将该channel对应的fd直接从epoll之中删除。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> EPollPoller::update(<span class="keyword">int</span> operation, Channel* channel)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">struct</span> epoll_event <span class="keyword">event</span>;</div><div class="line">  bzero(&amp;<span class="keyword">event</span>, sizeof <span class="keyword">event</span>);</div><div class="line">  <span class="keyword">event</span><span class="variable">.events</span> = channel-&gt;events();</div><div class="line">  <span class="keyword">event</span><span class="variable">.data</span><span class="variable">.ptr</span> = channel;</div><div class="line">  <span class="keyword">int</span> fd = channel-&gt;fd();</div><div class="line">  LOG_TRACE &lt;&lt; <span class="string">"epoll_ctl op = "</span> &lt;&lt; operationToString(operation)</div><div class="line">    &lt;&lt; <span class="string">" fd = "</span> &lt;&lt; fd &lt;&lt; <span class="string">" event = &#123; "</span> &lt;&lt; channel-&gt;eventsToString() &lt;&lt; <span class="string">" &#125;"</span>;</div><div class="line">  <span class="keyword">if</span> (::epoll_ctl(epollfd_, operation, fd, &amp;<span class="keyword">event</span>) &lt; <span class="number">0</span>)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">if</span> (operation == EPOLL_CTL_DEL)</div><div class="line">    &#123;</div><div class="line">      LOG_SYSERR &lt;&lt; <span class="string">"epoll_ctl op ="</span> &lt;&lt; operationToString(operation) &lt;&lt; <span class="string">" fd ="</span> &lt;&lt; fd;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">      LOG_SYSFATAL &lt;&lt; <span class="string">"epoll_ctl op ="</span> &lt;&lt; operationToString(operation) &lt;&lt; <span class="string">" fd ="</span> &lt;&lt; fd;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在update中，对于delete操作进行了区分处理，它容忍delete出错，但是对于modify和add出错，程序会fatal。</p>
<h2 id="removeChannel"><a href="#removeChannel" class="headerlink" title="removeChannel"></a>removeChannel</h2><p>removeChannel将Channel对应的fd从epoll中删除，并且Channel也从channels_之中删除了。<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">void EPollPoller::removeChannel(Channel* channel)</div><div class="line">&#123;</div><div class="line"><span class="symbol">  Poller:</span>:assertInLoopThread()<span class="comment">;</span></div><div class="line">  int fd = channel-&gt;fd()<span class="comment">;</span></div><div class="line">  LOG_TRACE &lt;&lt; <span class="string">"fd = "</span> &lt;&lt; fd<span class="comment">;</span></div><div class="line">  assert(channels_.find(fd) != channels_<span class="meta">.end</span>())<span class="comment">;</span></div><div class="line">  assert(channels_[fd] == channel)<span class="comment">;</span></div><div class="line">  assert(channel-&gt;isNoneEvent())<span class="comment">;</span></div><div class="line">  int index = channel-&gt;index()<span class="comment">;</span></div><div class="line">  assert(index == kAdded <span class="title">||</span> index == kDeleted)<span class="comment">;</span></div><div class="line">  size_t n = channels_.erase(fd)<span class="comment">;</span></div><div class="line">  (void)n<span class="comment">;</span></div><div class="line">  assert(n == <span class="number">1</span>)<span class="comment">;</span></div><div class="line"></div><div class="line">  if (index == kAdded)</div><div class="line">  &#123;</div><div class="line">    update(EPOLL_CTL_DEL, channel)<span class="comment">;</span></div><div class="line">  &#125;</div><div class="line">  channel-&gt;set_index(kNew)<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> muduo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
            <tag> muduo </tag>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[muduo Connector]]></title>
      <url>/2017/06/11/muduo-Connector/</url>
      <content type="html"><![CDATA[<h2 id="怎么判断连接成功了？"><a href="#怎么判断连接成功了？" class="headerlink" title="怎么判断连接成功了？"></a>怎么判断连接成功了？</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> <span class="string">Connector:</span>:connect()</div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> sockfd = <span class="string">sockets:</span>:createNonblockingOrDie(serverAddr_.family());</div><div class="line">  <span class="keyword">int</span> ret = <span class="string">sockets:</span>:connect(sockfd, serverAddr_.getSockAddr());</div><div class="line">  <span class="keyword">int</span> savedErrno = (ret == <span class="number">0</span>) ? 0 : errno;</div><div class="line">  <span class="keyword">switch</span> (savedErrno)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">    <span class="keyword">case</span> <span class="string">EINPROGRESS:</span></div><div class="line">    <span class="keyword">case</span> <span class="string">EINTR:</span></div><div class="line">    <span class="keyword">case</span> <span class="string">EISCONN:</span></div><div class="line">      connecting(sockfd);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> <span class="string">EAGAIN:</span></div><div class="line">    <span class="keyword">case</span> <span class="string">EADDRINUSE:</span></div><div class="line">    <span class="keyword">case</span> <span class="string">EADDRNOTAVAIL:</span></div><div class="line">    <span class="keyword">case</span> <span class="string">ECONNREFUSED:</span></div><div class="line">    <span class="keyword">case</span> <span class="string">ENETUNREACH:</span></div><div class="line">      retry(sockfd);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line"></div><div class="line">    <span class="keyword">case</span> <span class="string">EACCES:</span></div><div class="line">    <span class="keyword">case</span> <span class="string">EPERM:</span></div><div class="line">    <span class="keyword">case</span> <span class="string">EAFNOSUPPORT:</span></div><div class="line">    <span class="keyword">case</span> <span class="string">EALREADY:</span></div><div class="line">    <span class="keyword">case</span> <span class="string">EBADF:</span></div><div class="line">    <span class="keyword">case</span> <span class="string">EFAULT:</span></div><div class="line">    <span class="keyword">case</span> <span class="string">ENOTSOCK:</span></div><div class="line">      LOG_SYSERR &lt;&lt; <span class="string">"connect error in Connector::startInLoop "</span> &lt;&lt; savedErrno;</div><div class="line"><span class="symbol">      sockets:</span>:close(sockfd);</div><div class="line">      <span class="keyword">break</span>;</div><div class="line"><span class="symbol"></span></div><div class="line">    default:</div><div class="line">      LOG_SYSERR &lt;&lt; <span class="string">"Unexpected error in Connector::startInLoop "</span> &lt;&lt; savedErrno;</div><div class="line"><span class="symbol">      sockets:</span>:close(sockfd);</div><div class="line">      <span class="comment">// connectErrorCallback_();</span></div><div class="line">      <span class="keyword">break</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可见，对于非阻塞io，如果connect之后的返回值为0，或者errno设置为EINTR, EINPROGRESS, EISCONN, 那么代表连接成功或者正在连接的过程之中。 如果errno为EAGIN，EADDRINUSE，EADDRNOTAVAIL，ECONNREFUSED，ENETURNREACH, 那么表示连接失败。在linux tcp编程之中，对于连接失败的情况，可以移植的解决方式是重新创建一个socket fd，再次尝试连接。对于EACCES，EPERM，EAFNOSUPPORT，EALREADY，EBADF，EFAULT，ENOTSOCK的情况，表示不可恢复的连接失败，直接停止连接，对于其他未知的情况也做此处理。</p>
<p>现在，怎么知道连接成功了呢？以connect返回的sockfd创建一个channel，关注其可写事件。若channel可写，并且尝试使用<code>getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &amp;optval, &amp;optlen)</code>返回的errorCode为0，并且不是自连接，那么说明连接成功，可以将这个sockfd通过connectionCallback通知TcpClient。当然，如果调用的是ErrorCallback，那么close返回的fd，并且进行重试。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> <span class="string">Connector:</span>:handleWrite()</div><div class="line">&#123;</div><div class="line">  LOG_TRACE &lt;&lt; <span class="string">"Connector::handleWrite "</span> &lt;&lt; state_;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (state_ == kConnecting)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">int</span> sockfd = removeAndResetChannel();</div><div class="line">    <span class="keyword">int</span> err = <span class="string">sockets:</span>:getSocketError(sockfd);</div><div class="line">    <span class="keyword">if</span> (err)</div><div class="line">    &#123;</div><div class="line">      LOG_WARN &lt;&lt; <span class="string">"Connector::handleWrite - SO_ERROR = "</span></div><div class="line">               &lt;&lt; err &lt;&lt; <span class="string">" "</span> &lt;&lt; strerror_tl(err);</div><div class="line">      retry(sockfd);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">sockets:</span>:isSelfConnect(sockfd))</div><div class="line">    &#123;</div><div class="line">      LOG_WARN &lt;&lt; <span class="string">"Connector::handleWrite - Self connect"</span>;</div><div class="line">      retry(sockfd);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">      setState(kConnected);</div><div class="line">      <span class="keyword">if</span> (connect_)</div><div class="line">      &#123;</div><div class="line">        newConnectionCallback_(sockfd);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">else</span></div><div class="line">      &#123;</div><div class="line"><span class="symbol">        sockets:</span>:close(sockfd);</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">  &#123;</div><div class="line">    <span class="comment">// what happened?</span></div><div class="line">    <span class="keyword">assert</span>(state_ == kDisconnected);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// check if self connection</span></div><div class="line"><span class="keyword">bool</span> sockets::isSelfConnect(<span class="keyword">int</span> sockfd)</div><div class="line">&#123;</div><div class="line">  struct sockaddr_in6 localaddr = getLocalAddr(sockfd);</div><div class="line">  struct sockaddr_in6 peeraddr = getPeerAddr(sockfd);</div><div class="line">  <span class="built_in">if</span> (localaddr.sin6_family == AF_INET)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">const</span> struct sockaddr_in* laddr4 = <span class="keyword">reinterpret_cast</span>&lt;struct sockaddr_in*&gt;(&amp;localaddr);</div><div class="line">    <span class="keyword">const</span> struct sockaddr_in* raddr4 = <span class="keyword">reinterpret_cast</span>&lt;struct sockaddr_in*&gt;(&amp;peeraddr);</div><div class="line">    <span class="built_in">return</span> laddr4-&gt;sin_port == raddr4-&gt;sin_port</div><div class="line">        &amp;&amp; laddr4-&gt;sin_addr.s_addr == raddr4-&gt;sin_addr.s_addr;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">else</span> <span class="built_in">if</span> (localaddr.sin6_family == AF_INET6)</div><div class="line">  &#123;</div><div class="line">    <span class="built_in">return</span> localaddr.sin6_port == peeraddr.sin6_port</div><div class="line">        &amp;&amp; memcmp(&amp;localaddr.sin6_addr, &amp;peeraddr.sin6_addr, <span class="keyword">sizeof</span> localaddr.sin6_addr) == <span class="number">0</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">else</span></div><div class="line">  &#123;</div><div class="line">    <span class="built_in">return</span> false;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="怎么实现超时重连？"><a href="#怎么实现超时重连？" class="headerlink" title="怎么实现超时重连？"></a>怎么实现超时重连？</h2><p>对于retry的处理使用了Connector的retry方法，他会设置超时回调，回调的时间间隔设置为从500ms~30s, 每次重新retry会将间隔的时间加倍，当然时间间隔不可超过30s。</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">void Connector::retry(<span class="keyword">int</span> sockfd)</div><div class="line">&#123;</div><div class="line">  sockets::close(sockfd);</div><div class="line">  setState(kDisconnected);</div><div class="line">  <span class="keyword">if</span> (connect_)</div><div class="line">  &#123;</div><div class="line">    LOG_INFO &lt;&lt; <span class="string">"Connector::retry - Retry connecting to "</span> &lt;&lt; serverAddr_.toIpPort()</div><div class="line">             &lt;&lt; <span class="string">" in "</span> &lt;&lt; retryDelayMs_ &lt;&lt; <span class="string">" milliseconds. "</span>;</div><div class="line">    loop_-&gt;runAfter(retryDelayMs_/<span class="number">1000.0</span>,</div><div class="line">                    std::bind(&amp;Connector::startInLoop, shared_from_this()));</div><div class="line">    retryDelayMs_ = std::min(retryDelayMs_ * <span class="number">2</span>, kMaxRetryDelayMs);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">  &#123;</div><div class="line">    LOG_DEBUG &lt;&lt; <span class="string">"do not connect"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="对于stop的处理"><a href="#对于stop的处理" class="headerlink" title="对于stop的处理"></a>对于stop的处理</h2><p>如果要停止连接，那么首先设置<code>connect_</code>为false，表示不需要建立连接了，这样若handleWrite之中返回了正常的sockfd，那么我也不要通过这个sockfd创建一个连接，而是直接将其close。并且因为<code>connect_</code>设置设置为false，后续进行retry的时候也不会尝试重新连接的。</p>
<p>紧接着的是对stopInLoop的调用，这里对正在处于连接状态的channel进行了reset处理，并且将没有确定连接的sockfd关闭。</p>
]]></content>
      
        <categories>
            
            <category> muduo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
            <tag> muduo </tag>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++中的可变长参数模板]]></title>
      <url>/2017/06/10/C-%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%8F%98%E9%95%BF%E5%8F%82%E6%95%B0/</url>
      <content type="html"><![CDATA[<h1 id="C-中的可变长参数"><a href="#C-中的可变长参数" class="headerlink" title="C++ 中的可变长参数"></a>C++ 中的可变长参数</h1><h2 id="基本格式"><a href="#基本格式" class="headerlink" title="基本格式"></a>基本格式</h2><p>在C++中，可变长参数模板可以用来应对未知长度函数参数的问题。其基本格式如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Args&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(Args ... args)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span> ...(Args) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 类型参数的数目</span></div><div class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span> ...(args) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 函数参数的数目</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>可变参数函数通常是递归的，第一步调用处理包中的第一个实参，然后用剩余的实参来调用自身。如下的print示例程序就演示了这种用法。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="comment">// 递归调用的终点</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; os, <span class="keyword">const</span> T&amp; t)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> os &lt;&lt; t;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</div><div class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; os, <span class="keyword">const</span> T&amp; t, <span class="keyword">const</span> Args&amp;... rest)</span></span></div><div class="line">&#123;</div><div class="line">  os &lt;&lt; t &lt;&lt; <span class="string">", "</span>;</div><div class="line">  <span class="comment">// 递归用剩余参数进行调用</span></div><div class="line">  <span class="keyword">return</span> print(os, rest...);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  print(<span class="built_in">cout</span>, <span class="number">1</span>, <span class="number">2.0</span>, <span class="literal">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>递归会执行如下序列：</p>
<ol>
<li>print(cout, 1, 2.0, false)</li>
<li>print(cout, 2.0, false)</li>
<li>print(cout, false)</li>
</ol>
<p>当定义可变参数版本的print的时候，非可变参数版本的声明必须在作用域中。否则，可变参数版本会无限递归。</p>
<h2 id="包扩展"><a href="#包扩展" class="headerlink" title="包扩展"></a>包扩展</h2><p>可以利用包扩展机制，对可变长模板参数中的每一个参数进行相同的调用。如下所示代码演示了对输入的每个参数都调用了函数<code>no_operation</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="comment">// 递归调用的终点</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; os, <span class="keyword">const</span> T&amp; t)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> os &lt;&lt; t;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function">T <span class="title">no_operation</span><span class="params">(<span class="keyword">const</span> T&amp; val)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> val;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</div><div class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; os, <span class="keyword">const</span> T&amp; t, <span class="keyword">const</span> Args&amp;... rest)</span></span></div><div class="line">&#123;</div><div class="line">  os &lt;&lt; t &lt;&lt; <span class="string">", "</span>;</div><div class="line">  <span class="comment">// 递归用剩余参数进行调用</span></div><div class="line">  <span class="comment">// 对所有的参数统一调用no_operation</span></div><div class="line">  <span class="keyword">return</span> print(os, no_operation(rest)...);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="comment">// 实际调用no_operation的次数为3，和输入的参数的个数一致</span></div><div class="line">  print(<span class="built_in">cout</span>, <span class="number">1</span>, <span class="number">2.0</span>, <span class="literal">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="转发参数包"><a href="#转发参数包" class="headerlink" title="转发参数包"></a>转发参数包</h2><p>借助std::forward，可以安全的将输入的可变长参数转发给其他函数，这样vector通过emplace_back就在容器内部直接通过输入的参数构造需要插入的对象。</p>
<p>最简单的例子是make_unique，如下所示：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">template&lt;typename T, typename... Args&gt;</div><div class="line"><span class="symbol">std:</span><span class="symbol">:unique_ptr&lt;T&gt;</span> make_unique(Args&amp;&amp; ...args)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">return</span> <span class="symbol">std:</span><span class="symbol">:unique_ptr&lt;T&gt;</span>(new T(<span class="symbol">std:</span><span class="symbol">:forward&lt;Args&gt;</span>(args)...));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb filter_block]]></title>
      <url>/2017/06/09/leveldb-filter-block/</url>
      <content type="html"><![CDATA[<h1 id="leveldb-filter-block解析"><a href="#leveldb-filter-block解析" class="headerlink" title="leveldb filter_block解析"></a>leveldb filter_block解析</h1><h2 id="filter-meta-block-文件格式"><a href="#filter-meta-block-文件格式" class="headerlink" title="filter meta block 文件格式"></a>filter meta block 文件格式</h2><p>首先借助leveldb文档leveldb File format可以确定filter meta block内部的格式如下所示：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[filter 0]</div><div class="line">[filter 1]</div><div class="line">[filter 2]</div><div class="line">[filter 3]</div><div class="line">[filter 4]</div><div class="line"><span class="built_in">..</span>.</div><div class="line">[filter N-1]</div><div class="line">[offset of<span class="built_in"> filter </span>0]                  : 4 bytes</div><div class="line">[offset of<span class="built_in"> filter </span>1]                  : 4 bytes</div><div class="line">[offset of<span class="built_in"> filter </span>2]                  : 4 bytes</div><div class="line"><span class="built_in">..</span>.</div><div class="line">[offset of<span class="built_in"> filter </span>N-1]                : 4 bytes</div><div class="line">[offset of beginning of offset array] : 4 bytes</div><div class="line">lg(base)                              : 1 byte</div></pre></td></tr></table></figure>
<p>借助源码和文档，我对filter meta block的格式有了深刻的理解。每一个filter对应负责一个block offset范围内的key的组织。对于第i个filter，它所管理的key在文件中的偏移范围是<code>[i * base ... (i+1) * base - 1]</code>。在leveldb中，base默认被设置为2KB，也就是说每2KB长度的偏移位置对应一个独立的filter。</p>
<p>每一个key借助hash函数(maybe, 看filter策略具体实现)产生一个滤值，一个filter可能会有多个这样的滤值。所有filter的滤值最后从前到后依次保存在filter meta block之中。然后再存放每一个filter对应滤值的偏移位置。根据当前filter和下一个filter的offset值就可以确定当前filter对应滤值在filter meta block中偏移值的范围。紧接着存放最后一个filter对应滤值offset范围的下界，通过它我们还能知道整个块中filter的数量。filter meta block的最后存放的是log(base)的值，由它我们能知道每个filter所能管理的文件偏移大小限制。</p>
<p>附上一张网上找到的图</p>
<p><img src="http://static.zybuluo.com/zhoudayang/6aqrw4rs2v9q6b3wcbaemvk6/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-10%20%E4%B8%8B%E5%8D%884.31.48.png" alt="leveldb-filter"></p>
<h2 id="FilterBlockBuilder"><a href="#FilterBlockBuilder" class="headerlink" title="FilterBlockBuilder"></a>FilterBlockBuilder</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// A FilterBlockBuilder is used to construct all of the filters for a</span></div><div class="line"><span class="comment">// particular Table.  It generates a single string which is stored as</span></div><div class="line"><span class="comment">// a special block in the Table.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// The sequence of calls to FilterBlockBuilder must match the regexp:</span></div><div class="line"><span class="comment">//      (StartBlock AddKey*)* Finish</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterBlockBuilder</span> &#123;</span></div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">FilterBlockBuilder</span><span class="params">(<span class="keyword">const</span> FilterPolicy*)</span></span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">StartBlock</span><span class="params">(<span class="keyword">uint64_t</span> block_offset)</span></span>;</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AddKey</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span></span>;</div><div class="line">  <span class="function">Slice <span class="title">Finish</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="function"><span class="keyword">void</span> <span class="title">GenerateFilter</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">  <span class="keyword">const</span> FilterPolicy* policy_;   <span class="comment">// 过滤策略</span></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> keys_;              <span class="comment">// 存放所有的key</span></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; start_;     <span class="comment">// 存放每一个key在keys_的下标范围</span></div><div class="line">  <span class="comment">// 存放最终的结果</span></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> result_;            <span class="comment">// Filter data computed so far</span></div><div class="line">  <span class="comment">// 用于记录每个filter产生的滤值的临时容器</span></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Slice&gt; tmp_keys_;   <span class="comment">// policy_-&gt;CreateFilter() argument</span></div><div class="line">  <span class="comment">// 记录每个filter的offset开始位置</span></div><div class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint32_t</span>&gt; filter_offsets_;</div><div class="line"></div><div class="line">  <span class="comment">// No copying allowed</span></div><div class="line">  FilterBlockBuilder(<span class="keyword">const</span> FilterBlockBuilder&amp;);</div><div class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> FilterBlockBuilder&amp;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>FilterBlockBuilder对象在构造的时候需要指定FilterPolicy，它要用其来生成滤值。在对偏移为block_offset的文件进行操作前，首先需要调用StartBlock。此方法确定输入的偏移值对应哪一个filter，并且将filter_index更小的filter的滤值写入result_。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> FilterBlockBuilder::StartBlock(<span class="keyword">uint64_t</span> block_offset) &#123;</div><div class="line">  <span class="comment">// kFilterBase的大小为2048</span></div><div class="line">  <span class="keyword">uint64_t</span> filter_index = (block_offset / kFilterBase);</div><div class="line">  assert(filter_index &gt;= filter_offsets_.size());</div><div class="line">  <span class="keyword">while</span> (filter_index &gt; filter_offsets_.size()) &#123;</div><div class="line">    <span class="comment">// 若filter_index 的值更大，将之前的filter对应的滤值加入result_</span></div><div class="line">    GenerateFilter();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>请注意，要按照偏移的先后顺序调用StartBlock和AddKey方法，这样才能保证filter meta block内部顺序和实际偏移一致。</p>
<p>GenerateFilter方法将当前filter所管理的key按照输入的Filter策略转换为滤值，并且记录当前filter对应的滤值在block中偏移的开始位置。<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 产生新的filter</span></div><div class="line"><span class="keyword">void</span> FilterBlockBuilder::GenerateFilter() &#123;</div><div class="line">  <span class="comment">// 对应key的数目</span></div><div class="line">  <span class="keyword">const</span> size_t num_keys = start_.<span class="built_in">size</span>();</div><div class="line">  <span class="built_in">if</span> (num_keys == <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">// Fast path if there are no keys for this filter</span></div><div class="line">    <span class="comment">// 记录此filter的偏移位置</span></div><div class="line">    filter_offsets_.push_back(result_.<span class="built_in">size</span>());</div><div class="line">    <span class="built_in">return</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Make list of keys from flattened key structure</span></div><div class="line">  start_.push_back(keys_.<span class="built_in">size</span>());  <span class="comment">// Simplify length computation</span></div><div class="line">  tmp_keys_.resize(num_keys);</div><div class="line">  <span class="built_in">for</span> (size_t i = <span class="number">0</span>; i &lt; num_keys; i++) &#123;</div><div class="line">    <span class="comment">// 每个key的开头位置</span></div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* base = keys_.data() + start_[i];</div><div class="line">    <span class="comment">// 每个key的长度</span></div><div class="line">    size_t length = start_[i+<span class="number">1</span>] - start_[i];</div><div class="line">    tmp_keys_[i] = Slice(base, length);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Generate filter for current set of keys and append to result_.</span></div><div class="line">  <span class="comment">// 记录此filter的偏移起始位置</span></div><div class="line">  filter_offsets_.push_back(result_.<span class="built_in">size</span>());</div><div class="line">  <span class="comment">// 创建filter，输入key对应的数组，数组大小，存放结果的result</span></div><div class="line">  <span class="comment">// result存放key对应的hash值</span></div><div class="line">  policy_-&gt;CreateFilter(&amp;tmp_keys_[<span class="number">0</span>], <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(num_keys), &amp;result_);</div><div class="line"></div><div class="line">  tmp_keys_.<span class="built_in">clear</span>();</div><div class="line">  keys_.<span class="built_in">clear</span>();</div><div class="line">  start_.<span class="built_in">clear</span>();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在加入新的key时，会在start_中记录新的key在keys_中的开始位置，然后将其append到keys_之中，这样之后借助keys_和start_t就能重构所有输入的key。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> FilterBlockBuilder::AddKey(<span class="keyword">const</span> Slice&amp; <span class="built_in">key</span>) &#123;</div><div class="line">  Slice k = <span class="built_in">key</span>;</div><div class="line">  start_.push_back(keys_.<span class="built_in">size</span>());</div><div class="line">  keys_.<span class="built_in">append</span>(k.data(), k.<span class="built_in">size</span>());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Finish函数的操作很容易理解，他首先记录所有filter对应滤值的offset范围，注意要补充记录最后一个filter的滤值offset下界。当然也要按照文件格式记录log(base)值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Slice FilterBlockBuilder::Finish() &#123;</div><div class="line">  <span class="keyword">if</span> (!start_.empty()) &#123;</div><div class="line">    GenerateFilter();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Append array of per-filter offsets</span></div><div class="line">  <span class="comment">// 这是滤值数组的结束位置offset，将这个值记住</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> array_offset = result_.size();</div><div class="line">  <span class="comment">// 存放filter对应的offset开头位置</span></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; filter_offsets_.size(); i++) &#123;</div><div class="line">    PutFixed32(&amp;result_, filter_offsets_[i]);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 存放最后一个filter offset的下界</span></div><div class="line">  PutFixed32(&amp;result_, array_offset);</div><div class="line">  <span class="comment">// 存放kFilterBaseLg的大小</span></div><div class="line">  <span class="comment">// kFilterBaseLg = log(base)</span></div><div class="line">  result_.push_back(kFilterBaseLg);  <span class="comment">// Save encoding parameter in result</span></div><div class="line">  <span class="keyword">return</span> Slice(result_);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="FilterBlockReader"><a href="#FilterBlockReader" class="headerlink" title="FilterBlockReader"></a>FilterBlockReader</h2><p>相比FilterBlockBuilder，FilterBLockReader可以理解为它的逆过程。</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class FilterBlockReader &#123;</div><div class="line"><span class="keyword"> public</span>:</div><div class="line"> // REQUIRES: <span class="string">"contents"</span><span class="built_in"> and </span>*policy must stay live while *this is live.</div><div class="line">  FilterBlockReader(const FilterPolicy* policy,<span class="built_in"> const </span>Slice&amp; contents);</div><div class="line">  bool KeyMayMatch(uint64_t block_offset,<span class="built_in"> const </span>Slice&amp; key);</div><div class="line"></div><div class="line"><span class="keyword"> private</span>:</div><div class="line"> <span class="built_in"> const </span>FilterPolicy* policy_;</div><div class="line"> <span class="built_in"> const </span>char* data_;    // Pointer to filter data (at block-start)</div><div class="line">                         // 指向offset数组靠近block尾部的开始处</div><div class="line"> <span class="built_in"> const </span>char* offset_;  // Pointer to beginning of offset<span class="built_in"> array </span>(at block-end)</div><div class="line">  // filter的数目</div><div class="line">  size_t num_;          // Number of entries in offset<span class="built_in"> array</span></div><div class="line">  size_t base_lg_;      // Encoding parameter (see kFilterBaseLg in .cc file)</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在构造函数中，Reader根据文件格式获取base的log值，filter的数目，第一个filter的偏移的开始位置。</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">FilterBlockReader::FilterBlockReader(const FilterPolicy* policy,</div><div class="line">                                    <span class="built_in"> const </span>Slice&amp; contents)</div><div class="line">   <span class="keyword"> :</span> policy_(policy),</div><div class="line">      data_(NULL),</div><div class="line">      offset_(NULL),</div><div class="line">      num_(0),</div><div class="line">      base_lg_(0) &#123;</div><div class="line">  size_t n = contents.size();</div><div class="line">  // size<span class="built_in"> not </span>enough to hold start<span class="built_in"> and </span>offset<span class="built_in"> array</span></div><div class="line"> <span class="built_in"> if </span>(n &lt; 5) return;  // 1 byte for base_lg_<span class="built_in"> and </span>4 for start of offset<span class="built_in"> array</span></div><div class="line">  // 取出base_lg_的值</div><div class="line">  base_lg_ = contents[n-1];</div><div class="line">  uint32_t last_word = DecodeFixed32(contents.data() + n - 5);</div><div class="line">  // 滤值数组的最后元素的末尾位置不可能超出n-5，否则无法容纳</div><div class="line"> <span class="built_in"> if </span>(last_word &gt; n - 5) return;</div><div class="line">  data_ = contents.data();</div><div class="line">  // 指向最后一个filter滤值的offset下界位置</div><div class="line">  offset_ = data_ + last_word;</div><div class="line">  // filter的数量</div><div class="line">  num_ = (n - 5 - last_word) / 4;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至于对key的匹配判断，对于输入的block_offset，计算出它属于哪一个filter。然后取出此filter的所有滤值，和key按照filter策略计算得到的滤纸进行匹配，相同说明可能匹配，否则不能匹配。对于计算得到的filter的index值大于block中filter的数量的情况，也被认为是匹配，即错误被当做潜在的匹配。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool</span> FilterBlockReader::KeyMayMatch(<span class="keyword">uint64_t</span> block_offset, <span class="keyword">const</span> Slice&amp; key) &#123;</div><div class="line">  <span class="keyword">uint64_t</span> index = block_offset &gt;&gt; base_lg_;</div><div class="line">  <span class="keyword">if</span> (index &lt; num_) &#123;</div><div class="line">    <span class="comment">// 滤值开始位置对应的偏移</span></div><div class="line">    <span class="keyword">uint32_t</span> start = DecodeFixed32(offset_ + index*<span class="number">4</span>);</div><div class="line">    <span class="comment">// 滤值结束位置对应的偏移</span></div><div class="line">    <span class="comment">// 实质上是下一个filter的offset开始位置</span></div><div class="line">    <span class="keyword">uint32_t</span> limit = DecodeFixed32(offset_ + index*<span class="number">4</span> + <span class="number">4</span>);</div><div class="line">    <span class="keyword">if</span> (start &lt;= limit &amp;&amp; limit &lt;= <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(offset_ - data_)) &#123;</div><div class="line">      Slice filter = Slice(data_ + start, limit - start);</div><div class="line">      <span class="keyword">return</span> policy_-&gt;KeyMayMatch(key, filter);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start == limit) &#123;</div><div class="line">      <span class="comment">// Empty filters do not match any keys</span></div><div class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// Errors are treated as potential matches</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb File format]]></title>
      <url>/2017/06/09/leveldb-File-format/</url>
      <content type="html"><![CDATA[<h1 id="leveldb-File-format"><a href="#leveldb-File-format" class="headerlink" title="leveldb File format"></a>leveldb File format</h1><figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="keyword">beginning_of_file&gt;</span></div><div class="line">[<span class="meta">data</span> <span class="keyword">block </span><span class="number">1</span>]</div><div class="line">[<span class="meta">data</span> <span class="keyword">block </span><span class="number">2</span>]</div><div class="line"><span class="symbol">...</span></div><div class="line">[<span class="meta">data</span> <span class="keyword">block </span>N]</div><div class="line">[meta <span class="keyword">block </span><span class="number">1</span>]</div><div class="line"><span class="symbol">...</span></div><div class="line">[meta <span class="keyword">block </span>K]</div><div class="line">[metaindex <span class="keyword">block]</span></div><div class="line">[index <span class="keyword">block]</span></div><div class="line">[Footer]        (fixed size<span class="comment">; starts at file_size - sizeof(Footer))</span></div><div class="line">&lt;end_of_file&gt;</div></pre></td></tr></table></figure>
<p>文件之中包含内部指针。每一个这样的指针被称为BlockHandle，包含下述信息。</p>
<figure class="highlight avrasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">offset:</span> varint64</div><div class="line"><span class="symbol">size:</span>   varint64</div></pre></td></tr></table></figure>
<p>varint的解释可以查看<a href="https://developers.google.com/protocol-buffers/docs/encoding#varints" target="_blank" rel="external">varints</a>。</p>
<ol>
<li>文件中的键值对按照顺序进行存储，并被分割成为数据块序列。这些数据块在文件中从前到后依次排列。每一个数据块按照<code>block_builder.cc</code>中的代码进行格式化，然后进行可选的压缩。</li>
<li>在数据块之后，我们存储了一串元数据块。支持的meta块类型会在下文描述。未来可能会增加新的meta块类型。每一个meta块也是使用<code>block_builder.cc</code>中的代码进行格式化，然后进行可选的压缩。</li>
<li>一个命名为”metaindex”的块。对于其他的meta块每个块记录一个entry，key是meta块的名称，value是指向对应meta块的BlockHandle。</li>
<li>一个名为”index”的块。这个块对于每个数据块记录一个entry，key是大于对应数据块最后一个key，并且小于紧接着的下一个数据块的第一个key的字符串。value是数据块的BlockHandle。</li>
<li>每个文件的末尾是一个固定长度的footer，包含metaindex和index块的BlockHandle，以及一个魔数。</li>
</ol>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="string">metaindex_handle:</span> <span class="keyword">char</span>[p];     <span class="comment">// Block handle for metaindex</span></div><div class="line"><span class="string">index_handle:</span>     <span class="keyword">char</span>[q];     <span class="comment">// Block handle for index</span></div><div class="line"><span class="string">padding:</span>          <span class="keyword">char</span>[<span class="number">40</span>-p-q];<span class="comment">// zeroed bytes to make fixed length</span></div><div class="line">                               <span class="comment">// (40==2*BlockHandle::kMaxEncodedLength)</span></div><div class="line"><span class="string">magic:</span>            fixed64;     <span class="comment">// == 0xdb4775248b80fb57 (little-endian)</span></div></pre></td></tr></table></figure>
<h2 id="“filter”-Meta-Block"><a href="#“filter”-Meta-Block" class="headerlink" title="“filter” Meta Block"></a>“filter” Meta Block</h2><p>若数据库打开时指定了<code>FilterPolicy</code>，每个table会存储一个filter块。”metaindex”块包含一条entry，记录从<code>filter.&lt;N&gt;</code>到filter块的BlockHandle的映射。其中<code>&lt;N&gt;</code>是filter policy的<code>Name()</code>方法返回的字符串。</p>
<p>filter块存储了filters序列，其中filter i包含<code>FilterPolicy::CreateFilter()</code>所有key的输出，这些key在文件中偏移的范围在范围：</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[ i*base ... (<span class="name">i+1</span>)*base-1 ]</div></pre></td></tr></table></figure>
<p>当前，”base”是2KB，举例来说，若块x和y在文件中的偏移范围是<code>[0KB .. 2KB-1]</code>，所有x和y的将会调用<code>FilterPolicy::CreateFilter()</code>转换成filter，生成的filter是第一个filter block。</p>
<p>filter块的格式如下所示：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[filter 0]</div><div class="line">[filter 1]</div><div class="line">[filter 2]</div><div class="line"><span class="built_in">..</span>.</div><div class="line">[filter N-1]</div><div class="line"></div><div class="line">[offset of<span class="built_in"> filter </span>0]                  : 4 bytes</div><div class="line">[offset of<span class="built_in"> filter </span>1]                  : 4 bytes</div><div class="line">[offset of<span class="built_in"> filter </span>2]                  : 4 bytes</div><div class="line"><span class="built_in">..</span>.</div><div class="line">[offset of<span class="built_in"> filter </span>N-1]                : 4 bytes</div><div class="line"></div><div class="line">[offset of beginning of offset array] : 4 bytes</div><div class="line">lg(base)                              : 1 byte</div></pre></td></tr></table></figure>
<p>filter块末尾的offset array 允许从data block偏移到对应filter的有效映射。</p>
<h2 id="“Stats”-Meta-Block"><a href="#“Stats”-Meta-Block" class="headerlink" title="“Stats” Meta Block"></a>“Stats” Meta Block</h2><p>这一meta块包含一串统计信息。key是统计名称，value是统计值。</p>
<p>TODO(postrelease): record following stats.</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">data</span> <span class="built_in">size</span></div><div class="line"><span class="built_in">index</span> <span class="built_in">size</span></div><div class="line">key <span class="built_in">size</span> (uncompressed)</div><div class="line"><span class="keyword">value</span> <span class="built_in">size</span> (uncompressed)</div><div class="line"><span class="keyword">number</span> of entries</div><div class="line"><span class="keyword">number</span> of <span class="keyword">data</span> blocks</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb Log format]]></title>
      <url>/2017/06/09/leveldb-Log-format/</url>
      <content type="html"><![CDATA[<h1 id="leveldb-Log-format"><a href="#leveldb-Log-format" class="headerlink" title="leveldb Log format"></a>leveldb Log format</h1><p>日志文件内容是一系列32KB大小的block序列。唯一的例外是文件的末尾可能包含一个不完整的block。</p>
<p>每一个block包含一个记录序列：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">block := record* trailer?</div><div class="line"> record :=</div><div class="line">   checksum: <span class="keyword">uint32</span>     <span class="comment">// crc32c of type and data[] ; little-endian</span></div><div class="line">   length: <span class="keyword">uint16</span>       <span class="comment">// little-endian</span></div><div class="line">   <span class="keyword">type</span>: <span class="keyword">uint8</span>          <span class="comment">// One of FULL, FIRST, MIDDLE, LAST</span></div><div class="line">   data: <span class="keyword">uint8</span>[length]</div></pre></td></tr></table></figure>
<p>一条记录不会在一个block的最后6 byte处开始（因为放不下）。所有剩余的bytes组成trailer，需要包含全0的bytes，并且必须被读者跳过。</p>
<p>例外：若当前block恰好剩余7bytes，增加一个新的非0长度的record，写者必须将第一条记录（包含长度为0的用户数据）填充之前block剩余的7bytes，将用户数据写入之后的block之中。</p>
<p>在未来可能会增加新的类型。 一些读者可能会跳过不理解的记录类型，其他的可能会报告他跳过了一些值。</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attr">FULL</span> == <span class="number">1</span></div><div class="line"><span class="attr">FIRST</span> == <span class="number">2</span></div><div class="line"><span class="attr">MIDDLE</span> == <span class="number">3</span></div><div class="line"><span class="attr">LAST</span> == <span class="number">4</span></div></pre></td></tr></table></figure>
<p>FULL record包含完整的用户记录。</p>
<p>FIRST, MIDDLE, LAST 用于标志分片的用户记录（一般由于block边界）。FIRST是用户记录第一个分片的类型，LAST是用户记录最后一个分片的类型，MIDDLE是所有的用户记录中间分片的类型。</p>
<p>例子： 一个用户记录序列：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">A: <span class="built_in">length</span> <span class="number">1000</span></div><div class="line">B: <span class="built_in">length</span> <span class="number">97270</span></div><div class="line">C: <span class="built_in">length</span> <span class="number">8000</span></div></pre></td></tr></table></figure>
<p><strong>A</strong> 会是第一个block的FULL记录。</p>
<p><strong>B</strong> 会被分为3个分段：第一段占据第一块剩余部分，第二段占据第二个block的全部，第三段占据第三个block的前面的绝大部分。第三个block会剩余6bytes空间，会被空余当做trailer。</p>
<p><strong>C</strong> 会在第4个block中存放一条FULL记录。</p>
<hr>
<h2 id="Some-benefits-over-the-recordio-format"><a href="#Some-benefits-over-the-recordio-format" class="headerlink" title="Some benefits over the recordio format:"></a>Some benefits over the recordio format:</h2><ol>
<li>重新同步时不需要任何启发式查找 - 只需要到下一个block边界并进行扫描。 如果有错误，跳过去处理下一个block。附加的好处是，当一个log文件的部分内容被嵌入另一个log文件作为record时，我们不会陷入疑惑。</li>
<li>在大致的边界上进行分割（例如，mapreduce）非常简单：找到下一个块的边界，跳过record直到我们找到一条FULL或者FIRST类型的记录。</li>
<li>对于大的records，我们不需要额外的缓存。</li>
</ol>
<h2 id="Some-downside-compared-to-recordio-format"><a href="#Some-downside-compared-to-recordio-format" class="headerlink" title="Some downside compared to recordio format:"></a>Some downside compared to recordio format:</h2><ol>
<li>不会对小的record进行打包。可以通过增加新的记录类型来解决。所以这是当前实现的缺陷，不是这一format的缺点。</li>
<li>没有压缩。 这个也可以通过增加新的记录类型来解决。</li>
</ol>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leveldb 实现文档]]></title>
      <url>/2017/06/09/leveldb-%E5%AE%9E%E7%8E%B0%E6%96%87%E6%A1%A3/</url>
      <content type="html"><![CDATA[<h1 id="leveldb-实现文档"><a href="#leveldb-实现文档" class="headerlink" title="leveldb 实现文档"></a>leveldb 实现文档</h1><h2 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h2><p>leveldb的实现和一个单点的<a href="http://research.google.com/archive/bigtable.html" target="_blank" rel="external">Bigtable tablet(section 5.2)</a>相似。但是内部文件的组成有所不同，下面会进行解释。</p>
<p>每一个数据库都是存储在目录下一系列的文件集合构成。有以下几种不同的文件类型：</p>
<h3 id="Log-files"><a href="#Log-files" class="headerlink" title="Log files"></a>Log files</h3><p>一个log文件存储了最近更新的序列。每一个更新记录都被追加到当前的log文件中。当log文件达到预先设置的大小（可能是默认值4MB），它会被转换为一个<code>sorted table</code>，并且会创建一个新的log文件记录未来的更新。</p>
<p>当前log文件的副本被保存在内存中(<code>memtable</code>)。每次读都会检索这一副本，所以读操作能反映所有已经记录日志的更新。</p>
<h3 id="Sorted-tables"><a href="#Sorted-tables" class="headerlink" title="Sorted tables"></a>Sorted tables</h3><p>一个sorted table（*.ldb）保存了按照key排序的entry序列。每一个entry可能是key和对应的value，或者key和对应的删除标记。（在旧版本的sorted tables中，删除标记用于覆盖过期的value）。</p>
<p>sorted tables组成的集合被组织成为level序列。从一个log文件中生成的sorted table被放置在一个特殊的 <strong>young level</strong>之中（也被称为level-0）。当 <strong>young files</strong> 的数目超出阈值（当前设置为4），所有的 <strong>young files</strong> 和key区间重叠的level-1文件合并生成一系列新的level-1文件（我们创建的新的level-1文件的大小是2MB）。</p>
<p><strong>young level</strong> 文件可能包含重叠区间的key。但是其他level的文件都有唯一的没有重叠的key区间范围。对于 &gt;= 1的level值L，当level-L级别的文件大小超过（10^L）MB时（例如，level-1达到10MB, level-2达到100MB，···），一个level-L文件和所有key区间重叠的level-(L+1)文件合并为level-(L+1)的一系列新文件。这些合并操作使用块读取和写入操作，将新的更新从<code>young level</code> 逐步迁移到最大的level，减少了昂贵的寻道操作。</p>
<h3 id="Manifset"><a href="#Manifset" class="headerlink" title="Manifset"></a>Manifset</h3><p>一个MANIFEST文件列出了组成每个level的sorted tables文件集合，对应key的范围，其他重要的元数据。一个新的MANIFEST文件（会在文件名中植入新的number）会在数据库重新打开时创建。MANIFEST是日志文件，服务状态的更新（新增或者移除文件）会追加到这一log文件。</p>
<h3 id="Current"><a href="#Current" class="headerlink" title="Current"></a>Current</h3><p>CURRENT是一个简单的文本文件，其中包含了最新的MANIFEST文件的名字。</p>
<h3 id="Info-logs"><a href="#Info-logs" class="headerlink" title="Info logs"></a>Info logs</h3><p>日志信息被写入命名为LOG或者Log.old的文件。</p>
<h3 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h3><p>其他文件各种用途的文件，用途如名称所述，例如LOCK， *.dbtmp。</p>
<h2 id="level0"><a href="#level0" class="headerlink" title="level0"></a>level0</h2><p>当log文件增长到某个值（默认是1MB）时：</p>
<p>创建新的memtable和log文件，将未来的更新写入新的文件。</p>
<p>在后台：</p>
<ol>
<li>将之前memtable的内容写入到sstable</li>
<li>丢弃memtable</li>
<li>删除旧的log和memtable文件，将新的sstable文件加入<strong>young level</strong>。</li>
</ol>
<h2 id="Compactions"><a href="#Compactions" class="headerlink" title="Compactions"></a>Compactions</h2><p>当level L的文件大小超出限制之后，我们会在后台线程之中进行压缩合并。合并操作选取level-L中的一个文件和下一个level-(L+1)中key区间重叠的所有文件进行。注意到，如果level-L文件key区间只和level-(L+1)文件部分重叠，那么level-(L+1)文件会作为合并操作的输入，并且在合并操作完成之后被丢弃。例外：因为level-0文件比较特殊（level-0文件可能彼此之间互相重叠），我们对于从level-0到level-1的合并操作特殊对待：一个level-0级别的合并操作会选取所有key区间重叠的level-0文件进行，因而选取的level-0文件数量可能超过1。</p>
<p>一个合并压缩操作合并选取的文件内容，产生一个level-(L+1)序列的文件。在当前输出文件大小到达目标大小（2MB），我们会创建新的level-(L+1)文件。我们在当前输出文件的大小增长到和超过10个level-(L+2)级别的文件重叠时，也会产生新的输出文件。最后一条规则确保之后对于level-(L+1)文件的合并操作不会涉及到level-(L+2)中的过多的文件。</p>
<p>旧的文件会被丢弃，新的文件会被记录以更新当前服务状态。</p>
<p>对于一个特定level来说，合并操作会在key区间轮转进行。更详细地说，对于每一个level L，我们记录上一次level-L合并操作最后的key，下次level L的合并操作将会选取第一个大于这个key的文件开始（如果没有这样的文件，就从key区间的开头位置开始）。</p>
<p>合并操作会丢弃覆盖的值。若更高level的文件key的区间没有包含标记为删除的key，也会将其删除。</p>
<h3 id="Timing"><a href="#Timing" class="headerlink" title="Timing"></a>Timing</h3><p>Level-0的合并操作会读取至多4个1MB大小的level-0文件，在最坏的情况下会读取所有的level-1文件（10MB）。因此，我们会读14MB，写14MB。</p>
<p>除了特殊的level-0合并操作，我们会从level-L选取一个2MB的文件。在最坏的情况下，这一文件会和level-(L+1)的中12个level-L文件大小的，level-(L+1)文件key区间重合（10因为level-(L+1) 比level-L的文件大小大10倍，剩余2因为level-L的文件大小和level-L+1的文件大小通常不对齐而增加的界限)。所以合并操作会读取26MB，写入26MB。假设硬盘的IO速度为100MB/s(现代设备的速度)，最坏的合并操作需要大约0.5秒。</p>
<p>若我们限制后台写入的速度，比如说全速100MB/s的10%，一个合并操作可能花费5秒。如果用户写入的速度是10MB/s，我们需要创建很多level-0文件（~50个，用于存放5*10MB）。由于每次读操作会合并过多的文件，这会显著增加读的开销。</p>
<p>解决方式：</p>
<ol>
<li>为了减小这一问题，当level-0文件数量很大时，我们可能需要增加生成新的log文件的阈值。然而，缺点是这个阈值越大，我们需要更多的内存来存放对应的memtable。</li>
<li>当level-0文件数量上涨时，我们可能需要人为减小写入速度。</li>
<li>减小大幅度merge的开销。可能大多数level-0文件都是未经压缩存放在cache中，我们只需要O(N)复杂度的合并操作。</li>
</ol>
<h3 id="Number-of-files"><a href="#Number-of-files" class="headerlink" title="Number of files"></a>Number of files</h3><p>不再总是创建2MB的文件，更大level的文件有更大的大小能减小文件总数，虽然以合并操作更加突发为代价。另外，我们能将文件集合存放在不同的路径下。</p>
<p>2001年2月4日，一个在ext3文件系统下的实验演示了对于目录下不同数量，相同大小（100K）文件的打开操作的时间开销：</p>
<table>
<thead>
<tr>
<th style="text-align:right">Files in directory</th>
<th style="text-align:right">Microseconds to open a file</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right">1000</td>
<td style="text-align:right">9</td>
</tr>
<tr>
<td style="text-align:right">10000</td>
<td style="text-align:right">10</td>
</tr>
<tr>
<td style="text-align:right">100000</td>
<td style="text-align:right">16</td>
</tr>
</tbody>
</table>
<p>所以对于现代文件系统，分片没有必要？</p>
<h2 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h2><ul>
<li>读取CURRENT找到最新提交的MANIFEST文件的名称</li>
<li>读取MANIFEST文件</li>
<li>清除无效文件</li>
<li>我们可以打开所有的sstables文件，但是可能晚点打开会更好…</li>
<li>将log文件转换为新的level-0 sstable文件</li>
<li>将更新新写入新的log文件（以恢复后的序列）</li>
</ul>
<h2 id="Garbage-collection-of-file"><a href="#Garbage-collection-of-file" class="headerlink" title="Garbage collection of file"></a>Garbage collection of file</h2><p><code>DeleteObsoleteFiles()</code>在每次合并和恢复操作的最后会被调用。他会查找database中用到的所有文件，删除不是当前log文件的所有log文件，删除没被任何层引用并且不是有效合并操作输出的所有table文件。</p>
]]></content>
      
        <categories>
            
            <category> leveldb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leveldb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[muduo Channel]]></title>
      <url>/2017/06/08/muduo-Channel/</url>
      <content type="html"><![CDATA[<h4 id="实现简介"><a href="#实现简介" class="headerlink" title="实现简介"></a>实现简介</h4><p>channel一般用于抽象一个fd，包含fd当前关注的事件，出现事件更新需要在poller之中做出更新。poller获取到当前io复用返回的io事件之后，会更新channel之中的revent。在eventloop中会为当前活跃的channel进行事件处理，调用对应revent，io事件的回调函数。整个Channel类的实现非常简单明了。</p>
<h4 id="重点-tie"><a href="#重点-tie" class="headerlink" title="重点:tie"></a>重点:tie</h4><p>可能出现这种情况，我们设置的回调函数是某个类的成员函数，此类对象使用shared_ptr进行管理。如果在回调函数之中对此shared_ptr进行了reset或者release处理，那么此回调函数就会立即失效，因为类对象被回收了。对于这种特殊情况，可以使用<code>std::weak_ptr&lt;void&gt; tie</code>来存放该shared_ptr的弱引用（使用弱引用是为了避免增加shared_ptr的引用计数，导致对象一直无法得以析构。每次进行事件处理的时候，若之前设置了tie，那么首先tie进行提升，保证回调函数处理期间此shared_ptr管理的对象不会被析构。</p>
<p>tie这一措施是为了TcpConnectionPtr而设计了，如果在某个回调函数之中，reset了此TcpConnectionPtr, 那么TcpConnection的其他回调函数就会失效。所以在处理这些事件期间，需要提升此TcpConnectionPtr的引用计数，阻止TcpConnectionPtr被析构。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">void</span> Channel::tie(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">void</span>&gt;&amp; obj)</div><div class="line">&#123;</div><div class="line">  tie_ = obj;</div><div class="line">  tied_ = <span class="literal">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> Channel::handleEvent(Timestamp receiveTime)</div><div class="line">&#123;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">void</span>&gt; guard;</div><div class="line">  <span class="keyword">if</span> (tied_)</div><div class="line">  &#123;</div><div class="line">    guard = tie_.lock();</div><div class="line">    <span class="keyword">if</span> (guard)</div><div class="line">    &#123;</div><div class="line">      handleEventWithGuard(receiveTime);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">  &#123;</div><div class="line">    handleEventWithGuard(receiveTime);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">void</span> Channel::handleEventWithGuard(Timestamp receiveTime)</div><div class="line">&#123;</div><div class="line">  eventHandling_ = <span class="literal">true</span>;</div><div class="line">  LOG_TRACE &lt;&lt; reventsToString();</div><div class="line">  <span class="keyword">if</span> ((revents_ &amp; POLLHUP) &amp;&amp; !(revents_ &amp; POLLIN))</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">if</span> (logHup_)</div><div class="line">    &#123;</div><div class="line">      LOG_WARN &lt;&lt; <span class="string">"fd = "</span> &lt;&lt; fd_ &lt;&lt; <span class="string">" Channel::handle_event() POLLHUP"</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (closeCallback_) closeCallback_();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (revents_ &amp; POLLNVAL)</div><div class="line">  &#123;</div><div class="line">    LOG_WARN &lt;&lt; <span class="string">"fd = "</span> &lt;&lt; fd_ &lt;&lt; <span class="string">" Channel::handle_event() POLLNVAL"</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (revents_ &amp; (POLLERR | POLLNVAL))</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">if</span> (errorCallback_) errorCallback_();</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (revents_ &amp; (POLLIN | POLLPRI | POLLRDHUP))</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">if</span> (readCallback_) readCallback_(receiveTime);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">if</span> (revents_ &amp; POLLOUT)</div><div class="line">  &#123;</div><div class="line">    <span class="keyword">if</span> (writeCallback_) writeCallback_();</div><div class="line">  &#125;</div><div class="line">  eventHandling_ = <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> muduo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
            <tag> muduo </tag>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[muduo Buffer]]></title>
      <url>/2017/06/08/muduo-Buffer/</url>
      <content type="html"><![CDATA[<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>在muduo之中，使用std::vector来存放网络中传输的数据，包括从要发送给对方的数据以及从对方接收的数据。在Buffer之中，预留了 prependable 的缓存，可以在buffer之中加入前缀而无需移动整个buffer。整个buffer分为prependable, readable, writable bytes. Buffer 的布局可以参考下图。</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="string">///</span> A buffer class modeled after org.jboss.netty.buffer.ChannelBuffer</div><div class="line"><span class="string">///</span></div><div class="line"><span class="string">///</span> @code</div><div class="line"><span class="string">///</span> +<span class="params">-------------------</span>+<span class="params">------------------</span>+<span class="params">------------------</span>+</div><div class="line"><span class="string">///</span> | prependable bytes |  readable bytes  |  writable bytes  |</div><div class="line"><span class="string">///</span> |                   |     <span class="params">(CONTENT)</span>    |                  |</div><div class="line"><span class="string">///</span> +<span class="params">-------------------</span>+<span class="params">------------------</span>+<span class="params">------------------</span>+</div><div class="line"><span class="string">///</span> |                   |                  |                  |</div><div class="line"><span class="string">///</span> 0      &lt;=      readerIndex   &lt;=   writerIndex    &lt;=     size</div><div class="line"><span class="string">///</span> @endcode&gt;&gt;&gt;</div></pre></td></tr></table></figure>
<p>Buffer的作用非常之大，将用户程序从繁琐的Buffer相关读写操作之中解放了出来。</p>
<h4 id="重点"><a href="#重点" class="headerlink" title="重点"></a>重点</h4><p>在muduo的Buffer之中，对read进行了特殊处理。因为从socket读，会调用read，涉及到一次上下文切换，为了减少系统调用的开销，read的调用次数是越少越好，因而需要尽可能预先分配更大的用户空间缓存。另一方面，如果对于每个连接都分配过多的缓存，那么会造成因为内存容量有限而造成支持的并发连接数目有限的问题。这二者之间存在矛盾。</p>
<p>在muduo之中，使用分配在堆栈上的缓存区域以及readv系统调用，将读取的数据优先存入buffer之中，超过限制才存放在堆栈上分配的缓存之中，最后再统一汇总到buffer之中。离开readFd函数之后，堆栈上分配的读取缓存会被自动回收。具体可以参考以下代码:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ssize_t</span> Buffer::readFd(<span class="keyword">int</span> fd, <span class="keyword">int</span>* savedErrno)</div><div class="line">&#123;</div><div class="line">  <span class="comment">// saved an ioctl()/FIONREAD call to tell how much to read</span></div><div class="line">  <span class="keyword">char</span> extrabuf[<span class="number">65536</span>];</div><div class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">vec</span>[2];</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> writable = writableBytes();</div><div class="line">  vec[<span class="number">0</span>].iov_base = begin()+writerIndex_;</div><div class="line">  vec[<span class="number">0</span>].iov_len = writable;</div><div class="line">  vec[<span class="number">1</span>].iov_base = extrabuf;</div><div class="line">  vec[<span class="number">1</span>].iov_len = <span class="keyword">sizeof</span> extrabuf;</div><div class="line">  <span class="comment">// when there is enough space in this buffer, don't read into extrabuf.</span></div><div class="line">  <span class="comment">// when extrabuf is used, we read 128k-1 bytes at most.</span></div><div class="line">  <span class="keyword">const</span> <span class="keyword">int</span> iovcnt = (writable &lt; <span class="keyword">sizeof</span> extrabuf) ? <span class="number">2</span> : <span class="number">1</span>;</div><div class="line">  <span class="keyword">const</span> <span class="keyword">ssize_t</span> n = sockets::readv(fd, vec, iovcnt);</div><div class="line">  <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</div><div class="line">  &#123;</div><div class="line">    *savedErrno = errno;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (implicit_cast&lt;<span class="keyword">size_t</span>&gt;(n) &lt;= writable)</div><div class="line">  &#123;</div><div class="line">    writerIndex_ += n;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">  &#123;</div><div class="line">    writerIndex_ = buffer_.size();</div><div class="line">    append(extrabuf, n - writable);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// if (n == writable + sizeof extrabuf)</span></div><div class="line">  <span class="comment">// &#123;</span></div><div class="line">  <span class="comment">//   goto line_30;</span></div><div class="line">  <span class="comment">// &#125;</span></div><div class="line">  <span class="keyword">return</span> n;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> muduo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
            <tag> muduo </tag>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[auto关键字]]></title>
      <url>/2017/06/08/auto%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      <content type="html"><![CDATA[<h3 id="5-优先使用auto而非显示类型声明"><a href="#5-优先使用auto而非显示类型声明" class="headerlink" title="5. 优先使用auto而非显示类型声明"></a>5. 优先使用auto而非显示类型声明</h3><p>在C++之中，使用auto关键字声明类型可以将程序员从输入繁琐的类型中解放出来，编译器会自动推导出变量的实际类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> It&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">dwim</span><span class="params">(It b, It e)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">while</span>(b != e)&#123;</div><div class="line">    <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;It&gt;::value_type</div><div class="line">    currValue = *b;</div><div class="line">      ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用auto关键字</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">template</span>&lt;typename <span class="keyword">It&gt;</span></div><div class="line"><span class="symbol">void</span> dwim(<span class="keyword">It </span><span class="keyword">b, </span><span class="keyword">It </span>e)</div><div class="line">&#123;</div><div class="line">  <span class="meta">while</span>(<span class="keyword">b </span>!= e)&#123;</div><div class="line">    auto currValue = *<span class="keyword">b;</span></div><div class="line">      ...</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在C++14中，lambda函数的参数都可以使用auto来定义。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> derefLess =                            <span class="comment">// C++14 comparison</span></div><div class="line">  [](<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p1,                          <span class="comment">// function for</span></div><div class="line">     <span class="keyword">const</span> <span class="keyword">auto</span>&amp; p2)                          <span class="comment">// values pointed</span></div><div class="line">  &#123; <span class="keyword">return</span> *p1 &lt; *p2; &#125;;</div></pre></td></tr></table></figure></p>
<p>使用auto生命类型还可以将我们从类型截断的问题中解放出来：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; arrs;</div><div class="line"><span class="keyword">auto</span> size = arrs.size();</div></pre></td></tr></table></figure></p>
<p>在C++中，<code>unordered_map</code>的key的类型是const类型的，所以即便采取如下方式遍历<code>unordered_map</code>容器，仍然会产生临时对象：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;</div><div class="line">   ...</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt;&amp; p : m)</div><div class="line">&#123;</div><div class="line">   ...                  <span class="comment">// do something with p</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是借助auto，我们不仅使声明更加简洁，还避开了此问题：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; m;</div><div class="line">   ...</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : m)</div><div class="line">&#123;</div><div class="line">   ...                  <span class="comment">// do something with p</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="6-当auto推导出非预期类型时应当使用显示的类型初始化"><a href="#6-当auto推导出非预期类型时应当使用显示的类型初始化" class="headerlink" title="6. 当auto推导出非预期类型时应当使用显示的类型初始化"></a>6. 当auto推导出非预期类型时应当使用显示的类型初始化</h3><p>在C++中，因为标准不允许返回对bit的引用，所以对于<code>vector&lt;bool&gt;</code>标准库进行了特化处理，其<code>[]</code>运算符返回的是<code>std::vector&lt;bool&gt;::reference</code>类型的临时对象。对临时对象的修改会被其同步到vector中，因而这样使用auto关键字是不合规的。<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Widget w;</div><div class="line">…</div><div class="line">auto highPriority = features<span class="comment">(w)</span>[<span class="number">5</span>];         <span class="comment">// w是不是个高优先级的？</span></div><div class="line">…</div><div class="line">processWidget<span class="comment">(w, highPriority)</span>;             <span class="comment">// 配合优先级处理w</span></div></pre></td></tr></table></figure></p>
<p>在这种情况下，我们只需显示指出<code>highPriority</code>的类型为bool即可规避此问题。</p>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> modern effective C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[C++类型推导]]></title>
      <url>/2017/06/08/C++%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/</url>
      <content type="html"><![CDATA[<h3 id="1-理解模板类型推导"><a href="#1-理解模板类型推导" class="headerlink" title="1. 理解模板类型推导"></a>1. 理解模板类型推导</h3><h4 id="1-expr是T-amp"><a href="#1-expr是T-amp" class="headerlink" title="1. expr是T&amp;"></a>1. expr是T&amp;</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T &amp; param)</span></span>;</div><div class="line"><span class="comment">// 我们声明如下变量</span></div><div class="line"><span class="keyword">int</span> x = <span class="number">27</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x;</div></pre></td></tr></table></figure>
<p>函数调用时，推导出的Param和T的类型如下：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">f(x);  // T <span class="keyword">is</span> <span class="built_in">int</span>, param's <span class="keyword">type</span> <span class="keyword">is</span> <span class="built_in">int</span>&amp;</div><div class="line">f(cx); // T <span class="keyword">is</span> <span class="keyword">const</span> <span class="built_in">int</span>, param's <span class="keyword">type</span> <span class="keyword">is</span> <span class="keyword">const</span> <span class="built_in">int</span>&amp;</div><div class="line">f(rx); // T <span class="keyword">is</span> <span class="keyword">const</span> <span class="built_in">int</span>, param's <span class="keyword">type</span> <span class="keyword">is</span> <span class="keyword">const</span> <span class="built_in">int</span>&amp;</div></pre></td></tr></table></figure>
<p>需要特别注明的是，通过T&amp;的方式传入数组，数组的大小信息不会丢失。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;typename T&gt;</div><div class="line"><span class="built_in">void</span> f(T&amp; param);</div><div class="line"><span class="keyword">const</span> <span class="built_in">int</span> arr[<span class="number">10</span>];</div><div class="line">f(arr); // T <span class="keyword">is</span> <span class="keyword">const</span> <span class="built_in">int</span>[<span class="number">10</span>], param <span class="keyword">type</span> <span class="keyword">is</span> <span class="keyword">const</span> <span class="built_in">int</span>(&amp;)[<span class="number">10</span>]</div></pre></td></tr></table></figure>
<p><strong>在类型推导期间，数组和函数将退化为指针类型，除非他们是被初始化为引用。</strong></p>
<h4 id="2-expr是const-T-amp"><a href="#2-expr是const-T-amp" class="headerlink" title="2. expr是const T&amp;"></a>2. expr是const T&amp;</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp; param)</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> x = <span class="number">27</span>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span> cx = x;</div><div class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rx = x;</div></pre></td></tr></table></figure>
<p>在进行类型推导的时候，rx的引用性被忽略了。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">f(x);  // T <span class="keyword">is</span> <span class="built_in">int</span>, param's <span class="keyword">type</span> <span class="keyword">is</span> <span class="keyword">const</span> <span class="built_in">int</span>&amp;</div><div class="line">f(cx); // T <span class="keyword">is</span> <span class="built_in">int</span>, param's <span class="keyword">type</span> <span class="keyword">is</span> <span class="keyword">const</span> <span class="built_in">int</span>&amp;</div><div class="line">f(rx); // T <span class="keyword">is</span> <span class="built_in">int</span>, param's <span class="keyword">type</span> <span class="keyword">is</span> <span class="keyword">const</span> <span class="built_in">int</span>&amp;</div></pre></td></tr></table></figure>
<h4 id="3-param是一个指针类型"><a href="#3-param是一个指针类型" class="headerlink" title="3. param是一个指针类型"></a>3. param是一个指针类型</h4><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;typename T&gt;</div><div class="line"><span class="built_in">void</span> f(T* param); // param <span class="keyword">is</span> now a <span class="built_in">pointer</span></div><div class="line"></div><div class="line"><span class="built_in">int</span> x = <span class="number">27</span>;</div><div class="line"><span class="keyword">const</span> <span class="built_in">int</span>* px = &amp;x;</div><div class="line">f(&amp;x); // T <span class="keyword">is</span> <span class="built_in">int</span>, param's <span class="keyword">type</span> <span class="keyword">is</span> <span class="built_in">int</span> *</div><div class="line">f(px); // T <span class="keyword">is</span> <span class="keyword">const</span> <span class="built_in">int</span>, param's <span class="keyword">type</span> <span class="keyword">is</span> <span class="keyword">const</span> <span class="built_in">int</span> *</div></pre></td></tr></table></figure>
<h4 id="4-param是universial-reference"><a href="#4-param是universial-reference" class="headerlink" title="4. param是universial reference"></a>4. param是universial reference</h4><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;typename T&gt;</div><div class="line"><span class="built_in">void</span> f(T&amp;&amp; param); // param <span class="keyword">is</span> now a universal reference</div><div class="line"></div><div class="line"><span class="built_in">int</span> x = <span class="number">27</span>;</div><div class="line"><span class="keyword">const</span> <span class="built_in">int</span> cx = x;</div><div class="line"><span class="keyword">const</span> <span class="built_in">int</span>&amp; rx = x;</div><div class="line"></div><div class="line">f(x);  // x <span class="keyword">is</span> lvalue, so T <span class="keyword">is</span> <span class="built_in">int</span>&amp;, param's <span class="keyword">type</span> <span class="keyword">is</span> also <span class="built_in">int</span>&amp;</div><div class="line">f(cx); // cx <span class="keyword">is</span> lvalue, so T <span class="keyword">is</span> <span class="keyword">const</span> <span class="built_in">int</span>&amp;, param's <span class="keyword">type</span> <span class="keyword">is</span> also <span class="keyword">const</span> <span class="built_in">int</span>&amp;</div><div class="line">f(rx); // rx <span class="keyword">is</span> lvalue, so T <span class="keyword">is</span> <span class="keyword">const</span> <span class="built_in">int</span>&amp;, param's <span class="keyword">type</span> <span class="keyword">is</span> also <span class="keyword">const</span> <span class="built_in">int</span>&amp;</div><div class="line">f(<span class="number">27</span>); // <span class="number">27</span> <span class="keyword">is</span> rvalue, so T <span class="keyword">is</span> <span class="built_in">int</span>, param's typs <span class="keyword">is</span> <span class="built_in">int</span>&amp;&amp;</div></pre></td></tr></table></figure>
<h4 id="5-param-既不是指针也不是引用"><a href="#5-param-既不是指针也不是引用" class="headerlink" title="5. param 既不是指针也不是引用"></a>5. param 既不是指针也不是引用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T param)</span></span>;</div></pre></td></tr></table></figure>
<p>当ParamType既不是指针也不是引用的时候，我们按照值传递的方式进行处理。<br>需要举出一个有用的例子：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;typename T&gt;</div><div class="line"><span class="built_in">void</span> f(T param);</div><div class="line"><span class="keyword">const</span> <span class="built_in">char</span>* <span class="keyword">const</span> <span class="keyword">ptr</span> = <span class="string">"hello world\n"</span>;</div><div class="line">f(<span class="keyword">ptr</span>); // param's <span class="keyword">type</span> <span class="keyword">is</span> <span class="keyword">const</span> <span class="built_in">char</span>*</div></pre></td></tr></table></figure></p>
<h3 id="2-理解auto自动类型推导"><a href="#2-理解auto自动类型推导" class="headerlink" title="2. 理解auto自动类型推导"></a>2. 理解auto自动类型推导</h3><p>auto 类型对象推导通常和模板类型推导是相同的。<br>例子：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="built_in">char</span> name[] = <span class="string">"zhouyang"</span>;</div><div class="line"><span class="built_in">auto</span> arr1 = name; // arr1's <span class="keyword">type</span> <span class="keyword">is</span> <span class="keyword">const</span> <span class="built_in">char</span>*</div><div class="line"><span class="built_in">auto</span>&amp; arr2 = name; // arr2's <span class="keyword">type</span> <span class="keyword">is</span> <span class="keyword">const</span> <span class="built_in">char</span>(&amp;)[<span class="number">9</span>]</div><div class="line"><span class="built_in">void</span> someFunc(<span class="built_in">int</span>, double); // someFunc <span class="keyword">is</span> a function</div><div class="line"><span class="built_in">auto</span> func1 = someFunc; // func1's <span class="keyword">type</span> <span class="keyword">is</span> <span class="built_in">void</span>(*)(<span class="built_in">int</span>, double)</div><div class="line"><span class="built_in">auto</span>&amp; func2 = someFunc; // func2's <span class="keyword">type</span> <span class="keyword">is</span> <span class="built_in">void</span>(&amp;)(<span class="built_in">int</span>, double)</div></pre></td></tr></table></figure></p>
<p>唯一的例外是：使用auto和大括号进行初始化时，自动推导<code>为std::initializer_list</code>。并且，对于使用括号进行的初始化，模板类型推导会失败。</p>
<h3 id="3-理解decltype"><a href="#3-理解decltype" class="headerlink" title="3. 理解decltype"></a>3. 理解decltype</h3><p>decltype 一般情况下总是返回变量名或者表达式的类型而不做任何的修改。<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="built_in">int</span> i = <span class="number">0</span>; // decltype(i) <span class="keyword">is</span> <span class="keyword">const</span> <span class="built_in">int</span></div><div class="line"><span class="built_in">bool</span> f(<span class="keyword">const</span> <span class="type">Widget</span>&amp; w) // decltype(w) <span class="keyword">is</span> <span class="keyword">const</span> <span class="type">Widget</span>&amp;</div><div class="line"><span class="type">Widget</span> W; // decltype(w) <span class="keyword">is</span> <span class="type">Widget</span></div></pre></td></tr></table></figure></p>
<p>在C++14中，提供了decltype(auto)的支持，它从初始化式子中推导类型，使用的是decltype的推导规则。<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Widget w;</div><div class="line">cosnt Widget&amp; cw = w;</div><div class="line">auto myWidget1 = cw; // myWidget1<span class="symbol">'s</span> <span class="keyword">type</span> <span class="type">is </span>Widget</div><div class="line">decltype(auto) myWidget2 = cw; // decltype <span class="keyword">type</span> <span class="type">deduction:</span></div><div class="line">                               // myWidget2<span class="symbol">'s</span> <span class="keyword">type</span> <span class="type">is </span>const Widget&amp;</div><div class="line">// 注：可以在模板中使用</div></pre></td></tr></table></figure></p>
<p>特例:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> temp = <span class="number">10</span>;</div><div class="line"></div><div class="line">  <span class="keyword">decltype</span>((temp)) temp1 = temp; <span class="comment">// temp1's type is int&amp; </span></div><div class="line">  temp1 = <span class="number">1</span>;</div><div class="line">  <span class="built_in">cout</span>&lt;&lt; temp &lt;&lt; <span class="built_in">endl</span>;</div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//输出 : 1</span></div></pre></td></tr></table></figure></p>
<h3 id="4-了解如何查看推导出的类型"><a href="#4-了解如何查看推导出的类型" class="headerlink" title="4. 了解如何查看推导出的类型"></a>4. 了解如何查看推导出的类型</h3><p>可以利用编译器诊断来完成。我们想要知道被推导出的类型，可以首先声明一个类模板，但是不定义它。那么编译器的出错信息会包含推导的类型信息。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TD</span>;</span></div></pre></td></tr></table></figure></p>
<p>通过编译器内置的宏定义，可以输出函数类型<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_func</span><span class="params">(<span class="keyword">int</span>)</span></span></div><div class="line">&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__GNUC__)</span></div><div class="line">  <span class="built_in">cout</span> &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">elif</span> defined(_MSC_VER)</span></div><div class="line">  <span class="built_in">cout</span> &lt;&lt; __FUNCSIG__ &lt;&lt; <span class="built_in">endl</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  test_func(<span class="number">10</span>);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> C++ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> modern effective C++ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[muduo Acceptor]]></title>
      <url>/2017/06/08/muduo-Acceptor/</url>
      <content type="html"><![CDATA[<h4 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h4><p>Acceptr是muduo之中TcpServer用于接受连接的wrapper类。其中有一个成员acceptChannel_用于接受连接。其句柄是用于接受连接的socket fd。</p>
<p>上述acceptChannel_关注的是可读事件，可读代表有新的连接可以accept了。在关注可读事件之前需要首先开始监听。监听的backlog的限制采用的是Linux所支持的最大值: SOMAXCONN.</p>
<h4 id="特殊处理"><a href="#特殊处理" class="headerlink" title="特殊处理"></a>特殊处理</h4><p>在接受连接的时候，可能会出现这种问题：描述符用完了，这会导致accpet失败，并且返回<em>ENFILE</em>错误。但是并没有拒绝这一连接，连接仍然会在连接队列之中，这导致了下一次eventLoop中仍然会触发监听描述符的可读事件，这会导致busy loop。</p>
<ul>
<li>一种比较简单的解决方式是程序遇到这个问题，直接忽略，直到这种情况消失，但是这种解决方式会导致busy waiting。</li>
<li>另一种解决思路是记录除了EAGAIN或者EWOULDBLOCK其他任何错误，告诉用户出现了某种错误，并且停止监听描述符的可读事件，减少CPU的使用。</li>
<li>在libevent中，采用的是如下解决方式。首先打开/dev/null, 保留一个文件描述符，当accept出现ENFILE或者EMFILE错误的时候，关闭/dev/null，然后再次accept，并且close掉accept产生的fd，再次打开/dev/null，这是一种比较优雅的方式来拒绝客户端的连接。</li>
<li>最后一种比较sb的方式是遇到accept的这种错误，直接拒绝并且退出。这种方式比较容易受到Dos攻击。</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">void Acceptor::handleRead()</div><div class="line">&#123;</div><div class="line">  loop_-&gt;assertInLoopThread();</div><div class="line">  InetAddress peerAddr;</div><div class="line">  <span class="comment">//FIXME loop until no more</span></div><div class="line">  int connfd = acceptSocket_.accept(&amp;peerAddr);</div><div class="line">  <span class="keyword">if</span> (connfd &gt;= <span class="number">0</span>)</div><div class="line">  &#123;</div><div class="line">    <span class="comment">// string hostport = peerAddr.toIpPort();</span></div><div class="line">    <span class="comment">// LOG_TRACE &lt;&lt; "Accepts of " &lt;&lt; hostport;</span></div><div class="line">    <span class="keyword">if</span> (newConnectionCallback_)</div><div class="line">    &#123;</div><div class="line">      newConnectionCallback_(connfd, peerAddr);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">      sockets::close(connfd);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">else</span></div><div class="line">  &#123;</div><div class="line">    LOG_SYSERR &lt;&lt; <span class="string">"in Acceptor::handleRead"</span>;</div><div class="line">    <span class="comment">// Read the section named "The special problem of</span></div><div class="line">    <span class="comment">// accept()ing when you can't" in libev's doc.</span></div><div class="line">    <span class="comment">// By Marc Lehmann, author of libev.</span></div><div class="line">    <span class="keyword">if</span> (errno == EMFILE)</div><div class="line">    &#123;</div><div class="line">      ::close(idleFd_);</div><div class="line">      idleFd_ = ::accept(acceptSocket_.fd(), <span class="keyword">NULL</span>, <span class="keyword">NULL</span>);</div><div class="line">      ::close(idleFd_);</div><div class="line">      idleFd_ = ::open(<span class="string">"/dev/null"</span>, O_RDONLY | O_CLOEXEC);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> muduo </category>
            
        </categories>
        
        
        <tags>
            
            <tag> C++ </tag>
            
            <tag> muduo </tag>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
