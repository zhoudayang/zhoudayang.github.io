<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[auto关键字]]></title>
    <url>%2F2017%2F06%2F08%2Fauto%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[5. 优先使用auto而非显示类型声明在C++之中，使用auto关键字声明类型可以将程序员从输入繁琐的类型中解放出来，编译器会自动推导出变量的实际类型。 123456789template&lt;typename It&gt;void dwim(It b, It e)&#123; while(b != e)&#123; typename std::iterator_traits&lt;It&gt;::value_type currValue = *b; ... &#125;&#125; 使用auto关键字 12345678template&lt;typename It&gt;void dwim(It b, It e)&#123; while(b != e)&#123; auto currValue = *b; ... &#125;&#125; 在C++14中，lambda函数的参数都可以使用auto来定义。1234auto derefLess = // C++14 comparison [](const auto&amp; p1, // function for const auto&amp; p2) // values pointed &#123; return *p1 &lt; *p2; &#125;; 使用auto生命类型还可以将我们从类型截断的问题中解放出来：12std::vector&lt;int&gt; arrs;auto size = arrs.size(); 在C++中，unordered_map的key的类型是const类型的，所以即便采取如下方式遍历unordered_map容器，仍然会产生临时对象：1234567std::unordered_map&lt;std::string, int&gt; m; ...for (const std::pair&lt;std::string, int&gt;&amp; p : m)&#123; ... // do something with p&#125; 但是借助auto，我们不仅使声明更加简洁，还避开了此问题：1234567std::unordered_map&lt;std::string, int&gt; m; ...for (const auto&amp; p : m)&#123; ... // do something with p&#125; 6. 当auto推导出非预期类型时应当使用显示的类型初始化在C++中，因为标准不允许返回对bit的引用，所以对于vector&lt;bool&gt;标准库进行了特化处理，其[]运算符返回的是std::vector&lt;bool&gt;::reference类型的临时对象。对临时对象的修改会被其同步到vector中，因而这样使用auto关键字是不合规的。12345Widget w;…auto highPriority = features(w)[5]; // w是不是个高优先级的？…processWidget(w, highPriority); // 配合优先级处理w 在这种情况下，我们只需显示指出highPriority的类型为bool即可规避此问题。]]></content>
      <tags>
        <tag>modern effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++类型推导]]></title>
    <url>%2F2017%2F06%2F08%2FC%2B%2B%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[1. 理解模板类型推导1. expr是T&amp;123456template&lt;typename T&gt;void f(T &amp; param);// 我们声明如下变量int x = 27;const int cx = x;const int&amp; rx = x; 函数调用时，推导出的Param和T的类型如下： 123f(x); // T is int, param's type is int&amp;f(cx); // T is const int, param's type is const int&amp;f(rx); // T is const int, param's type is const int&amp; 需要特别注明的是，通过T&amp;的方式传入数组，数组的大小信息不会丢失。 1234template&lt;typename T&gt;void f(T&amp; param);int arr[10];f(arr); // T is const int[10], param type is const int(&amp;)[10] 在类型推导期间，数组和函数将退化为指针类型，除非他们是被初始化为引用。 2. expr是const T&amp;123456template&lt;typename T&gt;void f(const T&amp; param);int x = 27;const int cx = x;const int&amp; rx = x; 在进行类型推导的时候，rx的引用性被忽略了。 123f(x); // T is int, param's type is const int&amp;f(cx); // T is int, param's type is const int&amp;f(rx); // T is int, param's type is const int&amp; 3. param是一个指针类型1234567template&lt;typename T&gt;void f(T* param); // param is now a pointerint x = 27;const int* px = &amp;x;f(&amp;x); // T is int, param's type is int *f(px); // T is const int, param's type is const int * 4. param是universial reference1234567891011template&lt;typename T&gt;void f(T&amp;&amp; param); // param is now a universal referenceint x = 27;const int cx = x;const int rx = x;f(x); // x is lvalue, so T is int&amp;, param's type is also int&amp;f(cx); // cx is lvalue, so T is const int&amp;, param's type is also const int&amp;f(rx); // rx is lvalue, so T is const int&amp;, param's type is also const int&amp;f(27); // 27 is rvalue, so T is int, param's typs is int&amp;&amp; 5. param 既不是指针也不是引用12template&lt;typename T&gt;void f(T param); 当ParamType既不是指针也不是引用的时候，我们按照值传递的方式进行处理。需要举出一个有用的例子：1234template&lt;typename T&gt;void f(T param);const char* const ptr = "hello world\n";f(ptr); // param's type is const char* 2. 理解auto自动类型推导auto 类型对象推导通常和模板类型推导是相同的。例子：123456const char name[] = "zhouyang";auto arr1 = name; // arr1's type is const char*auto&amp; arr2 = name; // arr2's type is const char(&amp;)[9]void someFunc(int, double); // someFunc is a functionauto func1 = someFunc; // func1's type is void(*)(int, double)auto&amp; func2 = someFunc; // func2's type is void(&amp;)(int, double) 唯一的例外是：使用auto和大括号进行初始化时，自动推导为std::initializer_list。并且，对于使用括号进行的初始化，模板类型推导会失败。 3. 理解decltypedecltype 一般情况下总是返回变量名或者表达式的类型而不做任何的修改。123const int i = 0; // decltype(i) is const intbool f(const Widget&amp; w) // decltype(w) is const Widget&amp;Widget W; // decltype(w) is Widget 在C++14中，提供了decltype(auto)的支持，它从初始化式子中推导类型，使用的是decltype的推导规则。123456Widget w;cosnt Widget&amp; cw = w;auto myWidget1 = cw; // myWidget1's type is Widgetdecltype(auto) myWidget2 = cw; // decltype type deduction: // myWidget2's type is const Widget&amp;// 注：可以在模板中使用 特例:1234567891011121314#include &lt;iostream&gt;using namespace std;int main()&#123; int temp = 10; decltype((temp)) temp1 = temp; // temp1's type is int&amp; temp1 = 1; cout&lt;&lt; temp &lt;&lt; endl; return 0;&#125;//输出 : 1 4. 了解如何查看推导出的类型可以利用编译器诊断来完成。我们想要知道被推导出的类型，可以首先声明一个类模板，但是不定义它。那么编译器的出错信息会包含推导的类型信息。12template&lt;typename T&gt;class TD; 通过编译器内置的宏定义，可以输出函数类型1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void test_func(int)&#123;#if defined(__GNUC__) cout &lt;&lt; __PRETTY_FUNCTION__ &lt;&lt; endl;#elif defined(_MSC_VER) cout &lt;&lt; __FUNCSIG__ &lt;&lt; endl;#endif&#125;int main()&#123; test_func(10); return 0;&#125;]]></content>
      <tags>
        <tag>modern effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[muduo Acceptor]]></title>
    <url>%2F2017%2F06%2F08%2Fmuduo-Acceptor%2F</url>
    <content type="text"><![CDATA[运行流程Acceptr是muduo之中TcpServer用于接受连接的wrapper类。其中有一个成员acceptChannel_用于接受连接。其句柄是用于接受连接的socket fd。 上述acceptChannel_关注的是可读事件，可读代表有新的连接可以accept了。在关注可读事件之前需要首先开始监听。监听的backlog的限制采用的是Linux所支持的最大值: SOMAXCONN. 特殊处理在接受连接的时候，可能会出现这种问题：描述符用完了，这会导致accpet失败，并且返回ENFILE错误。但是并没有拒绝这一连接，连接仍然会在连接队列之中，这导致了下一次eventLoop中仍然会触发监听描述符的可读事件，这会导致busy loop。 一种比较简单的解决方式是程序遇到这个问题，直接忽略，直到这种情况消失，但是这种解决方式会导致busy waiting。 另一种解决思路是记录除了EAGAIN或者EWOULDBLOCK其他任何错误，告诉用户出现了某种错误，并且停止监听描述符的可读事件，减少CPU的使用。 在libevent中，采用的是如下解决方式。首先打开/dev/null, 保留一个文件描述符，当accept出现ENFILE或者EMFILE错误的时候，关闭/dev/null，然后再次accept，并且close掉accept产生的fd，再次打开/dev/null，这是一种比较优雅的方式来拒绝客户端的连接。 最后一种比较sb的方式是遇到accept的这种错误，直接拒绝并且退出。这种方式比较容易受到Dos攻击。 12345678910111213141516171819202122232425262728293031323334void Acceptor::handleRead()&#123; loop_-&gt;assertInLoopThread(); InetAddress peerAddr; //FIXME loop until no more int connfd = acceptSocket_.accept(&amp;peerAddr); if (connfd &gt;= 0) &#123; // string hostport = peerAddr.toIpPort(); // LOG_TRACE &lt;&lt; "Accepts of " &lt;&lt; hostport; if (newConnectionCallback_) &#123; newConnectionCallback_(connfd, peerAddr); &#125; else &#123; sockets::close(connfd); &#125; &#125; else &#123; LOG_SYSERR &lt;&lt; "in Acceptor::handleRead"; // Read the section named "The special problem of // accept()ing when you can't" in libev's doc. // By Marc Lehmann, author of libev. if (errno == EMFILE) &#123; ::close(idleFd_); idleFd_ = ::accept(acceptSocket_.fd(), NULL, NULL); ::close(idleFd_); idleFd_ = ::open("/dev/null", O_RDONLY | O_CLOEXEC); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>muduo</tag>
        <tag>C++</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>